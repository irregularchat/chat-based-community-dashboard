
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AdminEvent
 * 
 */
export type AdminEvent = $Result.DefaultSelection<Prisma.$AdminEventPayload>
/**
 * Model DashboardSettings
 * 
 */
export type DashboardSettings = $Result.DefaultSelection<Prisma.$DashboardSettingsPayload>
/**
 * Model CommunityBookmark
 * 
 */
export type CommunityBookmark = $Result.DefaultSelection<Prisma.$CommunityBookmarkPayload>
/**
 * Model DashboardAnnouncement
 * 
 */
export type DashboardAnnouncement = $Result.DefaultSelection<Prisma.$DashboardAnnouncementPayload>
/**
 * Model UserInvitation
 * 
 */
export type UserInvitation = $Result.DefaultSelection<Prisma.$UserInvitationPayload>
/**
 * Model CommunityEvent
 * 
 */
export type CommunityEvent = $Result.DefaultSelection<Prisma.$CommunityEventPayload>
/**
 * Model VerificationCode
 * 
 */
export type VerificationCode = $Result.DefaultSelection<Prisma.$VerificationCodePayload>
/**
 * Model MatrixRoomMember
 * 
 */
export type MatrixRoomMember = $Result.DefaultSelection<Prisma.$MatrixRoomMemberPayload>
/**
 * Model UserNote
 * 
 */
export type UserNote = $Result.DefaultSelection<Prisma.$UserNotePayload>
/**
 * Model Invite
 * 
 */
export type Invite = $Result.DefaultSelection<Prisma.$InvitePayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model UserGroup
 * 
 */
export type UserGroup = $Result.DefaultSelection<Prisma.$UserGroupPayload>
/**
 * Model ModeratorPermission
 * 
 */
export type ModeratorPermission = $Result.DefaultSelection<Prisma.$ModeratorPermissionPayload>
/**
 * Model MatrixUser
 * 
 */
export type MatrixUser = $Result.DefaultSelection<Prisma.$MatrixUserPayload>
/**
 * Model MatrixRoom
 * 
 */
export type MatrixRoom = $Result.DefaultSelection<Prisma.$MatrixRoomPayload>
/**
 * Model MatrixRoomMembership
 * 
 */
export type MatrixRoomMembership = $Result.DefaultSelection<Prisma.$MatrixRoomMembershipPayload>
/**
 * Model MatrixSyncStatus
 * 
 */
export type MatrixSyncStatus = $Result.DefaultSelection<Prisma.$MatrixSyncStatusPayload>
/**
 * Model MatrixUserCache
 * 
 */
export type MatrixUserCache = $Result.DefaultSelection<Prisma.$MatrixUserCachePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminEvent`: Exposes CRUD operations for the **AdminEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminEvents
    * const adminEvents = await prisma.adminEvent.findMany()
    * ```
    */
  get adminEvent(): Prisma.AdminEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboardSettings`: Exposes CRUD operations for the **DashboardSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardSettings
    * const dashboardSettings = await prisma.dashboardSettings.findMany()
    * ```
    */
  get dashboardSettings(): Prisma.DashboardSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communityBookmark`: Exposes CRUD operations for the **CommunityBookmark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityBookmarks
    * const communityBookmarks = await prisma.communityBookmark.findMany()
    * ```
    */
  get communityBookmark(): Prisma.CommunityBookmarkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dashboardAnnouncement`: Exposes CRUD operations for the **DashboardAnnouncement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardAnnouncements
    * const dashboardAnnouncements = await prisma.dashboardAnnouncement.findMany()
    * ```
    */
  get dashboardAnnouncement(): Prisma.DashboardAnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userInvitation`: Exposes CRUD operations for the **UserInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInvitations
    * const userInvitations = await prisma.userInvitation.findMany()
    * ```
    */
  get userInvitation(): Prisma.UserInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communityEvent`: Exposes CRUD operations for the **CommunityEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityEvents
    * const communityEvents = await prisma.communityEvent.findMany()
    * ```
    */
  get communityEvent(): Prisma.CommunityEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationCode`: Exposes CRUD operations for the **VerificationCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationCodes
    * const verificationCodes = await prisma.verificationCode.findMany()
    * ```
    */
  get verificationCode(): Prisma.VerificationCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matrixRoomMember`: Exposes CRUD operations for the **MatrixRoomMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatrixRoomMembers
    * const matrixRoomMembers = await prisma.matrixRoomMember.findMany()
    * ```
    */
  get matrixRoomMember(): Prisma.MatrixRoomMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userNote`: Exposes CRUD operations for the **UserNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNotes
    * const userNotes = await prisma.userNote.findMany()
    * ```
    */
  get userNote(): Prisma.UserNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invite`: Exposes CRUD operations for the **Invite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invites
    * const invites = await prisma.invite.findMany()
    * ```
    */
  get invite(): Prisma.InviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userGroup`: Exposes CRUD operations for the **UserGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGroups
    * const userGroups = await prisma.userGroup.findMany()
    * ```
    */
  get userGroup(): Prisma.UserGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moderatorPermission`: Exposes CRUD operations for the **ModeratorPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModeratorPermissions
    * const moderatorPermissions = await prisma.moderatorPermission.findMany()
    * ```
    */
  get moderatorPermission(): Prisma.ModeratorPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matrixUser`: Exposes CRUD operations for the **MatrixUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatrixUsers
    * const matrixUsers = await prisma.matrixUser.findMany()
    * ```
    */
  get matrixUser(): Prisma.MatrixUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matrixRoom`: Exposes CRUD operations for the **MatrixRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatrixRooms
    * const matrixRooms = await prisma.matrixRoom.findMany()
    * ```
    */
  get matrixRoom(): Prisma.MatrixRoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matrixRoomMembership`: Exposes CRUD operations for the **MatrixRoomMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatrixRoomMemberships
    * const matrixRoomMemberships = await prisma.matrixRoomMembership.findMany()
    * ```
    */
  get matrixRoomMembership(): Prisma.MatrixRoomMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matrixSyncStatus`: Exposes CRUD operations for the **MatrixSyncStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatrixSyncStatuses
    * const matrixSyncStatuses = await prisma.matrixSyncStatus.findMany()
    * ```
    */
  get matrixSyncStatus(): Prisma.MatrixSyncStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matrixUserCache`: Exposes CRUD operations for the **MatrixUserCache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatrixUserCaches
    * const matrixUserCaches = await prisma.matrixUserCache.findMany()
    * ```
    */
  get matrixUserCache(): Prisma.MatrixUserCacheDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    AdminEvent: 'AdminEvent',
    DashboardSettings: 'DashboardSettings',
    CommunityBookmark: 'CommunityBookmark',
    DashboardAnnouncement: 'DashboardAnnouncement',
    UserInvitation: 'UserInvitation',
    CommunityEvent: 'CommunityEvent',
    VerificationCode: 'VerificationCode',
    MatrixRoomMember: 'MatrixRoomMember',
    UserNote: 'UserNote',
    Invite: 'Invite',
    Group: 'Group',
    UserGroup: 'UserGroup',
    ModeratorPermission: 'ModeratorPermission',
    MatrixUser: 'MatrixUser',
    MatrixRoom: 'MatrixRoom',
    MatrixRoomMembership: 'MatrixRoomMembership',
    MatrixSyncStatus: 'MatrixSyncStatus',
    MatrixUserCache: 'MatrixUserCache'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "adminEvent" | "dashboardSettings" | "communityBookmark" | "dashboardAnnouncement" | "userInvitation" | "communityEvent" | "verificationCode" | "matrixRoomMember" | "userNote" | "invite" | "group" | "userGroup" | "moderatorPermission" | "matrixUser" | "matrixRoom" | "matrixRoomMembership" | "matrixSyncStatus" | "matrixUserCache"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AdminEvent: {
        payload: Prisma.$AdminEventPayload<ExtArgs>
        fields: Prisma.AdminEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminEventPayload>
          }
          findFirst: {
            args: Prisma.AdminEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminEventPayload>
          }
          findMany: {
            args: Prisma.AdminEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminEventPayload>[]
          }
          create: {
            args: Prisma.AdminEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminEventPayload>
          }
          createMany: {
            args: Prisma.AdminEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminEventPayload>[]
          }
          delete: {
            args: Prisma.AdminEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminEventPayload>
          }
          update: {
            args: Prisma.AdminEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminEventPayload>
          }
          deleteMany: {
            args: Prisma.AdminEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminEventPayload>[]
          }
          upsert: {
            args: Prisma.AdminEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminEventPayload>
          }
          aggregate: {
            args: Prisma.AdminEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminEvent>
          }
          groupBy: {
            args: Prisma.AdminEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminEventCountArgs<ExtArgs>
            result: $Utils.Optional<AdminEventCountAggregateOutputType> | number
          }
        }
      }
      DashboardSettings: {
        payload: Prisma.$DashboardSettingsPayload<ExtArgs>
        fields: Prisma.DashboardSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardSettingsPayload>
          }
          findFirst: {
            args: Prisma.DashboardSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardSettingsPayload>
          }
          findMany: {
            args: Prisma.DashboardSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardSettingsPayload>[]
          }
          create: {
            args: Prisma.DashboardSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardSettingsPayload>
          }
          createMany: {
            args: Prisma.DashboardSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardSettingsPayload>[]
          }
          delete: {
            args: Prisma.DashboardSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardSettingsPayload>
          }
          update: {
            args: Prisma.DashboardSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardSettingsPayload>
          }
          deleteMany: {
            args: Prisma.DashboardSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DashboardSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardSettingsPayload>[]
          }
          upsert: {
            args: Prisma.DashboardSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardSettingsPayload>
          }
          aggregate: {
            args: Prisma.DashboardSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboardSettings>
          }
          groupBy: {
            args: Prisma.DashboardSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardSettingsCountAggregateOutputType> | number
          }
        }
      }
      CommunityBookmark: {
        payload: Prisma.$CommunityBookmarkPayload<ExtArgs>
        fields: Prisma.CommunityBookmarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityBookmarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBookmarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityBookmarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBookmarkPayload>
          }
          findFirst: {
            args: Prisma.CommunityBookmarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBookmarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityBookmarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBookmarkPayload>
          }
          findMany: {
            args: Prisma.CommunityBookmarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBookmarkPayload>[]
          }
          create: {
            args: Prisma.CommunityBookmarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBookmarkPayload>
          }
          createMany: {
            args: Prisma.CommunityBookmarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityBookmarkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBookmarkPayload>[]
          }
          delete: {
            args: Prisma.CommunityBookmarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBookmarkPayload>
          }
          update: {
            args: Prisma.CommunityBookmarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBookmarkPayload>
          }
          deleteMany: {
            args: Prisma.CommunityBookmarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityBookmarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommunityBookmarkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBookmarkPayload>[]
          }
          upsert: {
            args: Prisma.CommunityBookmarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityBookmarkPayload>
          }
          aggregate: {
            args: Prisma.CommunityBookmarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityBookmark>
          }
          groupBy: {
            args: Prisma.CommunityBookmarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityBookmarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityBookmarkCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityBookmarkCountAggregateOutputType> | number
          }
        }
      }
      DashboardAnnouncement: {
        payload: Prisma.$DashboardAnnouncementPayload<ExtArgs>
        fields: Prisma.DashboardAnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardAnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardAnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnnouncementPayload>
          }
          findFirst: {
            args: Prisma.DashboardAnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardAnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnnouncementPayload>
          }
          findMany: {
            args: Prisma.DashboardAnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnnouncementPayload>[]
          }
          create: {
            args: Prisma.DashboardAnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnnouncementPayload>
          }
          createMany: {
            args: Prisma.DashboardAnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardAnnouncementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnnouncementPayload>[]
          }
          delete: {
            args: Prisma.DashboardAnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnnouncementPayload>
          }
          update: {
            args: Prisma.DashboardAnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.DashboardAnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardAnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DashboardAnnouncementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnnouncementPayload>[]
          }
          upsert: {
            args: Prisma.DashboardAnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardAnnouncementPayload>
          }
          aggregate: {
            args: Prisma.DashboardAnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboardAnnouncement>
          }
          groupBy: {
            args: Prisma.DashboardAnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardAnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardAnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardAnnouncementCountAggregateOutputType> | number
          }
        }
      }
      UserInvitation: {
        payload: Prisma.$UserInvitationPayload<ExtArgs>
        fields: Prisma.UserInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          findFirst: {
            args: Prisma.UserInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          findMany: {
            args: Prisma.UserInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>[]
          }
          create: {
            args: Prisma.UserInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          createMany: {
            args: Prisma.UserInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>[]
          }
          delete: {
            args: Prisma.UserInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          update: {
            args: Prisma.UserInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          deleteMany: {
            args: Prisma.UserInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>[]
          }
          upsert: {
            args: Prisma.UserInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          aggregate: {
            args: Prisma.UserInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInvitation>
          }
          groupBy: {
            args: Prisma.UserInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<UserInvitationCountAggregateOutputType> | number
          }
        }
      }
      CommunityEvent: {
        payload: Prisma.$CommunityEventPayload<ExtArgs>
        fields: Prisma.CommunityEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>
          }
          findFirst: {
            args: Prisma.CommunityEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>
          }
          findMany: {
            args: Prisma.CommunityEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>[]
          }
          create: {
            args: Prisma.CommunityEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>
          }
          createMany: {
            args: Prisma.CommunityEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>[]
          }
          delete: {
            args: Prisma.CommunityEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>
          }
          update: {
            args: Prisma.CommunityEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>
          }
          deleteMany: {
            args: Prisma.CommunityEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommunityEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>[]
          }
          upsert: {
            args: Prisma.CommunityEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityEventPayload>
          }
          aggregate: {
            args: Prisma.CommunityEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityEvent>
          }
          groupBy: {
            args: Prisma.CommunityEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityEventCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityEventCountAggregateOutputType> | number
          }
        }
      }
      VerificationCode: {
        payload: Prisma.$VerificationCodePayload<ExtArgs>
        fields: Prisma.VerificationCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          findFirst: {
            args: Prisma.VerificationCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          findMany: {
            args: Prisma.VerificationCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          create: {
            args: Prisma.VerificationCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          createMany: {
            args: Prisma.VerificationCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          delete: {
            args: Prisma.VerificationCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          update: {
            args: Prisma.VerificationCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          deleteMany: {
            args: Prisma.VerificationCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          upsert: {
            args: Prisma.VerificationCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          aggregate: {
            args: Prisma.VerificationCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationCode>
          }
          groupBy: {
            args: Prisma.VerificationCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCodeCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCodeCountAggregateOutputType> | number
          }
        }
      }
      MatrixRoomMember: {
        payload: Prisma.$MatrixRoomMemberPayload<ExtArgs>
        fields: Prisma.MatrixRoomMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatrixRoomMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatrixRoomMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMemberPayload>
          }
          findFirst: {
            args: Prisma.MatrixRoomMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatrixRoomMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMemberPayload>
          }
          findMany: {
            args: Prisma.MatrixRoomMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMemberPayload>[]
          }
          create: {
            args: Prisma.MatrixRoomMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMemberPayload>
          }
          createMany: {
            args: Prisma.MatrixRoomMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatrixRoomMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMemberPayload>[]
          }
          delete: {
            args: Prisma.MatrixRoomMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMemberPayload>
          }
          update: {
            args: Prisma.MatrixRoomMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMemberPayload>
          }
          deleteMany: {
            args: Prisma.MatrixRoomMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatrixRoomMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatrixRoomMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMemberPayload>[]
          }
          upsert: {
            args: Prisma.MatrixRoomMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMemberPayload>
          }
          aggregate: {
            args: Prisma.MatrixRoomMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatrixRoomMember>
          }
          groupBy: {
            args: Prisma.MatrixRoomMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatrixRoomMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatrixRoomMemberCountArgs<ExtArgs>
            result: $Utils.Optional<MatrixRoomMemberCountAggregateOutputType> | number
          }
        }
      }
      UserNote: {
        payload: Prisma.$UserNotePayload<ExtArgs>
        fields: Prisma.UserNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotePayload>
          }
          findFirst: {
            args: Prisma.UserNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotePayload>
          }
          findMany: {
            args: Prisma.UserNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotePayload>[]
          }
          create: {
            args: Prisma.UserNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotePayload>
          }
          createMany: {
            args: Prisma.UserNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotePayload>[]
          }
          delete: {
            args: Prisma.UserNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotePayload>
          }
          update: {
            args: Prisma.UserNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotePayload>
          }
          deleteMany: {
            args: Prisma.UserNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotePayload>[]
          }
          upsert: {
            args: Prisma.UserNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNotePayload>
          }
          aggregate: {
            args: Prisma.UserNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserNote>
          }
          groupBy: {
            args: Prisma.UserNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserNoteCountArgs<ExtArgs>
            result: $Utils.Optional<UserNoteCountAggregateOutputType> | number
          }
        }
      }
      Invite: {
        payload: Prisma.$InvitePayload<ExtArgs>
        fields: Prisma.InviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          findFirst: {
            args: Prisma.InviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          findMany: {
            args: Prisma.InviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          create: {
            args: Prisma.InviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          createMany: {
            args: Prisma.InviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          delete: {
            args: Prisma.InviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          update: {
            args: Prisma.InviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          deleteMany: {
            args: Prisma.InviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InviteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          upsert: {
            args: Prisma.InviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          aggregate: {
            args: Prisma.InviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvite>
          }
          groupBy: {
            args: Prisma.InviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<InviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.InviteCountArgs<ExtArgs>
            result: $Utils.Optional<InviteCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      UserGroup: {
        payload: Prisma.$UserGroupPayload<ExtArgs>
        fields: Prisma.UserGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          findFirst: {
            args: Prisma.UserGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          findMany: {
            args: Prisma.UserGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>[]
          }
          create: {
            args: Prisma.UserGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          createMany: {
            args: Prisma.UserGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>[]
          }
          delete: {
            args: Prisma.UserGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          update: {
            args: Prisma.UserGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          deleteMany: {
            args: Prisma.UserGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>[]
          }
          upsert: {
            args: Prisma.UserGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGroupPayload>
          }
          aggregate: {
            args: Prisma.UserGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserGroup>
          }
          groupBy: {
            args: Prisma.UserGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserGroupCountArgs<ExtArgs>
            result: $Utils.Optional<UserGroupCountAggregateOutputType> | number
          }
        }
      }
      ModeratorPermission: {
        payload: Prisma.$ModeratorPermissionPayload<ExtArgs>
        fields: Prisma.ModeratorPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModeratorPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeratorPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModeratorPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeratorPermissionPayload>
          }
          findFirst: {
            args: Prisma.ModeratorPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeratorPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModeratorPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeratorPermissionPayload>
          }
          findMany: {
            args: Prisma.ModeratorPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeratorPermissionPayload>[]
          }
          create: {
            args: Prisma.ModeratorPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeratorPermissionPayload>
          }
          createMany: {
            args: Prisma.ModeratorPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModeratorPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeratorPermissionPayload>[]
          }
          delete: {
            args: Prisma.ModeratorPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeratorPermissionPayload>
          }
          update: {
            args: Prisma.ModeratorPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeratorPermissionPayload>
          }
          deleteMany: {
            args: Prisma.ModeratorPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModeratorPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModeratorPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeratorPermissionPayload>[]
          }
          upsert: {
            args: Prisma.ModeratorPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModeratorPermissionPayload>
          }
          aggregate: {
            args: Prisma.ModeratorPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModeratorPermission>
          }
          groupBy: {
            args: Prisma.ModeratorPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModeratorPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModeratorPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<ModeratorPermissionCountAggregateOutputType> | number
          }
        }
      }
      MatrixUser: {
        payload: Prisma.$MatrixUserPayload<ExtArgs>
        fields: Prisma.MatrixUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatrixUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatrixUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserPayload>
          }
          findFirst: {
            args: Prisma.MatrixUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatrixUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserPayload>
          }
          findMany: {
            args: Prisma.MatrixUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserPayload>[]
          }
          create: {
            args: Prisma.MatrixUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserPayload>
          }
          createMany: {
            args: Prisma.MatrixUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatrixUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserPayload>[]
          }
          delete: {
            args: Prisma.MatrixUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserPayload>
          }
          update: {
            args: Prisma.MatrixUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserPayload>
          }
          deleteMany: {
            args: Prisma.MatrixUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatrixUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatrixUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserPayload>[]
          }
          upsert: {
            args: Prisma.MatrixUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserPayload>
          }
          aggregate: {
            args: Prisma.MatrixUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatrixUser>
          }
          groupBy: {
            args: Prisma.MatrixUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatrixUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatrixUserCountArgs<ExtArgs>
            result: $Utils.Optional<MatrixUserCountAggregateOutputType> | number
          }
        }
      }
      MatrixRoom: {
        payload: Prisma.$MatrixRoomPayload<ExtArgs>
        fields: Prisma.MatrixRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatrixRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatrixRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomPayload>
          }
          findFirst: {
            args: Prisma.MatrixRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatrixRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomPayload>
          }
          findMany: {
            args: Prisma.MatrixRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomPayload>[]
          }
          create: {
            args: Prisma.MatrixRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomPayload>
          }
          createMany: {
            args: Prisma.MatrixRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatrixRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomPayload>[]
          }
          delete: {
            args: Prisma.MatrixRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomPayload>
          }
          update: {
            args: Prisma.MatrixRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomPayload>
          }
          deleteMany: {
            args: Prisma.MatrixRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatrixRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatrixRoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomPayload>[]
          }
          upsert: {
            args: Prisma.MatrixRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomPayload>
          }
          aggregate: {
            args: Prisma.MatrixRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatrixRoom>
          }
          groupBy: {
            args: Prisma.MatrixRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatrixRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatrixRoomCountArgs<ExtArgs>
            result: $Utils.Optional<MatrixRoomCountAggregateOutputType> | number
          }
        }
      }
      MatrixRoomMembership: {
        payload: Prisma.$MatrixRoomMembershipPayload<ExtArgs>
        fields: Prisma.MatrixRoomMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatrixRoomMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatrixRoomMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMembershipPayload>
          }
          findFirst: {
            args: Prisma.MatrixRoomMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatrixRoomMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMembershipPayload>
          }
          findMany: {
            args: Prisma.MatrixRoomMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMembershipPayload>[]
          }
          create: {
            args: Prisma.MatrixRoomMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMembershipPayload>
          }
          createMany: {
            args: Prisma.MatrixRoomMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatrixRoomMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMembershipPayload>[]
          }
          delete: {
            args: Prisma.MatrixRoomMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMembershipPayload>
          }
          update: {
            args: Prisma.MatrixRoomMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMembershipPayload>
          }
          deleteMany: {
            args: Prisma.MatrixRoomMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatrixRoomMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatrixRoomMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMembershipPayload>[]
          }
          upsert: {
            args: Prisma.MatrixRoomMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixRoomMembershipPayload>
          }
          aggregate: {
            args: Prisma.MatrixRoomMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatrixRoomMembership>
          }
          groupBy: {
            args: Prisma.MatrixRoomMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatrixRoomMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatrixRoomMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<MatrixRoomMembershipCountAggregateOutputType> | number
          }
        }
      }
      MatrixSyncStatus: {
        payload: Prisma.$MatrixSyncStatusPayload<ExtArgs>
        fields: Prisma.MatrixSyncStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatrixSyncStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixSyncStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatrixSyncStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixSyncStatusPayload>
          }
          findFirst: {
            args: Prisma.MatrixSyncStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixSyncStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatrixSyncStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixSyncStatusPayload>
          }
          findMany: {
            args: Prisma.MatrixSyncStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixSyncStatusPayload>[]
          }
          create: {
            args: Prisma.MatrixSyncStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixSyncStatusPayload>
          }
          createMany: {
            args: Prisma.MatrixSyncStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatrixSyncStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixSyncStatusPayload>[]
          }
          delete: {
            args: Prisma.MatrixSyncStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixSyncStatusPayload>
          }
          update: {
            args: Prisma.MatrixSyncStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixSyncStatusPayload>
          }
          deleteMany: {
            args: Prisma.MatrixSyncStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatrixSyncStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatrixSyncStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixSyncStatusPayload>[]
          }
          upsert: {
            args: Prisma.MatrixSyncStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixSyncStatusPayload>
          }
          aggregate: {
            args: Prisma.MatrixSyncStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatrixSyncStatus>
          }
          groupBy: {
            args: Prisma.MatrixSyncStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatrixSyncStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatrixSyncStatusCountArgs<ExtArgs>
            result: $Utils.Optional<MatrixSyncStatusCountAggregateOutputType> | number
          }
        }
      }
      MatrixUserCache: {
        payload: Prisma.$MatrixUserCachePayload<ExtArgs>
        fields: Prisma.MatrixUserCacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatrixUserCacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserCachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatrixUserCacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserCachePayload>
          }
          findFirst: {
            args: Prisma.MatrixUserCacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserCachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatrixUserCacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserCachePayload>
          }
          findMany: {
            args: Prisma.MatrixUserCacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserCachePayload>[]
          }
          create: {
            args: Prisma.MatrixUserCacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserCachePayload>
          }
          createMany: {
            args: Prisma.MatrixUserCacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatrixUserCacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserCachePayload>[]
          }
          delete: {
            args: Prisma.MatrixUserCacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserCachePayload>
          }
          update: {
            args: Prisma.MatrixUserCacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserCachePayload>
          }
          deleteMany: {
            args: Prisma.MatrixUserCacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatrixUserCacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatrixUserCacheUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserCachePayload>[]
          }
          upsert: {
            args: Prisma.MatrixUserCacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatrixUserCachePayload>
          }
          aggregate: {
            args: Prisma.MatrixUserCacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatrixUserCache>
          }
          groupBy: {
            args: Prisma.MatrixUserCacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatrixUserCacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatrixUserCacheCountArgs<ExtArgs>
            result: $Utils.Optional<MatrixUserCacheCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    adminEvent?: AdminEventOmit
    dashboardSettings?: DashboardSettingsOmit
    communityBookmark?: CommunityBookmarkOmit
    dashboardAnnouncement?: DashboardAnnouncementOmit
    userInvitation?: UserInvitationOmit
    communityEvent?: CommunityEventOmit
    verificationCode?: VerificationCodeOmit
    matrixRoomMember?: MatrixRoomMemberOmit
    userNote?: UserNoteOmit
    invite?: InviteOmit
    group?: GroupOmit
    userGroup?: UserGroupOmit
    moderatorPermission?: ModeratorPermissionOmit
    matrixUser?: MatrixUserOmit
    matrixRoom?: MatrixRoomOmit
    matrixRoomMembership?: MatrixRoomMembershipOmit
    matrixSyncStatus?: MatrixSyncStatusOmit
    matrixUserCache?: MatrixUserCacheOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notes: number
    groups: number
    moderatorPermissions: number
    sentInvitations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | UserCountOutputTypeCountNotesArgs
    groups?: boolean | UserCountOutputTypeCountGroupsArgs
    moderatorPermissions?: boolean | UserCountOutputTypeCountModeratorPermissionsArgs
    sentInvitations?: boolean | UserCountOutputTypeCountSentInvitationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModeratorPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModeratorPermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInvitationWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    users: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | GroupCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupWhereInput
  }


  /**
   * Count Type MatrixUserCountOutputType
   */

  export type MatrixUserCountOutputType = {
    memberships: number
  }

  export type MatrixUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | MatrixUserCountOutputTypeCountMembershipsArgs
  }

  // Custom InputTypes
  /**
   * MatrixUserCountOutputType without action
   */
  export type MatrixUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCountOutputType
     */
    select?: MatrixUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatrixUserCountOutputType without action
   */
  export type MatrixUserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatrixRoomMembershipWhereInput
  }


  /**
   * Count Type MatrixRoomCountOutputType
   */

  export type MatrixRoomCountOutputType = {
    memberships: number
  }

  export type MatrixRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | MatrixRoomCountOutputTypeCountMembershipsArgs
  }

  // Custom InputTypes
  /**
   * MatrixRoomCountOutputType without action
   */
  export type MatrixRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomCountOutputType
     */
    select?: MatrixRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatrixRoomCountOutputType without action
   */
  export type MatrixRoomCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatrixRoomMembershipWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    isActive: boolean | null
    isAdmin: boolean | null
    isModerator: boolean | null
    dateJoined: Date | null
    lastLogin: Date | null
    authentikId: string | null
    signalIdentity: string | null
    matrixUsername: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    isActive: boolean | null
    isAdmin: boolean | null
    isModerator: boolean | null
    dateJoined: Date | null
    lastLogin: Date | null
    authentikId: string | null
    signalIdentity: string | null
    matrixUsername: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    firstName: number
    lastName: number
    password: number
    isActive: number
    isAdmin: number
    isModerator: number
    dateJoined: number
    lastLogin: number
    attributes: number
    authentikId: number
    signalIdentity: number
    matrixUsername: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    isActive?: true
    isAdmin?: true
    isModerator?: true
    dateJoined?: true
    lastLogin?: true
    authentikId?: true
    signalIdentity?: true
    matrixUsername?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    isActive?: true
    isAdmin?: true
    isModerator?: true
    dateJoined?: true
    lastLogin?: true
    authentikId?: true
    signalIdentity?: true
    matrixUsername?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    isActive?: true
    isAdmin?: true
    isModerator?: true
    dateJoined?: true
    lastLogin?: true
    attributes?: true
    authentikId?: true
    signalIdentity?: true
    matrixUsername?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    isActive: boolean
    isAdmin: boolean
    isModerator: boolean
    dateJoined: Date
    lastLogin: Date | null
    attributes: JsonValue | null
    authentikId: string | null
    signalIdentity: string | null
    matrixUsername: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: boolean
    lastLogin?: boolean
    attributes?: boolean
    authentikId?: boolean
    signalIdentity?: boolean
    matrixUsername?: boolean
    notes?: boolean | User$notesArgs<ExtArgs>
    groups?: boolean | User$groupsArgs<ExtArgs>
    moderatorPermissions?: boolean | User$moderatorPermissionsArgs<ExtArgs>
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: boolean
    lastLogin?: boolean
    attributes?: boolean
    authentikId?: boolean
    signalIdentity?: boolean
    matrixUsername?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: boolean
    lastLogin?: boolean
    attributes?: boolean
    authentikId?: boolean
    signalIdentity?: boolean
    matrixUsername?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: boolean
    lastLogin?: boolean
    attributes?: boolean
    authentikId?: boolean
    signalIdentity?: boolean
    matrixUsername?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "firstName" | "lastName" | "password" | "isActive" | "isAdmin" | "isModerator" | "dateJoined" | "lastLogin" | "attributes" | "authentikId" | "signalIdentity" | "matrixUsername", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | User$notesArgs<ExtArgs>
    groups?: boolean | User$groupsArgs<ExtArgs>
    moderatorPermissions?: boolean | User$moderatorPermissionsArgs<ExtArgs>
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      notes: Prisma.$UserNotePayload<ExtArgs>[]
      groups: Prisma.$UserGroupPayload<ExtArgs>[]
      moderatorPermissions: Prisma.$ModeratorPermissionPayload<ExtArgs>[]
      sentInvitations: Prisma.$UserInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string | null
      email: string | null
      firstName: string | null
      lastName: string | null
      password: string | null
      isActive: boolean
      isAdmin: boolean
      isModerator: boolean
      dateJoined: Date
      lastLogin: Date | null
      attributes: Prisma.JsonValue | null
      authentikId: string | null
      signalIdentity: string | null
      matrixUsername: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notes<T extends User$notesArgs<ExtArgs> = {}>(args?: Subset<T, User$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groups<T extends User$groupsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moderatorPermissions<T extends User$moderatorPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$moderatorPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModeratorPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentInvitations<T extends User$sentInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly isModerator: FieldRef<"User", 'Boolean'>
    readonly dateJoined: FieldRef<"User", 'DateTime'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly attributes: FieldRef<"User", 'Json'>
    readonly authentikId: FieldRef<"User", 'String'>
    readonly signalIdentity: FieldRef<"User", 'String'>
    readonly matrixUsername: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.notes
   */
  export type User$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteInclude<ExtArgs> | null
    where?: UserNoteWhereInput
    orderBy?: UserNoteOrderByWithRelationInput | UserNoteOrderByWithRelationInput[]
    cursor?: UserNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserNoteScalarFieldEnum | UserNoteScalarFieldEnum[]
  }

  /**
   * User.groups
   */
  export type User$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    where?: UserGroupWhereInput
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    cursor?: UserGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * User.moderatorPermissions
   */
  export type User$moderatorPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionInclude<ExtArgs> | null
    where?: ModeratorPermissionWhereInput
    orderBy?: ModeratorPermissionOrderByWithRelationInput | ModeratorPermissionOrderByWithRelationInput[]
    cursor?: ModeratorPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModeratorPermissionScalarFieldEnum | ModeratorPermissionScalarFieldEnum[]
  }

  /**
   * User.sentInvitations
   */
  export type User$sentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    where?: UserInvitationWhereInput
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    cursor?: UserInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AdminEvent
   */

  export type AggregateAdminEvent = {
    _count: AdminEventCountAggregateOutputType | null
    _avg: AdminEventAvgAggregateOutputType | null
    _sum: AdminEventSumAggregateOutputType | null
    _min: AdminEventMinAggregateOutputType | null
    _max: AdminEventMaxAggregateOutputType | null
  }

  export type AdminEventAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminEventSumAggregateOutputType = {
    id: number | null
  }

  export type AdminEventMinAggregateOutputType = {
    id: number | null
    eventType: string | null
    username: string | null
    details: string | null
    timestamp: Date | null
  }

  export type AdminEventMaxAggregateOutputType = {
    id: number | null
    eventType: string | null
    username: string | null
    details: string | null
    timestamp: Date | null
  }

  export type AdminEventCountAggregateOutputType = {
    id: number
    eventType: number
    username: number
    details: number
    timestamp: number
    _all: number
  }


  export type AdminEventAvgAggregateInputType = {
    id?: true
  }

  export type AdminEventSumAggregateInputType = {
    id?: true
  }

  export type AdminEventMinAggregateInputType = {
    id?: true
    eventType?: true
    username?: true
    details?: true
    timestamp?: true
  }

  export type AdminEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    username?: true
    details?: true
    timestamp?: true
  }

  export type AdminEventCountAggregateInputType = {
    id?: true
    eventType?: true
    username?: true
    details?: true
    timestamp?: true
    _all?: true
  }

  export type AdminEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminEvent to aggregate.
     */
    where?: AdminEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminEvents to fetch.
     */
    orderBy?: AdminEventOrderByWithRelationInput | AdminEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminEvents
    **/
    _count?: true | AdminEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminEventMaxAggregateInputType
  }

  export type GetAdminEventAggregateType<T extends AdminEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminEvent[P]>
      : GetScalarType<T[P], AggregateAdminEvent[P]>
  }




  export type AdminEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminEventWhereInput
    orderBy?: AdminEventOrderByWithAggregationInput | AdminEventOrderByWithAggregationInput[]
    by: AdminEventScalarFieldEnum[] | AdminEventScalarFieldEnum
    having?: AdminEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminEventCountAggregateInputType | true
    _avg?: AdminEventAvgAggregateInputType
    _sum?: AdminEventSumAggregateInputType
    _min?: AdminEventMinAggregateInputType
    _max?: AdminEventMaxAggregateInputType
  }

  export type AdminEventGroupByOutputType = {
    id: number
    eventType: string
    username: string | null
    details: string | null
    timestamp: Date
    _count: AdminEventCountAggregateOutputType | null
    _avg: AdminEventAvgAggregateOutputType | null
    _sum: AdminEventSumAggregateOutputType | null
    _min: AdminEventMinAggregateOutputType | null
    _max: AdminEventMaxAggregateOutputType | null
  }

  type GetAdminEventGroupByPayload<T extends AdminEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminEventGroupByOutputType[P]>
            : GetScalarType<T[P], AdminEventGroupByOutputType[P]>
        }
      >
    >


  export type AdminEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    username?: boolean
    details?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["adminEvent"]>

  export type AdminEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    username?: boolean
    details?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["adminEvent"]>

  export type AdminEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    username?: boolean
    details?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["adminEvent"]>

  export type AdminEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    username?: boolean
    details?: boolean
    timestamp?: boolean
  }

  export type AdminEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventType" | "username" | "details" | "timestamp", ExtArgs["result"]["adminEvent"]>

  export type $AdminEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      eventType: string
      username: string | null
      details: string | null
      timestamp: Date
    }, ExtArgs["result"]["adminEvent"]>
    composites: {}
  }

  type AdminEventGetPayload<S extends boolean | null | undefined | AdminEventDefaultArgs> = $Result.GetResult<Prisma.$AdminEventPayload, S>

  type AdminEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminEventCountAggregateInputType | true
    }

  export interface AdminEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminEvent'], meta: { name: 'AdminEvent' } }
    /**
     * Find zero or one AdminEvent that matches the filter.
     * @param {AdminEventFindUniqueArgs} args - Arguments to find a AdminEvent
     * @example
     * // Get one AdminEvent
     * const adminEvent = await prisma.adminEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminEventFindUniqueArgs>(args: SelectSubset<T, AdminEventFindUniqueArgs<ExtArgs>>): Prisma__AdminEventClient<$Result.GetResult<Prisma.$AdminEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminEventFindUniqueOrThrowArgs} args - Arguments to find a AdminEvent
     * @example
     * // Get one AdminEvent
     * const adminEvent = await prisma.adminEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminEventClient<$Result.GetResult<Prisma.$AdminEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminEventFindFirstArgs} args - Arguments to find a AdminEvent
     * @example
     * // Get one AdminEvent
     * const adminEvent = await prisma.adminEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminEventFindFirstArgs>(args?: SelectSubset<T, AdminEventFindFirstArgs<ExtArgs>>): Prisma__AdminEventClient<$Result.GetResult<Prisma.$AdminEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminEventFindFirstOrThrowArgs} args - Arguments to find a AdminEvent
     * @example
     * // Get one AdminEvent
     * const adminEvent = await prisma.adminEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminEventClient<$Result.GetResult<Prisma.$AdminEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminEvents
     * const adminEvents = await prisma.adminEvent.findMany()
     * 
     * // Get first 10 AdminEvents
     * const adminEvents = await prisma.adminEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminEventWithIdOnly = await prisma.adminEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminEventFindManyArgs>(args?: SelectSubset<T, AdminEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminEvent.
     * @param {AdminEventCreateArgs} args - Arguments to create a AdminEvent.
     * @example
     * // Create one AdminEvent
     * const AdminEvent = await prisma.adminEvent.create({
     *   data: {
     *     // ... data to create a AdminEvent
     *   }
     * })
     * 
     */
    create<T extends AdminEventCreateArgs>(args: SelectSubset<T, AdminEventCreateArgs<ExtArgs>>): Prisma__AdminEventClient<$Result.GetResult<Prisma.$AdminEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminEvents.
     * @param {AdminEventCreateManyArgs} args - Arguments to create many AdminEvents.
     * @example
     * // Create many AdminEvents
     * const adminEvent = await prisma.adminEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminEventCreateManyArgs>(args?: SelectSubset<T, AdminEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminEvents and returns the data saved in the database.
     * @param {AdminEventCreateManyAndReturnArgs} args - Arguments to create many AdminEvents.
     * @example
     * // Create many AdminEvents
     * const adminEvent = await prisma.adminEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminEvents and only return the `id`
     * const adminEventWithIdOnly = await prisma.adminEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminEvent.
     * @param {AdminEventDeleteArgs} args - Arguments to delete one AdminEvent.
     * @example
     * // Delete one AdminEvent
     * const AdminEvent = await prisma.adminEvent.delete({
     *   where: {
     *     // ... filter to delete one AdminEvent
     *   }
     * })
     * 
     */
    delete<T extends AdminEventDeleteArgs>(args: SelectSubset<T, AdminEventDeleteArgs<ExtArgs>>): Prisma__AdminEventClient<$Result.GetResult<Prisma.$AdminEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminEvent.
     * @param {AdminEventUpdateArgs} args - Arguments to update one AdminEvent.
     * @example
     * // Update one AdminEvent
     * const adminEvent = await prisma.adminEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminEventUpdateArgs>(args: SelectSubset<T, AdminEventUpdateArgs<ExtArgs>>): Prisma__AdminEventClient<$Result.GetResult<Prisma.$AdminEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminEvents.
     * @param {AdminEventDeleteManyArgs} args - Arguments to filter AdminEvents to delete.
     * @example
     * // Delete a few AdminEvents
     * const { count } = await prisma.adminEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminEventDeleteManyArgs>(args?: SelectSubset<T, AdminEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminEvents
     * const adminEvent = await prisma.adminEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminEventUpdateManyArgs>(args: SelectSubset<T, AdminEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminEvents and returns the data updated in the database.
     * @param {AdminEventUpdateManyAndReturnArgs} args - Arguments to update many AdminEvents.
     * @example
     * // Update many AdminEvents
     * const adminEvent = await prisma.adminEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminEvents and only return the `id`
     * const adminEventWithIdOnly = await prisma.adminEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminEvent.
     * @param {AdminEventUpsertArgs} args - Arguments to update or create a AdminEvent.
     * @example
     * // Update or create a AdminEvent
     * const adminEvent = await prisma.adminEvent.upsert({
     *   create: {
     *     // ... data to create a AdminEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminEvent we want to update
     *   }
     * })
     */
    upsert<T extends AdminEventUpsertArgs>(args: SelectSubset<T, AdminEventUpsertArgs<ExtArgs>>): Prisma__AdminEventClient<$Result.GetResult<Prisma.$AdminEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminEventCountArgs} args - Arguments to filter AdminEvents to count.
     * @example
     * // Count the number of AdminEvents
     * const count = await prisma.adminEvent.count({
     *   where: {
     *     // ... the filter for the AdminEvents we want to count
     *   }
     * })
    **/
    count<T extends AdminEventCountArgs>(
      args?: Subset<T, AdminEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminEventAggregateArgs>(args: Subset<T, AdminEventAggregateArgs>): Prisma.PrismaPromise<GetAdminEventAggregateType<T>>

    /**
     * Group by AdminEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminEventGroupByArgs['orderBy'] }
        : { orderBy?: AdminEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminEvent model
   */
  readonly fields: AdminEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminEvent model
   */
  interface AdminEventFieldRefs {
    readonly id: FieldRef<"AdminEvent", 'Int'>
    readonly eventType: FieldRef<"AdminEvent", 'String'>
    readonly username: FieldRef<"AdminEvent", 'String'>
    readonly details: FieldRef<"AdminEvent", 'String'>
    readonly timestamp: FieldRef<"AdminEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminEvent findUnique
   */
  export type AdminEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminEvent
     */
    select?: AdminEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminEvent
     */
    omit?: AdminEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminEvent to fetch.
     */
    where: AdminEventWhereUniqueInput
  }

  /**
   * AdminEvent findUniqueOrThrow
   */
  export type AdminEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminEvent
     */
    select?: AdminEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminEvent
     */
    omit?: AdminEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminEvent to fetch.
     */
    where: AdminEventWhereUniqueInput
  }

  /**
   * AdminEvent findFirst
   */
  export type AdminEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminEvent
     */
    select?: AdminEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminEvent
     */
    omit?: AdminEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminEvent to fetch.
     */
    where?: AdminEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminEvents to fetch.
     */
    orderBy?: AdminEventOrderByWithRelationInput | AdminEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminEvents.
     */
    cursor?: AdminEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminEvents.
     */
    distinct?: AdminEventScalarFieldEnum | AdminEventScalarFieldEnum[]
  }

  /**
   * AdminEvent findFirstOrThrow
   */
  export type AdminEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminEvent
     */
    select?: AdminEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminEvent
     */
    omit?: AdminEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminEvent to fetch.
     */
    where?: AdminEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminEvents to fetch.
     */
    orderBy?: AdminEventOrderByWithRelationInput | AdminEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminEvents.
     */
    cursor?: AdminEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminEvents.
     */
    distinct?: AdminEventScalarFieldEnum | AdminEventScalarFieldEnum[]
  }

  /**
   * AdminEvent findMany
   */
  export type AdminEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminEvent
     */
    select?: AdminEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminEvent
     */
    omit?: AdminEventOmit<ExtArgs> | null
    /**
     * Filter, which AdminEvents to fetch.
     */
    where?: AdminEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminEvents to fetch.
     */
    orderBy?: AdminEventOrderByWithRelationInput | AdminEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminEvents.
     */
    cursor?: AdminEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminEvents.
     */
    skip?: number
    distinct?: AdminEventScalarFieldEnum | AdminEventScalarFieldEnum[]
  }

  /**
   * AdminEvent create
   */
  export type AdminEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminEvent
     */
    select?: AdminEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminEvent
     */
    omit?: AdminEventOmit<ExtArgs> | null
    /**
     * The data needed to create a AdminEvent.
     */
    data: XOR<AdminEventCreateInput, AdminEventUncheckedCreateInput>
  }

  /**
   * AdminEvent createMany
   */
  export type AdminEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminEvents.
     */
    data: AdminEventCreateManyInput | AdminEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminEvent createManyAndReturn
   */
  export type AdminEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminEvent
     */
    select?: AdminEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminEvent
     */
    omit?: AdminEventOmit<ExtArgs> | null
    /**
     * The data used to create many AdminEvents.
     */
    data: AdminEventCreateManyInput | AdminEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminEvent update
   */
  export type AdminEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminEvent
     */
    select?: AdminEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminEvent
     */
    omit?: AdminEventOmit<ExtArgs> | null
    /**
     * The data needed to update a AdminEvent.
     */
    data: XOR<AdminEventUpdateInput, AdminEventUncheckedUpdateInput>
    /**
     * Choose, which AdminEvent to update.
     */
    where: AdminEventWhereUniqueInput
  }

  /**
   * AdminEvent updateMany
   */
  export type AdminEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminEvents.
     */
    data: XOR<AdminEventUpdateManyMutationInput, AdminEventUncheckedUpdateManyInput>
    /**
     * Filter which AdminEvents to update
     */
    where?: AdminEventWhereInput
    /**
     * Limit how many AdminEvents to update.
     */
    limit?: number
  }

  /**
   * AdminEvent updateManyAndReturn
   */
  export type AdminEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminEvent
     */
    select?: AdminEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminEvent
     */
    omit?: AdminEventOmit<ExtArgs> | null
    /**
     * The data used to update AdminEvents.
     */
    data: XOR<AdminEventUpdateManyMutationInput, AdminEventUncheckedUpdateManyInput>
    /**
     * Filter which AdminEvents to update
     */
    where?: AdminEventWhereInput
    /**
     * Limit how many AdminEvents to update.
     */
    limit?: number
  }

  /**
   * AdminEvent upsert
   */
  export type AdminEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminEvent
     */
    select?: AdminEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminEvent
     */
    omit?: AdminEventOmit<ExtArgs> | null
    /**
     * The filter to search for the AdminEvent to update in case it exists.
     */
    where: AdminEventWhereUniqueInput
    /**
     * In case the AdminEvent found by the `where` argument doesn't exist, create a new AdminEvent with this data.
     */
    create: XOR<AdminEventCreateInput, AdminEventUncheckedCreateInput>
    /**
     * In case the AdminEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminEventUpdateInput, AdminEventUncheckedUpdateInput>
  }

  /**
   * AdminEvent delete
   */
  export type AdminEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminEvent
     */
    select?: AdminEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminEvent
     */
    omit?: AdminEventOmit<ExtArgs> | null
    /**
     * Filter which AdminEvent to delete.
     */
    where: AdminEventWhereUniqueInput
  }

  /**
   * AdminEvent deleteMany
   */
  export type AdminEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminEvents to delete
     */
    where?: AdminEventWhereInput
    /**
     * Limit how many AdminEvents to delete.
     */
    limit?: number
  }

  /**
   * AdminEvent without action
   */
  export type AdminEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminEvent
     */
    select?: AdminEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminEvent
     */
    omit?: AdminEventOmit<ExtArgs> | null
  }


  /**
   * Model DashboardSettings
   */

  export type AggregateDashboardSettings = {
    _count: DashboardSettingsCountAggregateOutputType | null
    _avg: DashboardSettingsAvgAggregateOutputType | null
    _sum: DashboardSettingsSumAggregateOutputType | null
    _min: DashboardSettingsMinAggregateOutputType | null
    _max: DashboardSettingsMaxAggregateOutputType | null
  }

  export type DashboardSettingsAvgAggregateOutputType = {
    id: number | null
  }

  export type DashboardSettingsSumAggregateOutputType = {
    id: number | null
  }

  export type DashboardSettingsMinAggregateOutputType = {
    id: number | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DashboardSettingsMaxAggregateOutputType = {
    id: number | null
    key: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DashboardSettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DashboardSettingsAvgAggregateInputType = {
    id?: true
  }

  export type DashboardSettingsSumAggregateInputType = {
    id?: true
  }

  export type DashboardSettingsMinAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DashboardSettingsMaxAggregateInputType = {
    id?: true
    key?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DashboardSettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DashboardSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardSettings to aggregate.
     */
    where?: DashboardSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardSettings to fetch.
     */
    orderBy?: DashboardSettingsOrderByWithRelationInput | DashboardSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardSettings
    **/
    _count?: true | DashboardSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardSettingsMaxAggregateInputType
  }

  export type GetDashboardSettingsAggregateType<T extends DashboardSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardSettings[P]>
      : GetScalarType<T[P], AggregateDashboardSettings[P]>
  }




  export type DashboardSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardSettingsWhereInput
    orderBy?: DashboardSettingsOrderByWithAggregationInput | DashboardSettingsOrderByWithAggregationInput[]
    by: DashboardSettingsScalarFieldEnum[] | DashboardSettingsScalarFieldEnum
    having?: DashboardSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardSettingsCountAggregateInputType | true
    _avg?: DashboardSettingsAvgAggregateInputType
    _sum?: DashboardSettingsSumAggregateInputType
    _min?: DashboardSettingsMinAggregateInputType
    _max?: DashboardSettingsMaxAggregateInputType
  }

  export type DashboardSettingsGroupByOutputType = {
    id: number
    key: string
    value: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: DashboardSettingsCountAggregateOutputType | null
    _avg: DashboardSettingsAvgAggregateOutputType | null
    _sum: DashboardSettingsSumAggregateOutputType | null
    _min: DashboardSettingsMinAggregateOutputType | null
    _max: DashboardSettingsMaxAggregateOutputType | null
  }

  type GetDashboardSettingsGroupByPayload<T extends DashboardSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardSettingsGroupByOutputType[P]>
        }
      >
    >


  export type DashboardSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dashboardSettings"]>

  export type DashboardSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dashboardSettings"]>

  export type DashboardSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dashboardSettings"]>

  export type DashboardSettingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DashboardSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["dashboardSettings"]>

  export type $DashboardSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DashboardSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dashboardSettings"]>
    composites: {}
  }

  type DashboardSettingsGetPayload<S extends boolean | null | undefined | DashboardSettingsDefaultArgs> = $Result.GetResult<Prisma.$DashboardSettingsPayload, S>

  type DashboardSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DashboardSettingsCountAggregateInputType | true
    }

  export interface DashboardSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DashboardSettings'], meta: { name: 'DashboardSettings' } }
    /**
     * Find zero or one DashboardSettings that matches the filter.
     * @param {DashboardSettingsFindUniqueArgs} args - Arguments to find a DashboardSettings
     * @example
     * // Get one DashboardSettings
     * const dashboardSettings = await prisma.dashboardSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardSettingsFindUniqueArgs>(args: SelectSubset<T, DashboardSettingsFindUniqueArgs<ExtArgs>>): Prisma__DashboardSettingsClient<$Result.GetResult<Prisma.$DashboardSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DashboardSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardSettingsFindUniqueOrThrowArgs} args - Arguments to find a DashboardSettings
     * @example
     * // Get one DashboardSettings
     * const dashboardSettings = await prisma.dashboardSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardSettingsClient<$Result.GetResult<Prisma.$DashboardSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardSettingsFindFirstArgs} args - Arguments to find a DashboardSettings
     * @example
     * // Get one DashboardSettings
     * const dashboardSettings = await prisma.dashboardSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardSettingsFindFirstArgs>(args?: SelectSubset<T, DashboardSettingsFindFirstArgs<ExtArgs>>): Prisma__DashboardSettingsClient<$Result.GetResult<Prisma.$DashboardSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardSettingsFindFirstOrThrowArgs} args - Arguments to find a DashboardSettings
     * @example
     * // Get one DashboardSettings
     * const dashboardSettings = await prisma.dashboardSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardSettingsClient<$Result.GetResult<Prisma.$DashboardSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DashboardSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardSettings
     * const dashboardSettings = await prisma.dashboardSettings.findMany()
     * 
     * // Get first 10 DashboardSettings
     * const dashboardSettings = await prisma.dashboardSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardSettingsWithIdOnly = await prisma.dashboardSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardSettingsFindManyArgs>(args?: SelectSubset<T, DashboardSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DashboardSettings.
     * @param {DashboardSettingsCreateArgs} args - Arguments to create a DashboardSettings.
     * @example
     * // Create one DashboardSettings
     * const DashboardSettings = await prisma.dashboardSettings.create({
     *   data: {
     *     // ... data to create a DashboardSettings
     *   }
     * })
     * 
     */
    create<T extends DashboardSettingsCreateArgs>(args: SelectSubset<T, DashboardSettingsCreateArgs<ExtArgs>>): Prisma__DashboardSettingsClient<$Result.GetResult<Prisma.$DashboardSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DashboardSettings.
     * @param {DashboardSettingsCreateManyArgs} args - Arguments to create many DashboardSettings.
     * @example
     * // Create many DashboardSettings
     * const dashboardSettings = await prisma.dashboardSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardSettingsCreateManyArgs>(args?: SelectSubset<T, DashboardSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DashboardSettings and returns the data saved in the database.
     * @param {DashboardSettingsCreateManyAndReturnArgs} args - Arguments to create many DashboardSettings.
     * @example
     * // Create many DashboardSettings
     * const dashboardSettings = await prisma.dashboardSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DashboardSettings and only return the `id`
     * const dashboardSettingsWithIdOnly = await prisma.dashboardSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DashboardSettings.
     * @param {DashboardSettingsDeleteArgs} args - Arguments to delete one DashboardSettings.
     * @example
     * // Delete one DashboardSettings
     * const DashboardSettings = await prisma.dashboardSettings.delete({
     *   where: {
     *     // ... filter to delete one DashboardSettings
     *   }
     * })
     * 
     */
    delete<T extends DashboardSettingsDeleteArgs>(args: SelectSubset<T, DashboardSettingsDeleteArgs<ExtArgs>>): Prisma__DashboardSettingsClient<$Result.GetResult<Prisma.$DashboardSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DashboardSettings.
     * @param {DashboardSettingsUpdateArgs} args - Arguments to update one DashboardSettings.
     * @example
     * // Update one DashboardSettings
     * const dashboardSettings = await prisma.dashboardSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardSettingsUpdateArgs>(args: SelectSubset<T, DashboardSettingsUpdateArgs<ExtArgs>>): Prisma__DashboardSettingsClient<$Result.GetResult<Prisma.$DashboardSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DashboardSettings.
     * @param {DashboardSettingsDeleteManyArgs} args - Arguments to filter DashboardSettings to delete.
     * @example
     * // Delete a few DashboardSettings
     * const { count } = await prisma.dashboardSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardSettingsDeleteManyArgs>(args?: SelectSubset<T, DashboardSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardSettings
     * const dashboardSettings = await prisma.dashboardSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardSettingsUpdateManyArgs>(args: SelectSubset<T, DashboardSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardSettings and returns the data updated in the database.
     * @param {DashboardSettingsUpdateManyAndReturnArgs} args - Arguments to update many DashboardSettings.
     * @example
     * // Update many DashboardSettings
     * const dashboardSettings = await prisma.dashboardSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DashboardSettings and only return the `id`
     * const dashboardSettingsWithIdOnly = await prisma.dashboardSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DashboardSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, DashboardSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DashboardSettings.
     * @param {DashboardSettingsUpsertArgs} args - Arguments to update or create a DashboardSettings.
     * @example
     * // Update or create a DashboardSettings
     * const dashboardSettings = await prisma.dashboardSettings.upsert({
     *   create: {
     *     // ... data to create a DashboardSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardSettings we want to update
     *   }
     * })
     */
    upsert<T extends DashboardSettingsUpsertArgs>(args: SelectSubset<T, DashboardSettingsUpsertArgs<ExtArgs>>): Prisma__DashboardSettingsClient<$Result.GetResult<Prisma.$DashboardSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DashboardSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardSettingsCountArgs} args - Arguments to filter DashboardSettings to count.
     * @example
     * // Count the number of DashboardSettings
     * const count = await prisma.dashboardSettings.count({
     *   where: {
     *     // ... the filter for the DashboardSettings we want to count
     *   }
     * })
    **/
    count<T extends DashboardSettingsCountArgs>(
      args?: Subset<T, DashboardSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardSettingsAggregateArgs>(args: Subset<T, DashboardSettingsAggregateArgs>): Prisma.PrismaPromise<GetDashboardSettingsAggregateType<T>>

    /**
     * Group by DashboardSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardSettingsGroupByArgs['orderBy'] }
        : { orderBy?: DashboardSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DashboardSettings model
   */
  readonly fields: DashboardSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DashboardSettings model
   */
  interface DashboardSettingsFieldRefs {
    readonly id: FieldRef<"DashboardSettings", 'Int'>
    readonly key: FieldRef<"DashboardSettings", 'String'>
    readonly value: FieldRef<"DashboardSettings", 'Json'>
    readonly createdAt: FieldRef<"DashboardSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"DashboardSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DashboardSettings findUnique
   */
  export type DashboardSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardSettings
     */
    select?: DashboardSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardSettings
     */
    omit?: DashboardSettingsOmit<ExtArgs> | null
    /**
     * Filter, which DashboardSettings to fetch.
     */
    where: DashboardSettingsWhereUniqueInput
  }

  /**
   * DashboardSettings findUniqueOrThrow
   */
  export type DashboardSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardSettings
     */
    select?: DashboardSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardSettings
     */
    omit?: DashboardSettingsOmit<ExtArgs> | null
    /**
     * Filter, which DashboardSettings to fetch.
     */
    where: DashboardSettingsWhereUniqueInput
  }

  /**
   * DashboardSettings findFirst
   */
  export type DashboardSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardSettings
     */
    select?: DashboardSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardSettings
     */
    omit?: DashboardSettingsOmit<ExtArgs> | null
    /**
     * Filter, which DashboardSettings to fetch.
     */
    where?: DashboardSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardSettings to fetch.
     */
    orderBy?: DashboardSettingsOrderByWithRelationInput | DashboardSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardSettings.
     */
    cursor?: DashboardSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardSettings.
     */
    distinct?: DashboardSettingsScalarFieldEnum | DashboardSettingsScalarFieldEnum[]
  }

  /**
   * DashboardSettings findFirstOrThrow
   */
  export type DashboardSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardSettings
     */
    select?: DashboardSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardSettings
     */
    omit?: DashboardSettingsOmit<ExtArgs> | null
    /**
     * Filter, which DashboardSettings to fetch.
     */
    where?: DashboardSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardSettings to fetch.
     */
    orderBy?: DashboardSettingsOrderByWithRelationInput | DashboardSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardSettings.
     */
    cursor?: DashboardSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardSettings.
     */
    distinct?: DashboardSettingsScalarFieldEnum | DashboardSettingsScalarFieldEnum[]
  }

  /**
   * DashboardSettings findMany
   */
  export type DashboardSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardSettings
     */
    select?: DashboardSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardSettings
     */
    omit?: DashboardSettingsOmit<ExtArgs> | null
    /**
     * Filter, which DashboardSettings to fetch.
     */
    where?: DashboardSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardSettings to fetch.
     */
    orderBy?: DashboardSettingsOrderByWithRelationInput | DashboardSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardSettings.
     */
    cursor?: DashboardSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardSettings.
     */
    skip?: number
    distinct?: DashboardSettingsScalarFieldEnum | DashboardSettingsScalarFieldEnum[]
  }

  /**
   * DashboardSettings create
   */
  export type DashboardSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardSettings
     */
    select?: DashboardSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardSettings
     */
    omit?: DashboardSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a DashboardSettings.
     */
    data: XOR<DashboardSettingsCreateInput, DashboardSettingsUncheckedCreateInput>
  }

  /**
   * DashboardSettings createMany
   */
  export type DashboardSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DashboardSettings.
     */
    data: DashboardSettingsCreateManyInput | DashboardSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardSettings createManyAndReturn
   */
  export type DashboardSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardSettings
     */
    select?: DashboardSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardSettings
     */
    omit?: DashboardSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many DashboardSettings.
     */
    data: DashboardSettingsCreateManyInput | DashboardSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardSettings update
   */
  export type DashboardSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardSettings
     */
    select?: DashboardSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardSettings
     */
    omit?: DashboardSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a DashboardSettings.
     */
    data: XOR<DashboardSettingsUpdateInput, DashboardSettingsUncheckedUpdateInput>
    /**
     * Choose, which DashboardSettings to update.
     */
    where: DashboardSettingsWhereUniqueInput
  }

  /**
   * DashboardSettings updateMany
   */
  export type DashboardSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DashboardSettings.
     */
    data: XOR<DashboardSettingsUpdateManyMutationInput, DashboardSettingsUncheckedUpdateManyInput>
    /**
     * Filter which DashboardSettings to update
     */
    where?: DashboardSettingsWhereInput
    /**
     * Limit how many DashboardSettings to update.
     */
    limit?: number
  }

  /**
   * DashboardSettings updateManyAndReturn
   */
  export type DashboardSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardSettings
     */
    select?: DashboardSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardSettings
     */
    omit?: DashboardSettingsOmit<ExtArgs> | null
    /**
     * The data used to update DashboardSettings.
     */
    data: XOR<DashboardSettingsUpdateManyMutationInput, DashboardSettingsUncheckedUpdateManyInput>
    /**
     * Filter which DashboardSettings to update
     */
    where?: DashboardSettingsWhereInput
    /**
     * Limit how many DashboardSettings to update.
     */
    limit?: number
  }

  /**
   * DashboardSettings upsert
   */
  export type DashboardSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardSettings
     */
    select?: DashboardSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardSettings
     */
    omit?: DashboardSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the DashboardSettings to update in case it exists.
     */
    where: DashboardSettingsWhereUniqueInput
    /**
     * In case the DashboardSettings found by the `where` argument doesn't exist, create a new DashboardSettings with this data.
     */
    create: XOR<DashboardSettingsCreateInput, DashboardSettingsUncheckedCreateInput>
    /**
     * In case the DashboardSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardSettingsUpdateInput, DashboardSettingsUncheckedUpdateInput>
  }

  /**
   * DashboardSettings delete
   */
  export type DashboardSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardSettings
     */
    select?: DashboardSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardSettings
     */
    omit?: DashboardSettingsOmit<ExtArgs> | null
    /**
     * Filter which DashboardSettings to delete.
     */
    where: DashboardSettingsWhereUniqueInput
  }

  /**
   * DashboardSettings deleteMany
   */
  export type DashboardSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardSettings to delete
     */
    where?: DashboardSettingsWhereInput
    /**
     * Limit how many DashboardSettings to delete.
     */
    limit?: number
  }

  /**
   * DashboardSettings without action
   */
  export type DashboardSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardSettings
     */
    select?: DashboardSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardSettings
     */
    omit?: DashboardSettingsOmit<ExtArgs> | null
  }


  /**
   * Model CommunityBookmark
   */

  export type AggregateCommunityBookmark = {
    _count: CommunityBookmarkCountAggregateOutputType | null
    _avg: CommunityBookmarkAvgAggregateOutputType | null
    _sum: CommunityBookmarkSumAggregateOutputType | null
    _min: CommunityBookmarkMinAggregateOutputType | null
    _max: CommunityBookmarkMaxAggregateOutputType | null
  }

  export type CommunityBookmarkAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type CommunityBookmarkSumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type CommunityBookmarkMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    url: string | null
    icon: string | null
    category: string | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityBookmarkMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    url: string | null
    icon: string | null
    category: string | null
    order: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityBookmarkCountAggregateOutputType = {
    id: number
    title: number
    description: number
    url: number
    icon: number
    category: number
    order: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunityBookmarkAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type CommunityBookmarkSumAggregateInputType = {
    id?: true
    order?: true
  }

  export type CommunityBookmarkMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    icon?: true
    category?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityBookmarkMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    icon?: true
    category?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityBookmarkCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    url?: true
    icon?: true
    category?: true
    order?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunityBookmarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityBookmark to aggregate.
     */
    where?: CommunityBookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBookmarks to fetch.
     */
    orderBy?: CommunityBookmarkOrderByWithRelationInput | CommunityBookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityBookmarks
    **/
    _count?: true | CommunityBookmarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityBookmarkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityBookmarkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityBookmarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityBookmarkMaxAggregateInputType
  }

  export type GetCommunityBookmarkAggregateType<T extends CommunityBookmarkAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityBookmark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityBookmark[P]>
      : GetScalarType<T[P], AggregateCommunityBookmark[P]>
  }




  export type CommunityBookmarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityBookmarkWhereInput
    orderBy?: CommunityBookmarkOrderByWithAggregationInput | CommunityBookmarkOrderByWithAggregationInput[]
    by: CommunityBookmarkScalarFieldEnum[] | CommunityBookmarkScalarFieldEnum
    having?: CommunityBookmarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityBookmarkCountAggregateInputType | true
    _avg?: CommunityBookmarkAvgAggregateInputType
    _sum?: CommunityBookmarkSumAggregateInputType
    _min?: CommunityBookmarkMinAggregateInputType
    _max?: CommunityBookmarkMaxAggregateInputType
  }

  export type CommunityBookmarkGroupByOutputType = {
    id: number
    title: string
    description: string | null
    url: string
    icon: string | null
    category: string
    order: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CommunityBookmarkCountAggregateOutputType | null
    _avg: CommunityBookmarkAvgAggregateOutputType | null
    _sum: CommunityBookmarkSumAggregateOutputType | null
    _min: CommunityBookmarkMinAggregateOutputType | null
    _max: CommunityBookmarkMaxAggregateOutputType | null
  }

  type GetCommunityBookmarkGroupByPayload<T extends CommunityBookmarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityBookmarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityBookmarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityBookmarkGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityBookmarkGroupByOutputType[P]>
        }
      >
    >


  export type CommunityBookmarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    icon?: boolean
    category?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["communityBookmark"]>

  export type CommunityBookmarkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    icon?: boolean
    category?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["communityBookmark"]>

  export type CommunityBookmarkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    icon?: boolean
    category?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["communityBookmark"]>

  export type CommunityBookmarkSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    icon?: boolean
    category?: boolean
    order?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunityBookmarkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "url" | "icon" | "category" | "order" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["communityBookmark"]>

  export type $CommunityBookmarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityBookmark"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      url: string
      icon: string | null
      category: string
      order: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communityBookmark"]>
    composites: {}
  }

  type CommunityBookmarkGetPayload<S extends boolean | null | undefined | CommunityBookmarkDefaultArgs> = $Result.GetResult<Prisma.$CommunityBookmarkPayload, S>

  type CommunityBookmarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityBookmarkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityBookmarkCountAggregateInputType | true
    }

  export interface CommunityBookmarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityBookmark'], meta: { name: 'CommunityBookmark' } }
    /**
     * Find zero or one CommunityBookmark that matches the filter.
     * @param {CommunityBookmarkFindUniqueArgs} args - Arguments to find a CommunityBookmark
     * @example
     * // Get one CommunityBookmark
     * const communityBookmark = await prisma.communityBookmark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityBookmarkFindUniqueArgs>(args: SelectSubset<T, CommunityBookmarkFindUniqueArgs<ExtArgs>>): Prisma__CommunityBookmarkClient<$Result.GetResult<Prisma.$CommunityBookmarkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommunityBookmark that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityBookmarkFindUniqueOrThrowArgs} args - Arguments to find a CommunityBookmark
     * @example
     * // Get one CommunityBookmark
     * const communityBookmark = await prisma.communityBookmark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityBookmarkFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityBookmarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityBookmarkClient<$Result.GetResult<Prisma.$CommunityBookmarkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityBookmark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBookmarkFindFirstArgs} args - Arguments to find a CommunityBookmark
     * @example
     * // Get one CommunityBookmark
     * const communityBookmark = await prisma.communityBookmark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityBookmarkFindFirstArgs>(args?: SelectSubset<T, CommunityBookmarkFindFirstArgs<ExtArgs>>): Prisma__CommunityBookmarkClient<$Result.GetResult<Prisma.$CommunityBookmarkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityBookmark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBookmarkFindFirstOrThrowArgs} args - Arguments to find a CommunityBookmark
     * @example
     * // Get one CommunityBookmark
     * const communityBookmark = await prisma.communityBookmark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityBookmarkFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityBookmarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityBookmarkClient<$Result.GetResult<Prisma.$CommunityBookmarkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunityBookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBookmarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityBookmarks
     * const communityBookmarks = await prisma.communityBookmark.findMany()
     * 
     * // Get first 10 CommunityBookmarks
     * const communityBookmarks = await prisma.communityBookmark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityBookmarkWithIdOnly = await prisma.communityBookmark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityBookmarkFindManyArgs>(args?: SelectSubset<T, CommunityBookmarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityBookmarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommunityBookmark.
     * @param {CommunityBookmarkCreateArgs} args - Arguments to create a CommunityBookmark.
     * @example
     * // Create one CommunityBookmark
     * const CommunityBookmark = await prisma.communityBookmark.create({
     *   data: {
     *     // ... data to create a CommunityBookmark
     *   }
     * })
     * 
     */
    create<T extends CommunityBookmarkCreateArgs>(args: SelectSubset<T, CommunityBookmarkCreateArgs<ExtArgs>>): Prisma__CommunityBookmarkClient<$Result.GetResult<Prisma.$CommunityBookmarkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommunityBookmarks.
     * @param {CommunityBookmarkCreateManyArgs} args - Arguments to create many CommunityBookmarks.
     * @example
     * // Create many CommunityBookmarks
     * const communityBookmark = await prisma.communityBookmark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityBookmarkCreateManyArgs>(args?: SelectSubset<T, CommunityBookmarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityBookmarks and returns the data saved in the database.
     * @param {CommunityBookmarkCreateManyAndReturnArgs} args - Arguments to create many CommunityBookmarks.
     * @example
     * // Create many CommunityBookmarks
     * const communityBookmark = await prisma.communityBookmark.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityBookmarks and only return the `id`
     * const communityBookmarkWithIdOnly = await prisma.communityBookmark.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityBookmarkCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityBookmarkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityBookmarkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommunityBookmark.
     * @param {CommunityBookmarkDeleteArgs} args - Arguments to delete one CommunityBookmark.
     * @example
     * // Delete one CommunityBookmark
     * const CommunityBookmark = await prisma.communityBookmark.delete({
     *   where: {
     *     // ... filter to delete one CommunityBookmark
     *   }
     * })
     * 
     */
    delete<T extends CommunityBookmarkDeleteArgs>(args: SelectSubset<T, CommunityBookmarkDeleteArgs<ExtArgs>>): Prisma__CommunityBookmarkClient<$Result.GetResult<Prisma.$CommunityBookmarkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommunityBookmark.
     * @param {CommunityBookmarkUpdateArgs} args - Arguments to update one CommunityBookmark.
     * @example
     * // Update one CommunityBookmark
     * const communityBookmark = await prisma.communityBookmark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityBookmarkUpdateArgs>(args: SelectSubset<T, CommunityBookmarkUpdateArgs<ExtArgs>>): Prisma__CommunityBookmarkClient<$Result.GetResult<Prisma.$CommunityBookmarkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommunityBookmarks.
     * @param {CommunityBookmarkDeleteManyArgs} args - Arguments to filter CommunityBookmarks to delete.
     * @example
     * // Delete a few CommunityBookmarks
     * const { count } = await prisma.communityBookmark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityBookmarkDeleteManyArgs>(args?: SelectSubset<T, CommunityBookmarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityBookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBookmarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityBookmarks
     * const communityBookmark = await prisma.communityBookmark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityBookmarkUpdateManyArgs>(args: SelectSubset<T, CommunityBookmarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityBookmarks and returns the data updated in the database.
     * @param {CommunityBookmarkUpdateManyAndReturnArgs} args - Arguments to update many CommunityBookmarks.
     * @example
     * // Update many CommunityBookmarks
     * const communityBookmark = await prisma.communityBookmark.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommunityBookmarks and only return the `id`
     * const communityBookmarkWithIdOnly = await prisma.communityBookmark.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommunityBookmarkUpdateManyAndReturnArgs>(args: SelectSubset<T, CommunityBookmarkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityBookmarkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommunityBookmark.
     * @param {CommunityBookmarkUpsertArgs} args - Arguments to update or create a CommunityBookmark.
     * @example
     * // Update or create a CommunityBookmark
     * const communityBookmark = await prisma.communityBookmark.upsert({
     *   create: {
     *     // ... data to create a CommunityBookmark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityBookmark we want to update
     *   }
     * })
     */
    upsert<T extends CommunityBookmarkUpsertArgs>(args: SelectSubset<T, CommunityBookmarkUpsertArgs<ExtArgs>>): Prisma__CommunityBookmarkClient<$Result.GetResult<Prisma.$CommunityBookmarkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommunityBookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBookmarkCountArgs} args - Arguments to filter CommunityBookmarks to count.
     * @example
     * // Count the number of CommunityBookmarks
     * const count = await prisma.communityBookmark.count({
     *   where: {
     *     // ... the filter for the CommunityBookmarks we want to count
     *   }
     * })
    **/
    count<T extends CommunityBookmarkCountArgs>(
      args?: Subset<T, CommunityBookmarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityBookmarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityBookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBookmarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityBookmarkAggregateArgs>(args: Subset<T, CommunityBookmarkAggregateArgs>): Prisma.PrismaPromise<GetCommunityBookmarkAggregateType<T>>

    /**
     * Group by CommunityBookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityBookmarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityBookmarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityBookmarkGroupByArgs['orderBy'] }
        : { orderBy?: CommunityBookmarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityBookmarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityBookmarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityBookmark model
   */
  readonly fields: CommunityBookmarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityBookmark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityBookmarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityBookmark model
   */
  interface CommunityBookmarkFieldRefs {
    readonly id: FieldRef<"CommunityBookmark", 'Int'>
    readonly title: FieldRef<"CommunityBookmark", 'String'>
    readonly description: FieldRef<"CommunityBookmark", 'String'>
    readonly url: FieldRef<"CommunityBookmark", 'String'>
    readonly icon: FieldRef<"CommunityBookmark", 'String'>
    readonly category: FieldRef<"CommunityBookmark", 'String'>
    readonly order: FieldRef<"CommunityBookmark", 'Int'>
    readonly isActive: FieldRef<"CommunityBookmark", 'Boolean'>
    readonly createdAt: FieldRef<"CommunityBookmark", 'DateTime'>
    readonly updatedAt: FieldRef<"CommunityBookmark", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityBookmark findUnique
   */
  export type CommunityBookmarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBookmark
     */
    select?: CommunityBookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBookmark
     */
    omit?: CommunityBookmarkOmit<ExtArgs> | null
    /**
     * Filter, which CommunityBookmark to fetch.
     */
    where: CommunityBookmarkWhereUniqueInput
  }

  /**
   * CommunityBookmark findUniqueOrThrow
   */
  export type CommunityBookmarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBookmark
     */
    select?: CommunityBookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBookmark
     */
    omit?: CommunityBookmarkOmit<ExtArgs> | null
    /**
     * Filter, which CommunityBookmark to fetch.
     */
    where: CommunityBookmarkWhereUniqueInput
  }

  /**
   * CommunityBookmark findFirst
   */
  export type CommunityBookmarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBookmark
     */
    select?: CommunityBookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBookmark
     */
    omit?: CommunityBookmarkOmit<ExtArgs> | null
    /**
     * Filter, which CommunityBookmark to fetch.
     */
    where?: CommunityBookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBookmarks to fetch.
     */
    orderBy?: CommunityBookmarkOrderByWithRelationInput | CommunityBookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityBookmarks.
     */
    cursor?: CommunityBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityBookmarks.
     */
    distinct?: CommunityBookmarkScalarFieldEnum | CommunityBookmarkScalarFieldEnum[]
  }

  /**
   * CommunityBookmark findFirstOrThrow
   */
  export type CommunityBookmarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBookmark
     */
    select?: CommunityBookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBookmark
     */
    omit?: CommunityBookmarkOmit<ExtArgs> | null
    /**
     * Filter, which CommunityBookmark to fetch.
     */
    where?: CommunityBookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBookmarks to fetch.
     */
    orderBy?: CommunityBookmarkOrderByWithRelationInput | CommunityBookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityBookmarks.
     */
    cursor?: CommunityBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityBookmarks.
     */
    distinct?: CommunityBookmarkScalarFieldEnum | CommunityBookmarkScalarFieldEnum[]
  }

  /**
   * CommunityBookmark findMany
   */
  export type CommunityBookmarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBookmark
     */
    select?: CommunityBookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBookmark
     */
    omit?: CommunityBookmarkOmit<ExtArgs> | null
    /**
     * Filter, which CommunityBookmarks to fetch.
     */
    where?: CommunityBookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityBookmarks to fetch.
     */
    orderBy?: CommunityBookmarkOrderByWithRelationInput | CommunityBookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityBookmarks.
     */
    cursor?: CommunityBookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityBookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityBookmarks.
     */
    skip?: number
    distinct?: CommunityBookmarkScalarFieldEnum | CommunityBookmarkScalarFieldEnum[]
  }

  /**
   * CommunityBookmark create
   */
  export type CommunityBookmarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBookmark
     */
    select?: CommunityBookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBookmark
     */
    omit?: CommunityBookmarkOmit<ExtArgs> | null
    /**
     * The data needed to create a CommunityBookmark.
     */
    data: XOR<CommunityBookmarkCreateInput, CommunityBookmarkUncheckedCreateInput>
  }

  /**
   * CommunityBookmark createMany
   */
  export type CommunityBookmarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityBookmarks.
     */
    data: CommunityBookmarkCreateManyInput | CommunityBookmarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityBookmark createManyAndReturn
   */
  export type CommunityBookmarkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBookmark
     */
    select?: CommunityBookmarkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBookmark
     */
    omit?: CommunityBookmarkOmit<ExtArgs> | null
    /**
     * The data used to create many CommunityBookmarks.
     */
    data: CommunityBookmarkCreateManyInput | CommunityBookmarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityBookmark update
   */
  export type CommunityBookmarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBookmark
     */
    select?: CommunityBookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBookmark
     */
    omit?: CommunityBookmarkOmit<ExtArgs> | null
    /**
     * The data needed to update a CommunityBookmark.
     */
    data: XOR<CommunityBookmarkUpdateInput, CommunityBookmarkUncheckedUpdateInput>
    /**
     * Choose, which CommunityBookmark to update.
     */
    where: CommunityBookmarkWhereUniqueInput
  }

  /**
   * CommunityBookmark updateMany
   */
  export type CommunityBookmarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityBookmarks.
     */
    data: XOR<CommunityBookmarkUpdateManyMutationInput, CommunityBookmarkUncheckedUpdateManyInput>
    /**
     * Filter which CommunityBookmarks to update
     */
    where?: CommunityBookmarkWhereInput
    /**
     * Limit how many CommunityBookmarks to update.
     */
    limit?: number
  }

  /**
   * CommunityBookmark updateManyAndReturn
   */
  export type CommunityBookmarkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBookmark
     */
    select?: CommunityBookmarkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBookmark
     */
    omit?: CommunityBookmarkOmit<ExtArgs> | null
    /**
     * The data used to update CommunityBookmarks.
     */
    data: XOR<CommunityBookmarkUpdateManyMutationInput, CommunityBookmarkUncheckedUpdateManyInput>
    /**
     * Filter which CommunityBookmarks to update
     */
    where?: CommunityBookmarkWhereInput
    /**
     * Limit how many CommunityBookmarks to update.
     */
    limit?: number
  }

  /**
   * CommunityBookmark upsert
   */
  export type CommunityBookmarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBookmark
     */
    select?: CommunityBookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBookmark
     */
    omit?: CommunityBookmarkOmit<ExtArgs> | null
    /**
     * The filter to search for the CommunityBookmark to update in case it exists.
     */
    where: CommunityBookmarkWhereUniqueInput
    /**
     * In case the CommunityBookmark found by the `where` argument doesn't exist, create a new CommunityBookmark with this data.
     */
    create: XOR<CommunityBookmarkCreateInput, CommunityBookmarkUncheckedCreateInput>
    /**
     * In case the CommunityBookmark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityBookmarkUpdateInput, CommunityBookmarkUncheckedUpdateInput>
  }

  /**
   * CommunityBookmark delete
   */
  export type CommunityBookmarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBookmark
     */
    select?: CommunityBookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBookmark
     */
    omit?: CommunityBookmarkOmit<ExtArgs> | null
    /**
     * Filter which CommunityBookmark to delete.
     */
    where: CommunityBookmarkWhereUniqueInput
  }

  /**
   * CommunityBookmark deleteMany
   */
  export type CommunityBookmarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityBookmarks to delete
     */
    where?: CommunityBookmarkWhereInput
    /**
     * Limit how many CommunityBookmarks to delete.
     */
    limit?: number
  }

  /**
   * CommunityBookmark without action
   */
  export type CommunityBookmarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityBookmark
     */
    select?: CommunityBookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityBookmark
     */
    omit?: CommunityBookmarkOmit<ExtArgs> | null
  }


  /**
   * Model DashboardAnnouncement
   */

  export type AggregateDashboardAnnouncement = {
    _count: DashboardAnnouncementCountAggregateOutputType | null
    _avg: DashboardAnnouncementAvgAggregateOutputType | null
    _sum: DashboardAnnouncementSumAggregateOutputType | null
    _min: DashboardAnnouncementMinAggregateOutputType | null
    _max: DashboardAnnouncementMaxAggregateOutputType | null
  }

  export type DashboardAnnouncementAvgAggregateOutputType = {
    id: number | null
    priority: number | null
  }

  export type DashboardAnnouncementSumAggregateOutputType = {
    id: number | null
    priority: number | null
  }

  export type DashboardAnnouncementMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    type: string | null
    isActive: boolean | null
    priority: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type DashboardAnnouncementMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    type: string | null
    isActive: boolean | null
    priority: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type DashboardAnnouncementCountAggregateOutputType = {
    id: number
    title: number
    content: number
    type: number
    isActive: number
    priority: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type DashboardAnnouncementAvgAggregateInputType = {
    id?: true
    priority?: true
  }

  export type DashboardAnnouncementSumAggregateInputType = {
    id?: true
    priority?: true
  }

  export type DashboardAnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    isActive?: true
    priority?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type DashboardAnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    isActive?: true
    priority?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type DashboardAnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    type?: true
    isActive?: true
    priority?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type DashboardAnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardAnnouncement to aggregate.
     */
    where?: DashboardAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardAnnouncements to fetch.
     */
    orderBy?: DashboardAnnouncementOrderByWithRelationInput | DashboardAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardAnnouncements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardAnnouncements
    **/
    _count?: true | DashboardAnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardAnnouncementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardAnnouncementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardAnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardAnnouncementMaxAggregateInputType
  }

  export type GetDashboardAnnouncementAggregateType<T extends DashboardAnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardAnnouncement[P]>
      : GetScalarType<T[P], AggregateDashboardAnnouncement[P]>
  }




  export type DashboardAnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardAnnouncementWhereInput
    orderBy?: DashboardAnnouncementOrderByWithAggregationInput | DashboardAnnouncementOrderByWithAggregationInput[]
    by: DashboardAnnouncementScalarFieldEnum[] | DashboardAnnouncementScalarFieldEnum
    having?: DashboardAnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardAnnouncementCountAggregateInputType | true
    _avg?: DashboardAnnouncementAvgAggregateInputType
    _sum?: DashboardAnnouncementSumAggregateInputType
    _min?: DashboardAnnouncementMinAggregateInputType
    _max?: DashboardAnnouncementMaxAggregateInputType
  }

  export type DashboardAnnouncementGroupByOutputType = {
    id: number
    title: string
    content: string
    type: string
    isActive: boolean
    priority: number
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    createdBy: string
    _count: DashboardAnnouncementCountAggregateOutputType | null
    _avg: DashboardAnnouncementAvgAggregateOutputType | null
    _sum: DashboardAnnouncementSumAggregateOutputType | null
    _min: DashboardAnnouncementMinAggregateOutputType | null
    _max: DashboardAnnouncementMaxAggregateOutputType | null
  }

  type GetDashboardAnnouncementGroupByPayload<T extends DashboardAnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardAnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardAnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardAnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardAnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type DashboardAnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    isActive?: boolean
    priority?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["dashboardAnnouncement"]>

  export type DashboardAnnouncementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    isActive?: boolean
    priority?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["dashboardAnnouncement"]>

  export type DashboardAnnouncementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    isActive?: boolean
    priority?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["dashboardAnnouncement"]>

  export type DashboardAnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    isActive?: boolean
    priority?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type DashboardAnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "type" | "isActive" | "priority" | "expiresAt" | "createdAt" | "updatedAt" | "createdBy", ExtArgs["result"]["dashboardAnnouncement"]>

  export type $DashboardAnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DashboardAnnouncement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      type: string
      isActive: boolean
      priority: number
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
      createdBy: string
    }, ExtArgs["result"]["dashboardAnnouncement"]>
    composites: {}
  }

  type DashboardAnnouncementGetPayload<S extends boolean | null | undefined | DashboardAnnouncementDefaultArgs> = $Result.GetResult<Prisma.$DashboardAnnouncementPayload, S>

  type DashboardAnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DashboardAnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DashboardAnnouncementCountAggregateInputType | true
    }

  export interface DashboardAnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DashboardAnnouncement'], meta: { name: 'DashboardAnnouncement' } }
    /**
     * Find zero or one DashboardAnnouncement that matches the filter.
     * @param {DashboardAnnouncementFindUniqueArgs} args - Arguments to find a DashboardAnnouncement
     * @example
     * // Get one DashboardAnnouncement
     * const dashboardAnnouncement = await prisma.dashboardAnnouncement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardAnnouncementFindUniqueArgs>(args: SelectSubset<T, DashboardAnnouncementFindUniqueArgs<ExtArgs>>): Prisma__DashboardAnnouncementClient<$Result.GetResult<Prisma.$DashboardAnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DashboardAnnouncement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DashboardAnnouncementFindUniqueOrThrowArgs} args - Arguments to find a DashboardAnnouncement
     * @example
     * // Get one DashboardAnnouncement
     * const dashboardAnnouncement = await prisma.dashboardAnnouncement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardAnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardAnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardAnnouncementClient<$Result.GetResult<Prisma.$DashboardAnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardAnnouncement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnnouncementFindFirstArgs} args - Arguments to find a DashboardAnnouncement
     * @example
     * // Get one DashboardAnnouncement
     * const dashboardAnnouncement = await prisma.dashboardAnnouncement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardAnnouncementFindFirstArgs>(args?: SelectSubset<T, DashboardAnnouncementFindFirstArgs<ExtArgs>>): Prisma__DashboardAnnouncementClient<$Result.GetResult<Prisma.$DashboardAnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DashboardAnnouncement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnnouncementFindFirstOrThrowArgs} args - Arguments to find a DashboardAnnouncement
     * @example
     * // Get one DashboardAnnouncement
     * const dashboardAnnouncement = await prisma.dashboardAnnouncement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardAnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardAnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardAnnouncementClient<$Result.GetResult<Prisma.$DashboardAnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DashboardAnnouncements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardAnnouncements
     * const dashboardAnnouncements = await prisma.dashboardAnnouncement.findMany()
     * 
     * // Get first 10 DashboardAnnouncements
     * const dashboardAnnouncements = await prisma.dashboardAnnouncement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardAnnouncementWithIdOnly = await prisma.dashboardAnnouncement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardAnnouncementFindManyArgs>(args?: SelectSubset<T, DashboardAnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardAnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DashboardAnnouncement.
     * @param {DashboardAnnouncementCreateArgs} args - Arguments to create a DashboardAnnouncement.
     * @example
     * // Create one DashboardAnnouncement
     * const DashboardAnnouncement = await prisma.dashboardAnnouncement.create({
     *   data: {
     *     // ... data to create a DashboardAnnouncement
     *   }
     * })
     * 
     */
    create<T extends DashboardAnnouncementCreateArgs>(args: SelectSubset<T, DashboardAnnouncementCreateArgs<ExtArgs>>): Prisma__DashboardAnnouncementClient<$Result.GetResult<Prisma.$DashboardAnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DashboardAnnouncements.
     * @param {DashboardAnnouncementCreateManyArgs} args - Arguments to create many DashboardAnnouncements.
     * @example
     * // Create many DashboardAnnouncements
     * const dashboardAnnouncement = await prisma.dashboardAnnouncement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardAnnouncementCreateManyArgs>(args?: SelectSubset<T, DashboardAnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DashboardAnnouncements and returns the data saved in the database.
     * @param {DashboardAnnouncementCreateManyAndReturnArgs} args - Arguments to create many DashboardAnnouncements.
     * @example
     * // Create many DashboardAnnouncements
     * const dashboardAnnouncement = await prisma.dashboardAnnouncement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DashboardAnnouncements and only return the `id`
     * const dashboardAnnouncementWithIdOnly = await prisma.dashboardAnnouncement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardAnnouncementCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardAnnouncementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardAnnouncementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DashboardAnnouncement.
     * @param {DashboardAnnouncementDeleteArgs} args - Arguments to delete one DashboardAnnouncement.
     * @example
     * // Delete one DashboardAnnouncement
     * const DashboardAnnouncement = await prisma.dashboardAnnouncement.delete({
     *   where: {
     *     // ... filter to delete one DashboardAnnouncement
     *   }
     * })
     * 
     */
    delete<T extends DashboardAnnouncementDeleteArgs>(args: SelectSubset<T, DashboardAnnouncementDeleteArgs<ExtArgs>>): Prisma__DashboardAnnouncementClient<$Result.GetResult<Prisma.$DashboardAnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DashboardAnnouncement.
     * @param {DashboardAnnouncementUpdateArgs} args - Arguments to update one DashboardAnnouncement.
     * @example
     * // Update one DashboardAnnouncement
     * const dashboardAnnouncement = await prisma.dashboardAnnouncement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardAnnouncementUpdateArgs>(args: SelectSubset<T, DashboardAnnouncementUpdateArgs<ExtArgs>>): Prisma__DashboardAnnouncementClient<$Result.GetResult<Prisma.$DashboardAnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DashboardAnnouncements.
     * @param {DashboardAnnouncementDeleteManyArgs} args - Arguments to filter DashboardAnnouncements to delete.
     * @example
     * // Delete a few DashboardAnnouncements
     * const { count } = await prisma.dashboardAnnouncement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardAnnouncementDeleteManyArgs>(args?: SelectSubset<T, DashboardAnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardAnnouncements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardAnnouncements
     * const dashboardAnnouncement = await prisma.dashboardAnnouncement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardAnnouncementUpdateManyArgs>(args: SelectSubset<T, DashboardAnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardAnnouncements and returns the data updated in the database.
     * @param {DashboardAnnouncementUpdateManyAndReturnArgs} args - Arguments to update many DashboardAnnouncements.
     * @example
     * // Update many DashboardAnnouncements
     * const dashboardAnnouncement = await prisma.dashboardAnnouncement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DashboardAnnouncements and only return the `id`
     * const dashboardAnnouncementWithIdOnly = await prisma.dashboardAnnouncement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DashboardAnnouncementUpdateManyAndReturnArgs>(args: SelectSubset<T, DashboardAnnouncementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardAnnouncementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DashboardAnnouncement.
     * @param {DashboardAnnouncementUpsertArgs} args - Arguments to update or create a DashboardAnnouncement.
     * @example
     * // Update or create a DashboardAnnouncement
     * const dashboardAnnouncement = await prisma.dashboardAnnouncement.upsert({
     *   create: {
     *     // ... data to create a DashboardAnnouncement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardAnnouncement we want to update
     *   }
     * })
     */
    upsert<T extends DashboardAnnouncementUpsertArgs>(args: SelectSubset<T, DashboardAnnouncementUpsertArgs<ExtArgs>>): Prisma__DashboardAnnouncementClient<$Result.GetResult<Prisma.$DashboardAnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DashboardAnnouncements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnnouncementCountArgs} args - Arguments to filter DashboardAnnouncements to count.
     * @example
     * // Count the number of DashboardAnnouncements
     * const count = await prisma.dashboardAnnouncement.count({
     *   where: {
     *     // ... the filter for the DashboardAnnouncements we want to count
     *   }
     * })
    **/
    count<T extends DashboardAnnouncementCountArgs>(
      args?: Subset<T, DashboardAnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardAnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardAnnouncement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardAnnouncementAggregateArgs>(args: Subset<T, DashboardAnnouncementAggregateArgs>): Prisma.PrismaPromise<GetDashboardAnnouncementAggregateType<T>>

    /**
     * Group by DashboardAnnouncement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardAnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardAnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardAnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: DashboardAnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardAnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DashboardAnnouncement model
   */
  readonly fields: DashboardAnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardAnnouncement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardAnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DashboardAnnouncement model
   */
  interface DashboardAnnouncementFieldRefs {
    readonly id: FieldRef<"DashboardAnnouncement", 'Int'>
    readonly title: FieldRef<"DashboardAnnouncement", 'String'>
    readonly content: FieldRef<"DashboardAnnouncement", 'String'>
    readonly type: FieldRef<"DashboardAnnouncement", 'String'>
    readonly isActive: FieldRef<"DashboardAnnouncement", 'Boolean'>
    readonly priority: FieldRef<"DashboardAnnouncement", 'Int'>
    readonly expiresAt: FieldRef<"DashboardAnnouncement", 'DateTime'>
    readonly createdAt: FieldRef<"DashboardAnnouncement", 'DateTime'>
    readonly updatedAt: FieldRef<"DashboardAnnouncement", 'DateTime'>
    readonly createdBy: FieldRef<"DashboardAnnouncement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DashboardAnnouncement findUnique
   */
  export type DashboardAnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnnouncement
     */
    select?: DashboardAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnnouncement
     */
    omit?: DashboardAnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which DashboardAnnouncement to fetch.
     */
    where: DashboardAnnouncementWhereUniqueInput
  }

  /**
   * DashboardAnnouncement findUniqueOrThrow
   */
  export type DashboardAnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnnouncement
     */
    select?: DashboardAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnnouncement
     */
    omit?: DashboardAnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which DashboardAnnouncement to fetch.
     */
    where: DashboardAnnouncementWhereUniqueInput
  }

  /**
   * DashboardAnnouncement findFirst
   */
  export type DashboardAnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnnouncement
     */
    select?: DashboardAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnnouncement
     */
    omit?: DashboardAnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which DashboardAnnouncement to fetch.
     */
    where?: DashboardAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardAnnouncements to fetch.
     */
    orderBy?: DashboardAnnouncementOrderByWithRelationInput | DashboardAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardAnnouncements.
     */
    cursor?: DashboardAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardAnnouncements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardAnnouncements.
     */
    distinct?: DashboardAnnouncementScalarFieldEnum | DashboardAnnouncementScalarFieldEnum[]
  }

  /**
   * DashboardAnnouncement findFirstOrThrow
   */
  export type DashboardAnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnnouncement
     */
    select?: DashboardAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnnouncement
     */
    omit?: DashboardAnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which DashboardAnnouncement to fetch.
     */
    where?: DashboardAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardAnnouncements to fetch.
     */
    orderBy?: DashboardAnnouncementOrderByWithRelationInput | DashboardAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardAnnouncements.
     */
    cursor?: DashboardAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardAnnouncements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardAnnouncements.
     */
    distinct?: DashboardAnnouncementScalarFieldEnum | DashboardAnnouncementScalarFieldEnum[]
  }

  /**
   * DashboardAnnouncement findMany
   */
  export type DashboardAnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnnouncement
     */
    select?: DashboardAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnnouncement
     */
    omit?: DashboardAnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which DashboardAnnouncements to fetch.
     */
    where?: DashboardAnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardAnnouncements to fetch.
     */
    orderBy?: DashboardAnnouncementOrderByWithRelationInput | DashboardAnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardAnnouncements.
     */
    cursor?: DashboardAnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardAnnouncements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardAnnouncements.
     */
    skip?: number
    distinct?: DashboardAnnouncementScalarFieldEnum | DashboardAnnouncementScalarFieldEnum[]
  }

  /**
   * DashboardAnnouncement create
   */
  export type DashboardAnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnnouncement
     */
    select?: DashboardAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnnouncement
     */
    omit?: DashboardAnnouncementOmit<ExtArgs> | null
    /**
     * The data needed to create a DashboardAnnouncement.
     */
    data: XOR<DashboardAnnouncementCreateInput, DashboardAnnouncementUncheckedCreateInput>
  }

  /**
   * DashboardAnnouncement createMany
   */
  export type DashboardAnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DashboardAnnouncements.
     */
    data: DashboardAnnouncementCreateManyInput | DashboardAnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardAnnouncement createManyAndReturn
   */
  export type DashboardAnnouncementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnnouncement
     */
    select?: DashboardAnnouncementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnnouncement
     */
    omit?: DashboardAnnouncementOmit<ExtArgs> | null
    /**
     * The data used to create many DashboardAnnouncements.
     */
    data: DashboardAnnouncementCreateManyInput | DashboardAnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardAnnouncement update
   */
  export type DashboardAnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnnouncement
     */
    select?: DashboardAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnnouncement
     */
    omit?: DashboardAnnouncementOmit<ExtArgs> | null
    /**
     * The data needed to update a DashboardAnnouncement.
     */
    data: XOR<DashboardAnnouncementUpdateInput, DashboardAnnouncementUncheckedUpdateInput>
    /**
     * Choose, which DashboardAnnouncement to update.
     */
    where: DashboardAnnouncementWhereUniqueInput
  }

  /**
   * DashboardAnnouncement updateMany
   */
  export type DashboardAnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DashboardAnnouncements.
     */
    data: XOR<DashboardAnnouncementUpdateManyMutationInput, DashboardAnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which DashboardAnnouncements to update
     */
    where?: DashboardAnnouncementWhereInput
    /**
     * Limit how many DashboardAnnouncements to update.
     */
    limit?: number
  }

  /**
   * DashboardAnnouncement updateManyAndReturn
   */
  export type DashboardAnnouncementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnnouncement
     */
    select?: DashboardAnnouncementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnnouncement
     */
    omit?: DashboardAnnouncementOmit<ExtArgs> | null
    /**
     * The data used to update DashboardAnnouncements.
     */
    data: XOR<DashboardAnnouncementUpdateManyMutationInput, DashboardAnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which DashboardAnnouncements to update
     */
    where?: DashboardAnnouncementWhereInput
    /**
     * Limit how many DashboardAnnouncements to update.
     */
    limit?: number
  }

  /**
   * DashboardAnnouncement upsert
   */
  export type DashboardAnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnnouncement
     */
    select?: DashboardAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnnouncement
     */
    omit?: DashboardAnnouncementOmit<ExtArgs> | null
    /**
     * The filter to search for the DashboardAnnouncement to update in case it exists.
     */
    where: DashboardAnnouncementWhereUniqueInput
    /**
     * In case the DashboardAnnouncement found by the `where` argument doesn't exist, create a new DashboardAnnouncement with this data.
     */
    create: XOR<DashboardAnnouncementCreateInput, DashboardAnnouncementUncheckedCreateInput>
    /**
     * In case the DashboardAnnouncement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardAnnouncementUpdateInput, DashboardAnnouncementUncheckedUpdateInput>
  }

  /**
   * DashboardAnnouncement delete
   */
  export type DashboardAnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnnouncement
     */
    select?: DashboardAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnnouncement
     */
    omit?: DashboardAnnouncementOmit<ExtArgs> | null
    /**
     * Filter which DashboardAnnouncement to delete.
     */
    where: DashboardAnnouncementWhereUniqueInput
  }

  /**
   * DashboardAnnouncement deleteMany
   */
  export type DashboardAnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardAnnouncements to delete
     */
    where?: DashboardAnnouncementWhereInput
    /**
     * Limit how many DashboardAnnouncements to delete.
     */
    limit?: number
  }

  /**
   * DashboardAnnouncement without action
   */
  export type DashboardAnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardAnnouncement
     */
    select?: DashboardAnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DashboardAnnouncement
     */
    omit?: DashboardAnnouncementOmit<ExtArgs> | null
  }


  /**
   * Model UserInvitation
   */

  export type AggregateUserInvitation = {
    _count: UserInvitationCountAggregateOutputType | null
    _avg: UserInvitationAvgAggregateOutputType | null
    _sum: UserInvitationSumAggregateOutputType | null
    _min: UserInvitationMinAggregateOutputType | null
    _max: UserInvitationMaxAggregateOutputType | null
  }

  export type UserInvitationAvgAggregateOutputType = {
    id: number | null
    inviterUserId: number | null
  }

  export type UserInvitationSumAggregateOutputType = {
    id: number | null
    inviterUserId: number | null
  }

  export type UserInvitationMinAggregateOutputType = {
    id: number | null
    inviterUserId: number | null
    inviteeEmail: string | null
    inviteeName: string | null
    inviteePhone: string | null
    status: string | null
    inviteToken: string | null
    message: string | null
    expiresAt: Date | null
    acceptedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserInvitationMaxAggregateOutputType = {
    id: number | null
    inviterUserId: number | null
    inviteeEmail: string | null
    inviteeName: string | null
    inviteePhone: string | null
    status: string | null
    inviteToken: string | null
    message: string | null
    expiresAt: Date | null
    acceptedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserInvitationCountAggregateOutputType = {
    id: number
    inviterUserId: number
    inviteeEmail: number
    inviteeName: number
    inviteePhone: number
    roomIds: number
    status: number
    inviteToken: number
    message: number
    expiresAt: number
    acceptedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserInvitationAvgAggregateInputType = {
    id?: true
    inviterUserId?: true
  }

  export type UserInvitationSumAggregateInputType = {
    id?: true
    inviterUserId?: true
  }

  export type UserInvitationMinAggregateInputType = {
    id?: true
    inviterUserId?: true
    inviteeEmail?: true
    inviteeName?: true
    inviteePhone?: true
    status?: true
    inviteToken?: true
    message?: true
    expiresAt?: true
    acceptedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserInvitationMaxAggregateInputType = {
    id?: true
    inviterUserId?: true
    inviteeEmail?: true
    inviteeName?: true
    inviteePhone?: true
    status?: true
    inviteToken?: true
    message?: true
    expiresAt?: true
    acceptedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserInvitationCountAggregateInputType = {
    id?: true
    inviterUserId?: true
    inviteeEmail?: true
    inviteeName?: true
    inviteePhone?: true
    roomIds?: true
    status?: true
    inviteToken?: true
    message?: true
    expiresAt?: true
    acceptedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInvitation to aggregate.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInvitations
    **/
    _count?: true | UserInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserInvitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserInvitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInvitationMaxAggregateInputType
  }

  export type GetUserInvitationAggregateType<T extends UserInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInvitation[P]>
      : GetScalarType<T[P], AggregateUserInvitation[P]>
  }




  export type UserInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInvitationWhereInput
    orderBy?: UserInvitationOrderByWithAggregationInput | UserInvitationOrderByWithAggregationInput[]
    by: UserInvitationScalarFieldEnum[] | UserInvitationScalarFieldEnum
    having?: UserInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInvitationCountAggregateInputType | true
    _avg?: UserInvitationAvgAggregateInputType
    _sum?: UserInvitationSumAggregateInputType
    _min?: UserInvitationMinAggregateInputType
    _max?: UserInvitationMaxAggregateInputType
  }

  export type UserInvitationGroupByOutputType = {
    id: number
    inviterUserId: number | null
    inviteeEmail: string
    inviteeName: string | null
    inviteePhone: string | null
    roomIds: string[]
    status: string
    inviteToken: string | null
    message: string | null
    expiresAt: Date
    acceptedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserInvitationCountAggregateOutputType | null
    _avg: UserInvitationAvgAggregateOutputType | null
    _sum: UserInvitationSumAggregateOutputType | null
    _min: UserInvitationMinAggregateOutputType | null
    _max: UserInvitationMaxAggregateOutputType | null
  }

  type GetUserInvitationGroupByPayload<T extends UserInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], UserInvitationGroupByOutputType[P]>
        }
      >
    >


  export type UserInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterUserId?: boolean
    inviteeEmail?: boolean
    inviteeName?: boolean
    inviteePhone?: boolean
    roomIds?: boolean
    status?: boolean
    inviteToken?: boolean
    message?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inviter?: boolean | UserInvitation$inviterArgs<ExtArgs>
  }, ExtArgs["result"]["userInvitation"]>

  export type UserInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterUserId?: boolean
    inviteeEmail?: boolean
    inviteeName?: boolean
    inviteePhone?: boolean
    roomIds?: boolean
    status?: boolean
    inviteToken?: boolean
    message?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inviter?: boolean | UserInvitation$inviterArgs<ExtArgs>
  }, ExtArgs["result"]["userInvitation"]>

  export type UserInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviterUserId?: boolean
    inviteeEmail?: boolean
    inviteeName?: boolean
    inviteePhone?: boolean
    roomIds?: boolean
    status?: boolean
    inviteToken?: boolean
    message?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inviter?: boolean | UserInvitation$inviterArgs<ExtArgs>
  }, ExtArgs["result"]["userInvitation"]>

  export type UserInvitationSelectScalar = {
    id?: boolean
    inviterUserId?: boolean
    inviteeEmail?: boolean
    inviteeName?: boolean
    inviteePhone?: boolean
    roomIds?: boolean
    status?: boolean
    inviteToken?: boolean
    message?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inviterUserId" | "inviteeEmail" | "inviteeName" | "inviteePhone" | "roomIds" | "status" | "inviteToken" | "message" | "expiresAt" | "acceptedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userInvitation"]>
  export type UserInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserInvitation$inviterArgs<ExtArgs>
  }
  export type UserInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserInvitation$inviterArgs<ExtArgs>
  }
  export type UserInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviter?: boolean | UserInvitation$inviterArgs<ExtArgs>
  }

  export type $UserInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInvitation"
    objects: {
      inviter: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      inviterUserId: number | null
      inviteeEmail: string
      inviteeName: string | null
      inviteePhone: string | null
      roomIds: string[]
      status: string
      inviteToken: string | null
      message: string | null
      expiresAt: Date
      acceptedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userInvitation"]>
    composites: {}
  }

  type UserInvitationGetPayload<S extends boolean | null | undefined | UserInvitationDefaultArgs> = $Result.GetResult<Prisma.$UserInvitationPayload, S>

  type UserInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserInvitationCountAggregateInputType | true
    }

  export interface UserInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInvitation'], meta: { name: 'UserInvitation' } }
    /**
     * Find zero or one UserInvitation that matches the filter.
     * @param {UserInvitationFindUniqueArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInvitationFindUniqueArgs>(args: SelectSubset<T, UserInvitationFindUniqueArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserInvitationFindUniqueOrThrowArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationFindFirstArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInvitationFindFirstArgs>(args?: SelectSubset<T, UserInvitationFindFirstArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationFindFirstOrThrowArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInvitations
     * const userInvitations = await prisma.userInvitation.findMany()
     * 
     * // Get first 10 UserInvitations
     * const userInvitations = await prisma.userInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInvitationWithIdOnly = await prisma.userInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInvitationFindManyArgs>(args?: SelectSubset<T, UserInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserInvitation.
     * @param {UserInvitationCreateArgs} args - Arguments to create a UserInvitation.
     * @example
     * // Create one UserInvitation
     * const UserInvitation = await prisma.userInvitation.create({
     *   data: {
     *     // ... data to create a UserInvitation
     *   }
     * })
     * 
     */
    create<T extends UserInvitationCreateArgs>(args: SelectSubset<T, UserInvitationCreateArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserInvitations.
     * @param {UserInvitationCreateManyArgs} args - Arguments to create many UserInvitations.
     * @example
     * // Create many UserInvitations
     * const userInvitation = await prisma.userInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInvitationCreateManyArgs>(args?: SelectSubset<T, UserInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInvitations and returns the data saved in the database.
     * @param {UserInvitationCreateManyAndReturnArgs} args - Arguments to create many UserInvitations.
     * @example
     * // Create many UserInvitations
     * const userInvitation = await prisma.userInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInvitations and only return the `id`
     * const userInvitationWithIdOnly = await prisma.userInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserInvitation.
     * @param {UserInvitationDeleteArgs} args - Arguments to delete one UserInvitation.
     * @example
     * // Delete one UserInvitation
     * const UserInvitation = await prisma.userInvitation.delete({
     *   where: {
     *     // ... filter to delete one UserInvitation
     *   }
     * })
     * 
     */
    delete<T extends UserInvitationDeleteArgs>(args: SelectSubset<T, UserInvitationDeleteArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserInvitation.
     * @param {UserInvitationUpdateArgs} args - Arguments to update one UserInvitation.
     * @example
     * // Update one UserInvitation
     * const userInvitation = await prisma.userInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInvitationUpdateArgs>(args: SelectSubset<T, UserInvitationUpdateArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserInvitations.
     * @param {UserInvitationDeleteManyArgs} args - Arguments to filter UserInvitations to delete.
     * @example
     * // Delete a few UserInvitations
     * const { count } = await prisma.userInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInvitationDeleteManyArgs>(args?: SelectSubset<T, UserInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInvitations
     * const userInvitation = await prisma.userInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInvitationUpdateManyArgs>(args: SelectSubset<T, UserInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInvitations and returns the data updated in the database.
     * @param {UserInvitationUpdateManyAndReturnArgs} args - Arguments to update many UserInvitations.
     * @example
     * // Update many UserInvitations
     * const userInvitation = await prisma.userInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserInvitations and only return the `id`
     * const userInvitationWithIdOnly = await prisma.userInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, UserInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserInvitation.
     * @param {UserInvitationUpsertArgs} args - Arguments to update or create a UserInvitation.
     * @example
     * // Update or create a UserInvitation
     * const userInvitation = await prisma.userInvitation.upsert({
     *   create: {
     *     // ... data to create a UserInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInvitation we want to update
     *   }
     * })
     */
    upsert<T extends UserInvitationUpsertArgs>(args: SelectSubset<T, UserInvitationUpsertArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationCountArgs} args - Arguments to filter UserInvitations to count.
     * @example
     * // Count the number of UserInvitations
     * const count = await prisma.userInvitation.count({
     *   where: {
     *     // ... the filter for the UserInvitations we want to count
     *   }
     * })
    **/
    count<T extends UserInvitationCountArgs>(
      args?: Subset<T, UserInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInvitationAggregateArgs>(args: Subset<T, UserInvitationAggregateArgs>): Prisma.PrismaPromise<GetUserInvitationAggregateType<T>>

    /**
     * Group by UserInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInvitationGroupByArgs['orderBy'] }
        : { orderBy?: UserInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInvitation model
   */
  readonly fields: UserInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inviter<T extends UserInvitation$inviterArgs<ExtArgs> = {}>(args?: Subset<T, UserInvitation$inviterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInvitation model
   */
  interface UserInvitationFieldRefs {
    readonly id: FieldRef<"UserInvitation", 'Int'>
    readonly inviterUserId: FieldRef<"UserInvitation", 'Int'>
    readonly inviteeEmail: FieldRef<"UserInvitation", 'String'>
    readonly inviteeName: FieldRef<"UserInvitation", 'String'>
    readonly inviteePhone: FieldRef<"UserInvitation", 'String'>
    readonly roomIds: FieldRef<"UserInvitation", 'String[]'>
    readonly status: FieldRef<"UserInvitation", 'String'>
    readonly inviteToken: FieldRef<"UserInvitation", 'String'>
    readonly message: FieldRef<"UserInvitation", 'String'>
    readonly expiresAt: FieldRef<"UserInvitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"UserInvitation", 'DateTime'>
    readonly createdAt: FieldRef<"UserInvitation", 'DateTime'>
    readonly updatedAt: FieldRef<"UserInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserInvitation findUnique
   */
  export type UserInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation findUniqueOrThrow
   */
  export type UserInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation findFirst
   */
  export type UserInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInvitations.
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInvitations.
     */
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * UserInvitation findFirstOrThrow
   */
  export type UserInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInvitations.
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInvitations.
     */
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * UserInvitation findMany
   */
  export type UserInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitations to fetch.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInvitations.
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * UserInvitation create
   */
  export type UserInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInvitation.
     */
    data: XOR<UserInvitationCreateInput, UserInvitationUncheckedCreateInput>
  }

  /**
   * UserInvitation createMany
   */
  export type UserInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInvitations.
     */
    data: UserInvitationCreateManyInput | UserInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserInvitation createManyAndReturn
   */
  export type UserInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many UserInvitations.
     */
    data: UserInvitationCreateManyInput | UserInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInvitation update
   */
  export type UserInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInvitation.
     */
    data: XOR<UserInvitationUpdateInput, UserInvitationUncheckedUpdateInput>
    /**
     * Choose, which UserInvitation to update.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation updateMany
   */
  export type UserInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInvitations.
     */
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyInput>
    /**
     * Filter which UserInvitations to update
     */
    where?: UserInvitationWhereInput
    /**
     * Limit how many UserInvitations to update.
     */
    limit?: number
  }

  /**
   * UserInvitation updateManyAndReturn
   */
  export type UserInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * The data used to update UserInvitations.
     */
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyInput>
    /**
     * Filter which UserInvitations to update
     */
    where?: UserInvitationWhereInput
    /**
     * Limit how many UserInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInvitation upsert
   */
  export type UserInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInvitation to update in case it exists.
     */
    where: UserInvitationWhereUniqueInput
    /**
     * In case the UserInvitation found by the `where` argument doesn't exist, create a new UserInvitation with this data.
     */
    create: XOR<UserInvitationCreateInput, UserInvitationUncheckedCreateInput>
    /**
     * In case the UserInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInvitationUpdateInput, UserInvitationUncheckedUpdateInput>
  }

  /**
   * UserInvitation delete
   */
  export type UserInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter which UserInvitation to delete.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation deleteMany
   */
  export type UserInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInvitations to delete
     */
    where?: UserInvitationWhereInput
    /**
     * Limit how many UserInvitations to delete.
     */
    limit?: number
  }

  /**
   * UserInvitation.inviter
   */
  export type UserInvitation$inviterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UserInvitation without action
   */
  export type UserInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
  }


  /**
   * Model CommunityEvent
   */

  export type AggregateCommunityEvent = {
    _count: CommunityEventCountAggregateOutputType | null
    _avg: CommunityEventAvgAggregateOutputType | null
    _sum: CommunityEventSumAggregateOutputType | null
    _min: CommunityEventMinAggregateOutputType | null
    _max: CommunityEventMaxAggregateOutputType | null
  }

  export type CommunityEventAvgAggregateOutputType = {
    id: number | null
  }

  export type CommunityEventSumAggregateOutputType = {
    id: number | null
  }

  export type CommunityEventMinAggregateOutputType = {
    id: number | null
    eventType: string | null
    username: string | null
    details: string | null
    timestamp: Date | null
    isPublic: boolean | null
    category: string | null
  }

  export type CommunityEventMaxAggregateOutputType = {
    id: number | null
    eventType: string | null
    username: string | null
    details: string | null
    timestamp: Date | null
    isPublic: boolean | null
    category: string | null
  }

  export type CommunityEventCountAggregateOutputType = {
    id: number
    eventType: number
    username: number
    details: number
    timestamp: number
    isPublic: number
    category: number
    _all: number
  }


  export type CommunityEventAvgAggregateInputType = {
    id?: true
  }

  export type CommunityEventSumAggregateInputType = {
    id?: true
  }

  export type CommunityEventMinAggregateInputType = {
    id?: true
    eventType?: true
    username?: true
    details?: true
    timestamp?: true
    isPublic?: true
    category?: true
  }

  export type CommunityEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    username?: true
    details?: true
    timestamp?: true
    isPublic?: true
    category?: true
  }

  export type CommunityEventCountAggregateInputType = {
    id?: true
    eventType?: true
    username?: true
    details?: true
    timestamp?: true
    isPublic?: true
    category?: true
    _all?: true
  }

  export type CommunityEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityEvent to aggregate.
     */
    where?: CommunityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityEvents to fetch.
     */
    orderBy?: CommunityEventOrderByWithRelationInput | CommunityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityEvents
    **/
    _count?: true | CommunityEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityEventMaxAggregateInputType
  }

  export type GetCommunityEventAggregateType<T extends CommunityEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityEvent[P]>
      : GetScalarType<T[P], AggregateCommunityEvent[P]>
  }




  export type CommunityEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityEventWhereInput
    orderBy?: CommunityEventOrderByWithAggregationInput | CommunityEventOrderByWithAggregationInput[]
    by: CommunityEventScalarFieldEnum[] | CommunityEventScalarFieldEnum
    having?: CommunityEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityEventCountAggregateInputType | true
    _avg?: CommunityEventAvgAggregateInputType
    _sum?: CommunityEventSumAggregateInputType
    _min?: CommunityEventMinAggregateInputType
    _max?: CommunityEventMaxAggregateInputType
  }

  export type CommunityEventGroupByOutputType = {
    id: number
    eventType: string
    username: string
    details: string
    timestamp: Date
    isPublic: boolean
    category: string | null
    _count: CommunityEventCountAggregateOutputType | null
    _avg: CommunityEventAvgAggregateOutputType | null
    _sum: CommunityEventSumAggregateOutputType | null
    _min: CommunityEventMinAggregateOutputType | null
    _max: CommunityEventMaxAggregateOutputType | null
  }

  type GetCommunityEventGroupByPayload<T extends CommunityEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityEventGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityEventGroupByOutputType[P]>
        }
      >
    >


  export type CommunityEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    username?: boolean
    details?: boolean
    timestamp?: boolean
    isPublic?: boolean
    category?: boolean
  }, ExtArgs["result"]["communityEvent"]>

  export type CommunityEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    username?: boolean
    details?: boolean
    timestamp?: boolean
    isPublic?: boolean
    category?: boolean
  }, ExtArgs["result"]["communityEvent"]>

  export type CommunityEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    username?: boolean
    details?: boolean
    timestamp?: boolean
    isPublic?: boolean
    category?: boolean
  }, ExtArgs["result"]["communityEvent"]>

  export type CommunityEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    username?: boolean
    details?: boolean
    timestamp?: boolean
    isPublic?: boolean
    category?: boolean
  }

  export type CommunityEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventType" | "username" | "details" | "timestamp" | "isPublic" | "category", ExtArgs["result"]["communityEvent"]>

  export type $CommunityEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      eventType: string
      username: string
      details: string
      timestamp: Date
      isPublic: boolean
      category: string | null
    }, ExtArgs["result"]["communityEvent"]>
    composites: {}
  }

  type CommunityEventGetPayload<S extends boolean | null | undefined | CommunityEventDefaultArgs> = $Result.GetResult<Prisma.$CommunityEventPayload, S>

  type CommunityEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityEventCountAggregateInputType | true
    }

  export interface CommunityEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityEvent'], meta: { name: 'CommunityEvent' } }
    /**
     * Find zero or one CommunityEvent that matches the filter.
     * @param {CommunityEventFindUniqueArgs} args - Arguments to find a CommunityEvent
     * @example
     * // Get one CommunityEvent
     * const communityEvent = await prisma.communityEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityEventFindUniqueArgs>(args: SelectSubset<T, CommunityEventFindUniqueArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommunityEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityEventFindUniqueOrThrowArgs} args - Arguments to find a CommunityEvent
     * @example
     * // Get one CommunityEvent
     * const communityEvent = await prisma.communityEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventFindFirstArgs} args - Arguments to find a CommunityEvent
     * @example
     * // Get one CommunityEvent
     * const communityEvent = await prisma.communityEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityEventFindFirstArgs>(args?: SelectSubset<T, CommunityEventFindFirstArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventFindFirstOrThrowArgs} args - Arguments to find a CommunityEvent
     * @example
     * // Get one CommunityEvent
     * const communityEvent = await prisma.communityEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunityEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityEvents
     * const communityEvents = await prisma.communityEvent.findMany()
     * 
     * // Get first 10 CommunityEvents
     * const communityEvents = await prisma.communityEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityEventWithIdOnly = await prisma.communityEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityEventFindManyArgs>(args?: SelectSubset<T, CommunityEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommunityEvent.
     * @param {CommunityEventCreateArgs} args - Arguments to create a CommunityEvent.
     * @example
     * // Create one CommunityEvent
     * const CommunityEvent = await prisma.communityEvent.create({
     *   data: {
     *     // ... data to create a CommunityEvent
     *   }
     * })
     * 
     */
    create<T extends CommunityEventCreateArgs>(args: SelectSubset<T, CommunityEventCreateArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommunityEvents.
     * @param {CommunityEventCreateManyArgs} args - Arguments to create many CommunityEvents.
     * @example
     * // Create many CommunityEvents
     * const communityEvent = await prisma.communityEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityEventCreateManyArgs>(args?: SelectSubset<T, CommunityEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityEvents and returns the data saved in the database.
     * @param {CommunityEventCreateManyAndReturnArgs} args - Arguments to create many CommunityEvents.
     * @example
     * // Create many CommunityEvents
     * const communityEvent = await prisma.communityEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityEvents and only return the `id`
     * const communityEventWithIdOnly = await prisma.communityEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityEventCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommunityEvent.
     * @param {CommunityEventDeleteArgs} args - Arguments to delete one CommunityEvent.
     * @example
     * // Delete one CommunityEvent
     * const CommunityEvent = await prisma.communityEvent.delete({
     *   where: {
     *     // ... filter to delete one CommunityEvent
     *   }
     * })
     * 
     */
    delete<T extends CommunityEventDeleteArgs>(args: SelectSubset<T, CommunityEventDeleteArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommunityEvent.
     * @param {CommunityEventUpdateArgs} args - Arguments to update one CommunityEvent.
     * @example
     * // Update one CommunityEvent
     * const communityEvent = await prisma.communityEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityEventUpdateArgs>(args: SelectSubset<T, CommunityEventUpdateArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommunityEvents.
     * @param {CommunityEventDeleteManyArgs} args - Arguments to filter CommunityEvents to delete.
     * @example
     * // Delete a few CommunityEvents
     * const { count } = await prisma.communityEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityEventDeleteManyArgs>(args?: SelectSubset<T, CommunityEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityEvents
     * const communityEvent = await prisma.communityEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityEventUpdateManyArgs>(args: SelectSubset<T, CommunityEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityEvents and returns the data updated in the database.
     * @param {CommunityEventUpdateManyAndReturnArgs} args - Arguments to update many CommunityEvents.
     * @example
     * // Update many CommunityEvents
     * const communityEvent = await prisma.communityEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommunityEvents and only return the `id`
     * const communityEventWithIdOnly = await prisma.communityEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommunityEventUpdateManyAndReturnArgs>(args: SelectSubset<T, CommunityEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommunityEvent.
     * @param {CommunityEventUpsertArgs} args - Arguments to update or create a CommunityEvent.
     * @example
     * // Update or create a CommunityEvent
     * const communityEvent = await prisma.communityEvent.upsert({
     *   create: {
     *     // ... data to create a CommunityEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityEvent we want to update
     *   }
     * })
     */
    upsert<T extends CommunityEventUpsertArgs>(args: SelectSubset<T, CommunityEventUpsertArgs<ExtArgs>>): Prisma__CommunityEventClient<$Result.GetResult<Prisma.$CommunityEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommunityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventCountArgs} args - Arguments to filter CommunityEvents to count.
     * @example
     * // Count the number of CommunityEvents
     * const count = await prisma.communityEvent.count({
     *   where: {
     *     // ... the filter for the CommunityEvents we want to count
     *   }
     * })
    **/
    count<T extends CommunityEventCountArgs>(
      args?: Subset<T, CommunityEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityEventAggregateArgs>(args: Subset<T, CommunityEventAggregateArgs>): Prisma.PrismaPromise<GetCommunityEventAggregateType<T>>

    /**
     * Group by CommunityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityEventGroupByArgs['orderBy'] }
        : { orderBy?: CommunityEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityEvent model
   */
  readonly fields: CommunityEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityEvent model
   */
  interface CommunityEventFieldRefs {
    readonly id: FieldRef<"CommunityEvent", 'Int'>
    readonly eventType: FieldRef<"CommunityEvent", 'String'>
    readonly username: FieldRef<"CommunityEvent", 'String'>
    readonly details: FieldRef<"CommunityEvent", 'String'>
    readonly timestamp: FieldRef<"CommunityEvent", 'DateTime'>
    readonly isPublic: FieldRef<"CommunityEvent", 'Boolean'>
    readonly category: FieldRef<"CommunityEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CommunityEvent findUnique
   */
  export type CommunityEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityEvent
     */
    omit?: CommunityEventOmit<ExtArgs> | null
    /**
     * Filter, which CommunityEvent to fetch.
     */
    where: CommunityEventWhereUniqueInput
  }

  /**
   * CommunityEvent findUniqueOrThrow
   */
  export type CommunityEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityEvent
     */
    omit?: CommunityEventOmit<ExtArgs> | null
    /**
     * Filter, which CommunityEvent to fetch.
     */
    where: CommunityEventWhereUniqueInput
  }

  /**
   * CommunityEvent findFirst
   */
  export type CommunityEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityEvent
     */
    omit?: CommunityEventOmit<ExtArgs> | null
    /**
     * Filter, which CommunityEvent to fetch.
     */
    where?: CommunityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityEvents to fetch.
     */
    orderBy?: CommunityEventOrderByWithRelationInput | CommunityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityEvents.
     */
    cursor?: CommunityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityEvents.
     */
    distinct?: CommunityEventScalarFieldEnum | CommunityEventScalarFieldEnum[]
  }

  /**
   * CommunityEvent findFirstOrThrow
   */
  export type CommunityEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityEvent
     */
    omit?: CommunityEventOmit<ExtArgs> | null
    /**
     * Filter, which CommunityEvent to fetch.
     */
    where?: CommunityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityEvents to fetch.
     */
    orderBy?: CommunityEventOrderByWithRelationInput | CommunityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityEvents.
     */
    cursor?: CommunityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityEvents.
     */
    distinct?: CommunityEventScalarFieldEnum | CommunityEventScalarFieldEnum[]
  }

  /**
   * CommunityEvent findMany
   */
  export type CommunityEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityEvent
     */
    omit?: CommunityEventOmit<ExtArgs> | null
    /**
     * Filter, which CommunityEvents to fetch.
     */
    where?: CommunityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityEvents to fetch.
     */
    orderBy?: CommunityEventOrderByWithRelationInput | CommunityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityEvents.
     */
    cursor?: CommunityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityEvents.
     */
    skip?: number
    distinct?: CommunityEventScalarFieldEnum | CommunityEventScalarFieldEnum[]
  }

  /**
   * CommunityEvent create
   */
  export type CommunityEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityEvent
     */
    omit?: CommunityEventOmit<ExtArgs> | null
    /**
     * The data needed to create a CommunityEvent.
     */
    data: XOR<CommunityEventCreateInput, CommunityEventUncheckedCreateInput>
  }

  /**
   * CommunityEvent createMany
   */
  export type CommunityEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityEvents.
     */
    data: CommunityEventCreateManyInput | CommunityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityEvent createManyAndReturn
   */
  export type CommunityEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityEvent
     */
    omit?: CommunityEventOmit<ExtArgs> | null
    /**
     * The data used to create many CommunityEvents.
     */
    data: CommunityEventCreateManyInput | CommunityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityEvent update
   */
  export type CommunityEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityEvent
     */
    omit?: CommunityEventOmit<ExtArgs> | null
    /**
     * The data needed to update a CommunityEvent.
     */
    data: XOR<CommunityEventUpdateInput, CommunityEventUncheckedUpdateInput>
    /**
     * Choose, which CommunityEvent to update.
     */
    where: CommunityEventWhereUniqueInput
  }

  /**
   * CommunityEvent updateMany
   */
  export type CommunityEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityEvents.
     */
    data: XOR<CommunityEventUpdateManyMutationInput, CommunityEventUncheckedUpdateManyInput>
    /**
     * Filter which CommunityEvents to update
     */
    where?: CommunityEventWhereInput
    /**
     * Limit how many CommunityEvents to update.
     */
    limit?: number
  }

  /**
   * CommunityEvent updateManyAndReturn
   */
  export type CommunityEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityEvent
     */
    omit?: CommunityEventOmit<ExtArgs> | null
    /**
     * The data used to update CommunityEvents.
     */
    data: XOR<CommunityEventUpdateManyMutationInput, CommunityEventUncheckedUpdateManyInput>
    /**
     * Filter which CommunityEvents to update
     */
    where?: CommunityEventWhereInput
    /**
     * Limit how many CommunityEvents to update.
     */
    limit?: number
  }

  /**
   * CommunityEvent upsert
   */
  export type CommunityEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityEvent
     */
    omit?: CommunityEventOmit<ExtArgs> | null
    /**
     * The filter to search for the CommunityEvent to update in case it exists.
     */
    where: CommunityEventWhereUniqueInput
    /**
     * In case the CommunityEvent found by the `where` argument doesn't exist, create a new CommunityEvent with this data.
     */
    create: XOR<CommunityEventCreateInput, CommunityEventUncheckedCreateInput>
    /**
     * In case the CommunityEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityEventUpdateInput, CommunityEventUncheckedUpdateInput>
  }

  /**
   * CommunityEvent delete
   */
  export type CommunityEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityEvent
     */
    omit?: CommunityEventOmit<ExtArgs> | null
    /**
     * Filter which CommunityEvent to delete.
     */
    where: CommunityEventWhereUniqueInput
  }

  /**
   * CommunityEvent deleteMany
   */
  export type CommunityEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityEvents to delete
     */
    where?: CommunityEventWhereInput
    /**
     * Limit how many CommunityEvents to delete.
     */
    limit?: number
  }

  /**
   * CommunityEvent without action
   */
  export type CommunityEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityEvent
     */
    select?: CommunityEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityEvent
     */
    omit?: CommunityEventOmit<ExtArgs> | null
  }


  /**
   * Model VerificationCode
   */

  export type AggregateVerificationCode = {
    _count: VerificationCodeCountAggregateOutputType | null
    _avg: VerificationCodeAvgAggregateOutputType | null
    _sum: VerificationCodeSumAggregateOutputType | null
    _min: VerificationCodeMinAggregateOutputType | null
    _max: VerificationCodeMaxAggregateOutputType | null
  }

  export type VerificationCodeAvgAggregateOutputType = {
    id: number | null
  }

  export type VerificationCodeSumAggregateOutputType = {
    id: number | null
  }

  export type VerificationCodeMinAggregateOutputType = {
    id: number | null
    userId: string | null
    code: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type VerificationCodeMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    code: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type VerificationCodeCountAggregateOutputType = {
    id: number
    userId: number
    code: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type VerificationCodeAvgAggregateInputType = {
    id?: true
  }

  export type VerificationCodeSumAggregateInputType = {
    id?: true
  }

  export type VerificationCodeMinAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    createdAt?: true
    expiresAt?: true
  }

  export type VerificationCodeMaxAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    createdAt?: true
    expiresAt?: true
  }

  export type VerificationCodeCountAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type VerificationCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationCode to aggregate.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationCodes
    **/
    _count?: true | VerificationCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerificationCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerificationCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationCodeMaxAggregateInputType
  }

  export type GetVerificationCodeAggregateType<T extends VerificationCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationCode[P]>
      : GetScalarType<T[P], AggregateVerificationCode[P]>
  }




  export type VerificationCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationCodeWhereInput
    orderBy?: VerificationCodeOrderByWithAggregationInput | VerificationCodeOrderByWithAggregationInput[]
    by: VerificationCodeScalarFieldEnum[] | VerificationCodeScalarFieldEnum
    having?: VerificationCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCodeCountAggregateInputType | true
    _avg?: VerificationCodeAvgAggregateInputType
    _sum?: VerificationCodeSumAggregateInputType
    _min?: VerificationCodeMinAggregateInputType
    _max?: VerificationCodeMaxAggregateInputType
  }

  export type VerificationCodeGroupByOutputType = {
    id: number
    userId: string
    code: string
    createdAt: Date
    expiresAt: Date
    _count: VerificationCodeCountAggregateOutputType | null
    _avg: VerificationCodeAvgAggregateOutputType | null
    _sum: VerificationCodeSumAggregateOutputType | null
    _min: VerificationCodeMinAggregateOutputType | null
    _max: VerificationCodeMaxAggregateOutputType | null
  }

  type GetVerificationCodeGroupByPayload<T extends VerificationCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationCodeGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationCodeGroupByOutputType[P]>
        }
      >
    >


  export type VerificationCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectScalar = {
    id?: boolean
    userId?: boolean
    code?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type VerificationCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "code" | "createdAt" | "expiresAt", ExtArgs["result"]["verificationCode"]>

  export type $VerificationCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationCode"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      code: string
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["verificationCode"]>
    composites: {}
  }

  type VerificationCodeGetPayload<S extends boolean | null | undefined | VerificationCodeDefaultArgs> = $Result.GetResult<Prisma.$VerificationCodePayload, S>

  type VerificationCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCodeCountAggregateInputType | true
    }

  export interface VerificationCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationCode'], meta: { name: 'VerificationCode' } }
    /**
     * Find zero or one VerificationCode that matches the filter.
     * @param {VerificationCodeFindUniqueArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationCodeFindUniqueArgs>(args: SelectSubset<T, VerificationCodeFindUniqueArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationCodeFindUniqueOrThrowArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindFirstArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationCodeFindFirstArgs>(args?: SelectSubset<T, VerificationCodeFindFirstArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindFirstOrThrowArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationCodes
     * const verificationCodes = await prisma.verificationCode.findMany()
     * 
     * // Get first 10 VerificationCodes
     * const verificationCodes = await prisma.verificationCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationCodeFindManyArgs>(args?: SelectSubset<T, VerificationCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationCode.
     * @param {VerificationCodeCreateArgs} args - Arguments to create a VerificationCode.
     * @example
     * // Create one VerificationCode
     * const VerificationCode = await prisma.verificationCode.create({
     *   data: {
     *     // ... data to create a VerificationCode
     *   }
     * })
     * 
     */
    create<T extends VerificationCodeCreateArgs>(args: SelectSubset<T, VerificationCodeCreateArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationCodes.
     * @param {VerificationCodeCreateManyArgs} args - Arguments to create many VerificationCodes.
     * @example
     * // Create many VerificationCodes
     * const verificationCode = await prisma.verificationCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCodeCreateManyArgs>(args?: SelectSubset<T, VerificationCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationCodes and returns the data saved in the database.
     * @param {VerificationCodeCreateManyAndReturnArgs} args - Arguments to create many VerificationCodes.
     * @example
     * // Create many VerificationCodes
     * const verificationCode = await prisma.verificationCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationCodes and only return the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationCode.
     * @param {VerificationCodeDeleteArgs} args - Arguments to delete one VerificationCode.
     * @example
     * // Delete one VerificationCode
     * const VerificationCode = await prisma.verificationCode.delete({
     *   where: {
     *     // ... filter to delete one VerificationCode
     *   }
     * })
     * 
     */
    delete<T extends VerificationCodeDeleteArgs>(args: SelectSubset<T, VerificationCodeDeleteArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationCode.
     * @param {VerificationCodeUpdateArgs} args - Arguments to update one VerificationCode.
     * @example
     * // Update one VerificationCode
     * const verificationCode = await prisma.verificationCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationCodeUpdateArgs>(args: SelectSubset<T, VerificationCodeUpdateArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationCodes.
     * @param {VerificationCodeDeleteManyArgs} args - Arguments to filter VerificationCodes to delete.
     * @example
     * // Delete a few VerificationCodes
     * const { count } = await prisma.verificationCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationCodeDeleteManyArgs>(args?: SelectSubset<T, VerificationCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationCodes
     * const verificationCode = await prisma.verificationCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationCodeUpdateManyArgs>(args: SelectSubset<T, VerificationCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationCodes and returns the data updated in the database.
     * @param {VerificationCodeUpdateManyAndReturnArgs} args - Arguments to update many VerificationCodes.
     * @example
     * // Update many VerificationCodes
     * const verificationCode = await prisma.verificationCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationCodes and only return the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationCode.
     * @param {VerificationCodeUpsertArgs} args - Arguments to update or create a VerificationCode.
     * @example
     * // Update or create a VerificationCode
     * const verificationCode = await prisma.verificationCode.upsert({
     *   create: {
     *     // ... data to create a VerificationCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationCode we want to update
     *   }
     * })
     */
    upsert<T extends VerificationCodeUpsertArgs>(args: SelectSubset<T, VerificationCodeUpsertArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeCountArgs} args - Arguments to filter VerificationCodes to count.
     * @example
     * // Count the number of VerificationCodes
     * const count = await prisma.verificationCode.count({
     *   where: {
     *     // ... the filter for the VerificationCodes we want to count
     *   }
     * })
    **/
    count<T extends VerificationCodeCountArgs>(
      args?: Subset<T, VerificationCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationCodeAggregateArgs>(args: Subset<T, VerificationCodeAggregateArgs>): Prisma.PrismaPromise<GetVerificationCodeAggregateType<T>>

    /**
     * Group by VerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationCodeGroupByArgs['orderBy'] }
        : { orderBy?: VerificationCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationCode model
   */
  readonly fields: VerificationCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationCode model
   */
  interface VerificationCodeFieldRefs {
    readonly id: FieldRef<"VerificationCode", 'Int'>
    readonly userId: FieldRef<"VerificationCode", 'String'>
    readonly code: FieldRef<"VerificationCode", 'String'>
    readonly createdAt: FieldRef<"VerificationCode", 'DateTime'>
    readonly expiresAt: FieldRef<"VerificationCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationCode findUnique
   */
  export type VerificationCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode findUniqueOrThrow
   */
  export type VerificationCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode findFirst
   */
  export type VerificationCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationCodes.
     */
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode findFirstOrThrow
   */
  export type VerificationCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationCodes.
     */
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode findMany
   */
  export type VerificationCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Filter, which VerificationCodes to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode create
   */
  export type VerificationCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationCode.
     */
    data: XOR<VerificationCodeCreateInput, VerificationCodeUncheckedCreateInput>
  }

  /**
   * VerificationCode createMany
   */
  export type VerificationCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationCodes.
     */
    data: VerificationCodeCreateManyInput | VerificationCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationCode createManyAndReturn
   */
  export type VerificationCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationCodes.
     */
    data: VerificationCodeCreateManyInput | VerificationCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationCode update
   */
  export type VerificationCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationCode.
     */
    data: XOR<VerificationCodeUpdateInput, VerificationCodeUncheckedUpdateInput>
    /**
     * Choose, which VerificationCode to update.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode updateMany
   */
  export type VerificationCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationCodes.
     */
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyInput>
    /**
     * Filter which VerificationCodes to update
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to update.
     */
    limit?: number
  }

  /**
   * VerificationCode updateManyAndReturn
   */
  export type VerificationCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data used to update VerificationCodes.
     */
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyInput>
    /**
     * Filter which VerificationCodes to update
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to update.
     */
    limit?: number
  }

  /**
   * VerificationCode upsert
   */
  export type VerificationCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationCode to update in case it exists.
     */
    where: VerificationCodeWhereUniqueInput
    /**
     * In case the VerificationCode found by the `where` argument doesn't exist, create a new VerificationCode with this data.
     */
    create: XOR<VerificationCodeCreateInput, VerificationCodeUncheckedCreateInput>
    /**
     * In case the VerificationCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationCodeUpdateInput, VerificationCodeUncheckedUpdateInput>
  }

  /**
   * VerificationCode delete
   */
  export type VerificationCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Filter which VerificationCode to delete.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode deleteMany
   */
  export type VerificationCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationCodes to delete
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to delete.
     */
    limit?: number
  }

  /**
   * VerificationCode without action
   */
  export type VerificationCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
  }


  /**
   * Model MatrixRoomMember
   */

  export type AggregateMatrixRoomMember = {
    _count: MatrixRoomMemberCountAggregateOutputType | null
    _avg: MatrixRoomMemberAvgAggregateOutputType | null
    _sum: MatrixRoomMemberSumAggregateOutputType | null
    _min: MatrixRoomMemberMinAggregateOutputType | null
    _max: MatrixRoomMemberMaxAggregateOutputType | null
  }

  export type MatrixRoomMemberAvgAggregateOutputType = {
    id: number | null
  }

  export type MatrixRoomMemberSumAggregateOutputType = {
    id: number | null
  }

  export type MatrixRoomMemberMinAggregateOutputType = {
    id: number | null
    roomId: string | null
    userId: string | null
    displayName: string | null
    avatarUrl: string | null
    membership: string | null
    lastUpdated: Date | null
  }

  export type MatrixRoomMemberMaxAggregateOutputType = {
    id: number | null
    roomId: string | null
    userId: string | null
    displayName: string | null
    avatarUrl: string | null
    membership: string | null
    lastUpdated: Date | null
  }

  export type MatrixRoomMemberCountAggregateOutputType = {
    id: number
    roomId: number
    userId: number
    displayName: number
    avatarUrl: number
    membership: number
    lastUpdated: number
    _all: number
  }


  export type MatrixRoomMemberAvgAggregateInputType = {
    id?: true
  }

  export type MatrixRoomMemberSumAggregateInputType = {
    id?: true
  }

  export type MatrixRoomMemberMinAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    displayName?: true
    avatarUrl?: true
    membership?: true
    lastUpdated?: true
  }

  export type MatrixRoomMemberMaxAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    displayName?: true
    avatarUrl?: true
    membership?: true
    lastUpdated?: true
  }

  export type MatrixRoomMemberCountAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    displayName?: true
    avatarUrl?: true
    membership?: true
    lastUpdated?: true
    _all?: true
  }

  export type MatrixRoomMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrixRoomMember to aggregate.
     */
    where?: MatrixRoomMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixRoomMembers to fetch.
     */
    orderBy?: MatrixRoomMemberOrderByWithRelationInput | MatrixRoomMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatrixRoomMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixRoomMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixRoomMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatrixRoomMembers
    **/
    _count?: true | MatrixRoomMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatrixRoomMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatrixRoomMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatrixRoomMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatrixRoomMemberMaxAggregateInputType
  }

  export type GetMatrixRoomMemberAggregateType<T extends MatrixRoomMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMatrixRoomMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatrixRoomMember[P]>
      : GetScalarType<T[P], AggregateMatrixRoomMember[P]>
  }




  export type MatrixRoomMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatrixRoomMemberWhereInput
    orderBy?: MatrixRoomMemberOrderByWithAggregationInput | MatrixRoomMemberOrderByWithAggregationInput[]
    by: MatrixRoomMemberScalarFieldEnum[] | MatrixRoomMemberScalarFieldEnum
    having?: MatrixRoomMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatrixRoomMemberCountAggregateInputType | true
    _avg?: MatrixRoomMemberAvgAggregateInputType
    _sum?: MatrixRoomMemberSumAggregateInputType
    _min?: MatrixRoomMemberMinAggregateInputType
    _max?: MatrixRoomMemberMaxAggregateInputType
  }

  export type MatrixRoomMemberGroupByOutputType = {
    id: number
    roomId: string
    userId: string
    displayName: string | null
    avatarUrl: string | null
    membership: string | null
    lastUpdated: Date
    _count: MatrixRoomMemberCountAggregateOutputType | null
    _avg: MatrixRoomMemberAvgAggregateOutputType | null
    _sum: MatrixRoomMemberSumAggregateOutputType | null
    _min: MatrixRoomMemberMinAggregateOutputType | null
    _max: MatrixRoomMemberMaxAggregateOutputType | null
  }

  type GetMatrixRoomMemberGroupByPayload<T extends MatrixRoomMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatrixRoomMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatrixRoomMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatrixRoomMemberGroupByOutputType[P]>
            : GetScalarType<T[P], MatrixRoomMemberGroupByOutputType[P]>
        }
      >
    >


  export type MatrixRoomMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    membership?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["matrixRoomMember"]>

  export type MatrixRoomMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    membership?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["matrixRoomMember"]>

  export type MatrixRoomMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    membership?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["matrixRoomMember"]>

  export type MatrixRoomMemberSelectScalar = {
    id?: boolean
    roomId?: boolean
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    membership?: boolean
    lastUpdated?: boolean
  }

  export type MatrixRoomMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "userId" | "displayName" | "avatarUrl" | "membership" | "lastUpdated", ExtArgs["result"]["matrixRoomMember"]>

  export type $MatrixRoomMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatrixRoomMember"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roomId: string
      userId: string
      displayName: string | null
      avatarUrl: string | null
      membership: string | null
      lastUpdated: Date
    }, ExtArgs["result"]["matrixRoomMember"]>
    composites: {}
  }

  type MatrixRoomMemberGetPayload<S extends boolean | null | undefined | MatrixRoomMemberDefaultArgs> = $Result.GetResult<Prisma.$MatrixRoomMemberPayload, S>

  type MatrixRoomMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatrixRoomMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatrixRoomMemberCountAggregateInputType | true
    }

  export interface MatrixRoomMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatrixRoomMember'], meta: { name: 'MatrixRoomMember' } }
    /**
     * Find zero or one MatrixRoomMember that matches the filter.
     * @param {MatrixRoomMemberFindUniqueArgs} args - Arguments to find a MatrixRoomMember
     * @example
     * // Get one MatrixRoomMember
     * const matrixRoomMember = await prisma.matrixRoomMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatrixRoomMemberFindUniqueArgs>(args: SelectSubset<T, MatrixRoomMemberFindUniqueArgs<ExtArgs>>): Prisma__MatrixRoomMemberClient<$Result.GetResult<Prisma.$MatrixRoomMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatrixRoomMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatrixRoomMemberFindUniqueOrThrowArgs} args - Arguments to find a MatrixRoomMember
     * @example
     * // Get one MatrixRoomMember
     * const matrixRoomMember = await prisma.matrixRoomMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatrixRoomMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MatrixRoomMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatrixRoomMemberClient<$Result.GetResult<Prisma.$MatrixRoomMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatrixRoomMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMemberFindFirstArgs} args - Arguments to find a MatrixRoomMember
     * @example
     * // Get one MatrixRoomMember
     * const matrixRoomMember = await prisma.matrixRoomMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatrixRoomMemberFindFirstArgs>(args?: SelectSubset<T, MatrixRoomMemberFindFirstArgs<ExtArgs>>): Prisma__MatrixRoomMemberClient<$Result.GetResult<Prisma.$MatrixRoomMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatrixRoomMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMemberFindFirstOrThrowArgs} args - Arguments to find a MatrixRoomMember
     * @example
     * // Get one MatrixRoomMember
     * const matrixRoomMember = await prisma.matrixRoomMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatrixRoomMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MatrixRoomMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatrixRoomMemberClient<$Result.GetResult<Prisma.$MatrixRoomMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatrixRoomMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatrixRoomMembers
     * const matrixRoomMembers = await prisma.matrixRoomMember.findMany()
     * 
     * // Get first 10 MatrixRoomMembers
     * const matrixRoomMembers = await prisma.matrixRoomMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matrixRoomMemberWithIdOnly = await prisma.matrixRoomMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatrixRoomMemberFindManyArgs>(args?: SelectSubset<T, MatrixRoomMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixRoomMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatrixRoomMember.
     * @param {MatrixRoomMemberCreateArgs} args - Arguments to create a MatrixRoomMember.
     * @example
     * // Create one MatrixRoomMember
     * const MatrixRoomMember = await prisma.matrixRoomMember.create({
     *   data: {
     *     // ... data to create a MatrixRoomMember
     *   }
     * })
     * 
     */
    create<T extends MatrixRoomMemberCreateArgs>(args: SelectSubset<T, MatrixRoomMemberCreateArgs<ExtArgs>>): Prisma__MatrixRoomMemberClient<$Result.GetResult<Prisma.$MatrixRoomMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatrixRoomMembers.
     * @param {MatrixRoomMemberCreateManyArgs} args - Arguments to create many MatrixRoomMembers.
     * @example
     * // Create many MatrixRoomMembers
     * const matrixRoomMember = await prisma.matrixRoomMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatrixRoomMemberCreateManyArgs>(args?: SelectSubset<T, MatrixRoomMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatrixRoomMembers and returns the data saved in the database.
     * @param {MatrixRoomMemberCreateManyAndReturnArgs} args - Arguments to create many MatrixRoomMembers.
     * @example
     * // Create many MatrixRoomMembers
     * const matrixRoomMember = await prisma.matrixRoomMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatrixRoomMembers and only return the `id`
     * const matrixRoomMemberWithIdOnly = await prisma.matrixRoomMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatrixRoomMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MatrixRoomMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixRoomMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatrixRoomMember.
     * @param {MatrixRoomMemberDeleteArgs} args - Arguments to delete one MatrixRoomMember.
     * @example
     * // Delete one MatrixRoomMember
     * const MatrixRoomMember = await prisma.matrixRoomMember.delete({
     *   where: {
     *     // ... filter to delete one MatrixRoomMember
     *   }
     * })
     * 
     */
    delete<T extends MatrixRoomMemberDeleteArgs>(args: SelectSubset<T, MatrixRoomMemberDeleteArgs<ExtArgs>>): Prisma__MatrixRoomMemberClient<$Result.GetResult<Prisma.$MatrixRoomMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatrixRoomMember.
     * @param {MatrixRoomMemberUpdateArgs} args - Arguments to update one MatrixRoomMember.
     * @example
     * // Update one MatrixRoomMember
     * const matrixRoomMember = await prisma.matrixRoomMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatrixRoomMemberUpdateArgs>(args: SelectSubset<T, MatrixRoomMemberUpdateArgs<ExtArgs>>): Prisma__MatrixRoomMemberClient<$Result.GetResult<Prisma.$MatrixRoomMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatrixRoomMembers.
     * @param {MatrixRoomMemberDeleteManyArgs} args - Arguments to filter MatrixRoomMembers to delete.
     * @example
     * // Delete a few MatrixRoomMembers
     * const { count } = await prisma.matrixRoomMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatrixRoomMemberDeleteManyArgs>(args?: SelectSubset<T, MatrixRoomMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrixRoomMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatrixRoomMembers
     * const matrixRoomMember = await prisma.matrixRoomMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatrixRoomMemberUpdateManyArgs>(args: SelectSubset<T, MatrixRoomMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrixRoomMembers and returns the data updated in the database.
     * @param {MatrixRoomMemberUpdateManyAndReturnArgs} args - Arguments to update many MatrixRoomMembers.
     * @example
     * // Update many MatrixRoomMembers
     * const matrixRoomMember = await prisma.matrixRoomMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatrixRoomMembers and only return the `id`
     * const matrixRoomMemberWithIdOnly = await prisma.matrixRoomMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatrixRoomMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MatrixRoomMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixRoomMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatrixRoomMember.
     * @param {MatrixRoomMemberUpsertArgs} args - Arguments to update or create a MatrixRoomMember.
     * @example
     * // Update or create a MatrixRoomMember
     * const matrixRoomMember = await prisma.matrixRoomMember.upsert({
     *   create: {
     *     // ... data to create a MatrixRoomMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatrixRoomMember we want to update
     *   }
     * })
     */
    upsert<T extends MatrixRoomMemberUpsertArgs>(args: SelectSubset<T, MatrixRoomMemberUpsertArgs<ExtArgs>>): Prisma__MatrixRoomMemberClient<$Result.GetResult<Prisma.$MatrixRoomMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatrixRoomMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMemberCountArgs} args - Arguments to filter MatrixRoomMembers to count.
     * @example
     * // Count the number of MatrixRoomMembers
     * const count = await prisma.matrixRoomMember.count({
     *   where: {
     *     // ... the filter for the MatrixRoomMembers we want to count
     *   }
     * })
    **/
    count<T extends MatrixRoomMemberCountArgs>(
      args?: Subset<T, MatrixRoomMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatrixRoomMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatrixRoomMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatrixRoomMemberAggregateArgs>(args: Subset<T, MatrixRoomMemberAggregateArgs>): Prisma.PrismaPromise<GetMatrixRoomMemberAggregateType<T>>

    /**
     * Group by MatrixRoomMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatrixRoomMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatrixRoomMemberGroupByArgs['orderBy'] }
        : { orderBy?: MatrixRoomMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatrixRoomMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatrixRoomMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatrixRoomMember model
   */
  readonly fields: MatrixRoomMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatrixRoomMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatrixRoomMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatrixRoomMember model
   */
  interface MatrixRoomMemberFieldRefs {
    readonly id: FieldRef<"MatrixRoomMember", 'Int'>
    readonly roomId: FieldRef<"MatrixRoomMember", 'String'>
    readonly userId: FieldRef<"MatrixRoomMember", 'String'>
    readonly displayName: FieldRef<"MatrixRoomMember", 'String'>
    readonly avatarUrl: FieldRef<"MatrixRoomMember", 'String'>
    readonly membership: FieldRef<"MatrixRoomMember", 'String'>
    readonly lastUpdated: FieldRef<"MatrixRoomMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatrixRoomMember findUnique
   */
  export type MatrixRoomMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMember
     */
    select?: MatrixRoomMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMember
     */
    omit?: MatrixRoomMemberOmit<ExtArgs> | null
    /**
     * Filter, which MatrixRoomMember to fetch.
     */
    where: MatrixRoomMemberWhereUniqueInput
  }

  /**
   * MatrixRoomMember findUniqueOrThrow
   */
  export type MatrixRoomMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMember
     */
    select?: MatrixRoomMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMember
     */
    omit?: MatrixRoomMemberOmit<ExtArgs> | null
    /**
     * Filter, which MatrixRoomMember to fetch.
     */
    where: MatrixRoomMemberWhereUniqueInput
  }

  /**
   * MatrixRoomMember findFirst
   */
  export type MatrixRoomMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMember
     */
    select?: MatrixRoomMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMember
     */
    omit?: MatrixRoomMemberOmit<ExtArgs> | null
    /**
     * Filter, which MatrixRoomMember to fetch.
     */
    where?: MatrixRoomMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixRoomMembers to fetch.
     */
    orderBy?: MatrixRoomMemberOrderByWithRelationInput | MatrixRoomMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrixRoomMembers.
     */
    cursor?: MatrixRoomMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixRoomMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixRoomMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrixRoomMembers.
     */
    distinct?: MatrixRoomMemberScalarFieldEnum | MatrixRoomMemberScalarFieldEnum[]
  }

  /**
   * MatrixRoomMember findFirstOrThrow
   */
  export type MatrixRoomMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMember
     */
    select?: MatrixRoomMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMember
     */
    omit?: MatrixRoomMemberOmit<ExtArgs> | null
    /**
     * Filter, which MatrixRoomMember to fetch.
     */
    where?: MatrixRoomMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixRoomMembers to fetch.
     */
    orderBy?: MatrixRoomMemberOrderByWithRelationInput | MatrixRoomMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrixRoomMembers.
     */
    cursor?: MatrixRoomMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixRoomMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixRoomMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrixRoomMembers.
     */
    distinct?: MatrixRoomMemberScalarFieldEnum | MatrixRoomMemberScalarFieldEnum[]
  }

  /**
   * MatrixRoomMember findMany
   */
  export type MatrixRoomMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMember
     */
    select?: MatrixRoomMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMember
     */
    omit?: MatrixRoomMemberOmit<ExtArgs> | null
    /**
     * Filter, which MatrixRoomMembers to fetch.
     */
    where?: MatrixRoomMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixRoomMembers to fetch.
     */
    orderBy?: MatrixRoomMemberOrderByWithRelationInput | MatrixRoomMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatrixRoomMembers.
     */
    cursor?: MatrixRoomMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixRoomMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixRoomMembers.
     */
    skip?: number
    distinct?: MatrixRoomMemberScalarFieldEnum | MatrixRoomMemberScalarFieldEnum[]
  }

  /**
   * MatrixRoomMember create
   */
  export type MatrixRoomMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMember
     */
    select?: MatrixRoomMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMember
     */
    omit?: MatrixRoomMemberOmit<ExtArgs> | null
    /**
     * The data needed to create a MatrixRoomMember.
     */
    data: XOR<MatrixRoomMemberCreateInput, MatrixRoomMemberUncheckedCreateInput>
  }

  /**
   * MatrixRoomMember createMany
   */
  export type MatrixRoomMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatrixRoomMembers.
     */
    data: MatrixRoomMemberCreateManyInput | MatrixRoomMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrixRoomMember createManyAndReturn
   */
  export type MatrixRoomMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMember
     */
    select?: MatrixRoomMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMember
     */
    omit?: MatrixRoomMemberOmit<ExtArgs> | null
    /**
     * The data used to create many MatrixRoomMembers.
     */
    data: MatrixRoomMemberCreateManyInput | MatrixRoomMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrixRoomMember update
   */
  export type MatrixRoomMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMember
     */
    select?: MatrixRoomMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMember
     */
    omit?: MatrixRoomMemberOmit<ExtArgs> | null
    /**
     * The data needed to update a MatrixRoomMember.
     */
    data: XOR<MatrixRoomMemberUpdateInput, MatrixRoomMemberUncheckedUpdateInput>
    /**
     * Choose, which MatrixRoomMember to update.
     */
    where: MatrixRoomMemberWhereUniqueInput
  }

  /**
   * MatrixRoomMember updateMany
   */
  export type MatrixRoomMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatrixRoomMembers.
     */
    data: XOR<MatrixRoomMemberUpdateManyMutationInput, MatrixRoomMemberUncheckedUpdateManyInput>
    /**
     * Filter which MatrixRoomMembers to update
     */
    where?: MatrixRoomMemberWhereInput
    /**
     * Limit how many MatrixRoomMembers to update.
     */
    limit?: number
  }

  /**
   * MatrixRoomMember updateManyAndReturn
   */
  export type MatrixRoomMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMember
     */
    select?: MatrixRoomMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMember
     */
    omit?: MatrixRoomMemberOmit<ExtArgs> | null
    /**
     * The data used to update MatrixRoomMembers.
     */
    data: XOR<MatrixRoomMemberUpdateManyMutationInput, MatrixRoomMemberUncheckedUpdateManyInput>
    /**
     * Filter which MatrixRoomMembers to update
     */
    where?: MatrixRoomMemberWhereInput
    /**
     * Limit how many MatrixRoomMembers to update.
     */
    limit?: number
  }

  /**
   * MatrixRoomMember upsert
   */
  export type MatrixRoomMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMember
     */
    select?: MatrixRoomMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMember
     */
    omit?: MatrixRoomMemberOmit<ExtArgs> | null
    /**
     * The filter to search for the MatrixRoomMember to update in case it exists.
     */
    where: MatrixRoomMemberWhereUniqueInput
    /**
     * In case the MatrixRoomMember found by the `where` argument doesn't exist, create a new MatrixRoomMember with this data.
     */
    create: XOR<MatrixRoomMemberCreateInput, MatrixRoomMemberUncheckedCreateInput>
    /**
     * In case the MatrixRoomMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatrixRoomMemberUpdateInput, MatrixRoomMemberUncheckedUpdateInput>
  }

  /**
   * MatrixRoomMember delete
   */
  export type MatrixRoomMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMember
     */
    select?: MatrixRoomMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMember
     */
    omit?: MatrixRoomMemberOmit<ExtArgs> | null
    /**
     * Filter which MatrixRoomMember to delete.
     */
    where: MatrixRoomMemberWhereUniqueInput
  }

  /**
   * MatrixRoomMember deleteMany
   */
  export type MatrixRoomMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrixRoomMembers to delete
     */
    where?: MatrixRoomMemberWhereInput
    /**
     * Limit how many MatrixRoomMembers to delete.
     */
    limit?: number
  }

  /**
   * MatrixRoomMember without action
   */
  export type MatrixRoomMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMember
     */
    select?: MatrixRoomMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMember
     */
    omit?: MatrixRoomMemberOmit<ExtArgs> | null
  }


  /**
   * Model UserNote
   */

  export type AggregateUserNote = {
    _count: UserNoteCountAggregateOutputType | null
    _avg: UserNoteAvgAggregateOutputType | null
    _sum: UserNoteSumAggregateOutputType | null
    _min: UserNoteMinAggregateOutputType | null
    _max: UserNoteMaxAggregateOutputType | null
  }

  export type UserNoteAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserNoteSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type UserNoteMinAggregateOutputType = {
    id: number | null
    userId: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    lastEditedBy: string | null
  }

  export type UserNoteMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    lastEditedBy: string | null
  }

  export type UserNoteCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    createdAt: number
    updatedAt: number
    createdBy: number
    lastEditedBy: number
    _all: number
  }


  export type UserNoteAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserNoteSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type UserNoteMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    lastEditedBy?: true
  }

  export type UserNoteMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    lastEditedBy?: true
  }

  export type UserNoteCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    lastEditedBy?: true
    _all?: true
  }

  export type UserNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNote to aggregate.
     */
    where?: UserNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotes to fetch.
     */
    orderBy?: UserNoteOrderByWithRelationInput | UserNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNotes
    **/
    _count?: true | UserNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNoteMaxAggregateInputType
  }

  export type GetUserNoteAggregateType<T extends UserNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNote[P]>
      : GetScalarType<T[P], AggregateUserNote[P]>
  }




  export type UserNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNoteWhereInput
    orderBy?: UserNoteOrderByWithAggregationInput | UserNoteOrderByWithAggregationInput[]
    by: UserNoteScalarFieldEnum[] | UserNoteScalarFieldEnum
    having?: UserNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNoteCountAggregateInputType | true
    _avg?: UserNoteAvgAggregateInputType
    _sum?: UserNoteSumAggregateInputType
    _min?: UserNoteMinAggregateInputType
    _max?: UserNoteMaxAggregateInputType
  }

  export type UserNoteGroupByOutputType = {
    id: number
    userId: number
    content: string
    createdAt: Date
    updatedAt: Date
    createdBy: string
    lastEditedBy: string | null
    _count: UserNoteCountAggregateOutputType | null
    _avg: UserNoteAvgAggregateOutputType | null
    _sum: UserNoteSumAggregateOutputType | null
    _min: UserNoteMinAggregateOutputType | null
    _max: UserNoteMaxAggregateOutputType | null
  }

  type GetUserNoteGroupByPayload<T extends UserNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNoteGroupByOutputType[P]>
            : GetScalarType<T[P], UserNoteGroupByOutputType[P]>
        }
      >
    >


  export type UserNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    lastEditedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNote"]>

  export type UserNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    lastEditedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNote"]>

  export type UserNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    lastEditedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNote"]>

  export type UserNoteSelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    lastEditedBy?: boolean
  }

  export type UserNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "content" | "createdAt" | "updatedAt" | "createdBy" | "lastEditedBy", ExtArgs["result"]["userNote"]>
  export type UserNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserNote"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      content: string
      createdAt: Date
      updatedAt: Date
      createdBy: string
      lastEditedBy: string | null
    }, ExtArgs["result"]["userNote"]>
    composites: {}
  }

  type UserNoteGetPayload<S extends boolean | null | undefined | UserNoteDefaultArgs> = $Result.GetResult<Prisma.$UserNotePayload, S>

  type UserNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserNoteCountAggregateInputType | true
    }

  export interface UserNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserNote'], meta: { name: 'UserNote' } }
    /**
     * Find zero or one UserNote that matches the filter.
     * @param {UserNoteFindUniqueArgs} args - Arguments to find a UserNote
     * @example
     * // Get one UserNote
     * const userNote = await prisma.userNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserNoteFindUniqueArgs>(args: SelectSubset<T, UserNoteFindUniqueArgs<ExtArgs>>): Prisma__UserNoteClient<$Result.GetResult<Prisma.$UserNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserNoteFindUniqueOrThrowArgs} args - Arguments to find a UserNote
     * @example
     * // Get one UserNote
     * const userNote = await prisma.userNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, UserNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserNoteClient<$Result.GetResult<Prisma.$UserNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNoteFindFirstArgs} args - Arguments to find a UserNote
     * @example
     * // Get one UserNote
     * const userNote = await prisma.userNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserNoteFindFirstArgs>(args?: SelectSubset<T, UserNoteFindFirstArgs<ExtArgs>>): Prisma__UserNoteClient<$Result.GetResult<Prisma.$UserNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNoteFindFirstOrThrowArgs} args - Arguments to find a UserNote
     * @example
     * // Get one UserNote
     * const userNote = await prisma.userNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, UserNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserNoteClient<$Result.GetResult<Prisma.$UserNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNotes
     * const userNotes = await prisma.userNote.findMany()
     * 
     * // Get first 10 UserNotes
     * const userNotes = await prisma.userNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNoteWithIdOnly = await prisma.userNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserNoteFindManyArgs>(args?: SelectSubset<T, UserNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserNote.
     * @param {UserNoteCreateArgs} args - Arguments to create a UserNote.
     * @example
     * // Create one UserNote
     * const UserNote = await prisma.userNote.create({
     *   data: {
     *     // ... data to create a UserNote
     *   }
     * })
     * 
     */
    create<T extends UserNoteCreateArgs>(args: SelectSubset<T, UserNoteCreateArgs<ExtArgs>>): Prisma__UserNoteClient<$Result.GetResult<Prisma.$UserNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserNotes.
     * @param {UserNoteCreateManyArgs} args - Arguments to create many UserNotes.
     * @example
     * // Create many UserNotes
     * const userNote = await prisma.userNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserNoteCreateManyArgs>(args?: SelectSubset<T, UserNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserNotes and returns the data saved in the database.
     * @param {UserNoteCreateManyAndReturnArgs} args - Arguments to create many UserNotes.
     * @example
     * // Create many UserNotes
     * const userNote = await prisma.userNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserNotes and only return the `id`
     * const userNoteWithIdOnly = await prisma.userNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, UserNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserNote.
     * @param {UserNoteDeleteArgs} args - Arguments to delete one UserNote.
     * @example
     * // Delete one UserNote
     * const UserNote = await prisma.userNote.delete({
     *   where: {
     *     // ... filter to delete one UserNote
     *   }
     * })
     * 
     */
    delete<T extends UserNoteDeleteArgs>(args: SelectSubset<T, UserNoteDeleteArgs<ExtArgs>>): Prisma__UserNoteClient<$Result.GetResult<Prisma.$UserNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserNote.
     * @param {UserNoteUpdateArgs} args - Arguments to update one UserNote.
     * @example
     * // Update one UserNote
     * const userNote = await prisma.userNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserNoteUpdateArgs>(args: SelectSubset<T, UserNoteUpdateArgs<ExtArgs>>): Prisma__UserNoteClient<$Result.GetResult<Prisma.$UserNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserNotes.
     * @param {UserNoteDeleteManyArgs} args - Arguments to filter UserNotes to delete.
     * @example
     * // Delete a few UserNotes
     * const { count } = await prisma.userNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserNoteDeleteManyArgs>(args?: SelectSubset<T, UserNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNotes
     * const userNote = await prisma.userNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserNoteUpdateManyArgs>(args: SelectSubset<T, UserNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotes and returns the data updated in the database.
     * @param {UserNoteUpdateManyAndReturnArgs} args - Arguments to update many UserNotes.
     * @example
     * // Update many UserNotes
     * const userNote = await prisma.userNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserNotes and only return the `id`
     * const userNoteWithIdOnly = await prisma.userNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, UserNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserNote.
     * @param {UserNoteUpsertArgs} args - Arguments to update or create a UserNote.
     * @example
     * // Update or create a UserNote
     * const userNote = await prisma.userNote.upsert({
     *   create: {
     *     // ... data to create a UserNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNote we want to update
     *   }
     * })
     */
    upsert<T extends UserNoteUpsertArgs>(args: SelectSubset<T, UserNoteUpsertArgs<ExtArgs>>): Prisma__UserNoteClient<$Result.GetResult<Prisma.$UserNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNoteCountArgs} args - Arguments to filter UserNotes to count.
     * @example
     * // Count the number of UserNotes
     * const count = await prisma.userNote.count({
     *   where: {
     *     // ... the filter for the UserNotes we want to count
     *   }
     * })
    **/
    count<T extends UserNoteCountArgs>(
      args?: Subset<T, UserNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNoteAggregateArgs>(args: Subset<T, UserNoteAggregateArgs>): Prisma.PrismaPromise<GetUserNoteAggregateType<T>>

    /**
     * Group by UserNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNoteGroupByArgs['orderBy'] }
        : { orderBy?: UserNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserNote model
   */
  readonly fields: UserNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserNote model
   */
  interface UserNoteFieldRefs {
    readonly id: FieldRef<"UserNote", 'Int'>
    readonly userId: FieldRef<"UserNote", 'Int'>
    readonly content: FieldRef<"UserNote", 'String'>
    readonly createdAt: FieldRef<"UserNote", 'DateTime'>
    readonly updatedAt: FieldRef<"UserNote", 'DateTime'>
    readonly createdBy: FieldRef<"UserNote", 'String'>
    readonly lastEditedBy: FieldRef<"UserNote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserNote findUnique
   */
  export type UserNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteInclude<ExtArgs> | null
    /**
     * Filter, which UserNote to fetch.
     */
    where: UserNoteWhereUniqueInput
  }

  /**
   * UserNote findUniqueOrThrow
   */
  export type UserNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteInclude<ExtArgs> | null
    /**
     * Filter, which UserNote to fetch.
     */
    where: UserNoteWhereUniqueInput
  }

  /**
   * UserNote findFirst
   */
  export type UserNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteInclude<ExtArgs> | null
    /**
     * Filter, which UserNote to fetch.
     */
    where?: UserNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotes to fetch.
     */
    orderBy?: UserNoteOrderByWithRelationInput | UserNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotes.
     */
    cursor?: UserNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotes.
     */
    distinct?: UserNoteScalarFieldEnum | UserNoteScalarFieldEnum[]
  }

  /**
   * UserNote findFirstOrThrow
   */
  export type UserNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteInclude<ExtArgs> | null
    /**
     * Filter, which UserNote to fetch.
     */
    where?: UserNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotes to fetch.
     */
    orderBy?: UserNoteOrderByWithRelationInput | UserNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotes.
     */
    cursor?: UserNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotes.
     */
    distinct?: UserNoteScalarFieldEnum | UserNoteScalarFieldEnum[]
  }

  /**
   * UserNote findMany
   */
  export type UserNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteInclude<ExtArgs> | null
    /**
     * Filter, which UserNotes to fetch.
     */
    where?: UserNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotes to fetch.
     */
    orderBy?: UserNoteOrderByWithRelationInput | UserNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNotes.
     */
    cursor?: UserNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotes.
     */
    skip?: number
    distinct?: UserNoteScalarFieldEnum | UserNoteScalarFieldEnum[]
  }

  /**
   * UserNote create
   */
  export type UserNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a UserNote.
     */
    data: XOR<UserNoteCreateInput, UserNoteUncheckedCreateInput>
  }

  /**
   * UserNote createMany
   */
  export type UserNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserNotes.
     */
    data: UserNoteCreateManyInput | UserNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserNote createManyAndReturn
   */
  export type UserNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * The data used to create many UserNotes.
     */
    data: UserNoteCreateManyInput | UserNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserNote update
   */
  export type UserNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a UserNote.
     */
    data: XOR<UserNoteUpdateInput, UserNoteUncheckedUpdateInput>
    /**
     * Choose, which UserNote to update.
     */
    where: UserNoteWhereUniqueInput
  }

  /**
   * UserNote updateMany
   */
  export type UserNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserNotes.
     */
    data: XOR<UserNoteUpdateManyMutationInput, UserNoteUncheckedUpdateManyInput>
    /**
     * Filter which UserNotes to update
     */
    where?: UserNoteWhereInput
    /**
     * Limit how many UserNotes to update.
     */
    limit?: number
  }

  /**
   * UserNote updateManyAndReturn
   */
  export type UserNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * The data used to update UserNotes.
     */
    data: XOR<UserNoteUpdateManyMutationInput, UserNoteUncheckedUpdateManyInput>
    /**
     * Filter which UserNotes to update
     */
    where?: UserNoteWhereInput
    /**
     * Limit how many UserNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserNote upsert
   */
  export type UserNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the UserNote to update in case it exists.
     */
    where: UserNoteWhereUniqueInput
    /**
     * In case the UserNote found by the `where` argument doesn't exist, create a new UserNote with this data.
     */
    create: XOR<UserNoteCreateInput, UserNoteUncheckedCreateInput>
    /**
     * In case the UserNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserNoteUpdateInput, UserNoteUncheckedUpdateInput>
  }

  /**
   * UserNote delete
   */
  export type UserNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteInclude<ExtArgs> | null
    /**
     * Filter which UserNote to delete.
     */
    where: UserNoteWhereUniqueInput
  }

  /**
   * UserNote deleteMany
   */
  export type UserNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotes to delete
     */
    where?: UserNoteWhereInput
    /**
     * Limit how many UserNotes to delete.
     */
    limit?: number
  }

  /**
   * UserNote without action
   */
  export type UserNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNote
     */
    select?: UserNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNote
     */
    omit?: UserNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNoteInclude<ExtArgs> | null
  }


  /**
   * Model Invite
   */

  export type AggregateInvite = {
    _count: InviteCountAggregateOutputType | null
    _avg: InviteAvgAggregateOutputType | null
    _sum: InviteSumAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  export type InviteAvgAggregateOutputType = {
    id: number | null
  }

  export type InviteSumAggregateOutputType = {
    id: number | null
  }

  export type InviteMinAggregateOutputType = {
    id: number | null
    token: string | null
    label: string | null
    email: string | null
    name: string | null
    groups: string | null
    createdAt: Date | null
    expiresAt: Date | null
    createdBy: string | null
    isUsed: boolean | null
    usedBy: string | null
    usedAt: Date | null
  }

  export type InviteMaxAggregateOutputType = {
    id: number | null
    token: string | null
    label: string | null
    email: string | null
    name: string | null
    groups: string | null
    createdAt: Date | null
    expiresAt: Date | null
    createdBy: string | null
    isUsed: boolean | null
    usedBy: string | null
    usedAt: Date | null
  }

  export type InviteCountAggregateOutputType = {
    id: number
    token: number
    label: number
    email: number
    name: number
    groups: number
    createdAt: number
    expiresAt: number
    createdBy: number
    isUsed: number
    usedBy: number
    usedAt: number
    _all: number
  }


  export type InviteAvgAggregateInputType = {
    id?: true
  }

  export type InviteSumAggregateInputType = {
    id?: true
  }

  export type InviteMinAggregateInputType = {
    id?: true
    token?: true
    label?: true
    email?: true
    name?: true
    groups?: true
    createdAt?: true
    expiresAt?: true
    createdBy?: true
    isUsed?: true
    usedBy?: true
    usedAt?: true
  }

  export type InviteMaxAggregateInputType = {
    id?: true
    token?: true
    label?: true
    email?: true
    name?: true
    groups?: true
    createdAt?: true
    expiresAt?: true
    createdBy?: true
    isUsed?: true
    usedBy?: true
    usedAt?: true
  }

  export type InviteCountAggregateInputType = {
    id?: true
    token?: true
    label?: true
    email?: true
    name?: true
    groups?: true
    createdAt?: true
    expiresAt?: true
    createdBy?: true
    isUsed?: true
    usedBy?: true
    usedAt?: true
    _all?: true
  }

  export type InviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invite to aggregate.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invites
    **/
    _count?: true | InviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InviteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InviteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InviteMaxAggregateInputType
  }

  export type GetInviteAggregateType<T extends InviteAggregateArgs> = {
        [P in keyof T & keyof AggregateInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvite[P]>
      : GetScalarType<T[P], AggregateInvite[P]>
  }




  export type InviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithAggregationInput | InviteOrderByWithAggregationInput[]
    by: InviteScalarFieldEnum[] | InviteScalarFieldEnum
    having?: InviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InviteCountAggregateInputType | true
    _avg?: InviteAvgAggregateInputType
    _sum?: InviteSumAggregateInputType
    _min?: InviteMinAggregateInputType
    _max?: InviteMaxAggregateInputType
  }

  export type InviteGroupByOutputType = {
    id: number
    token: string
    label: string | null
    email: string | null
    name: string | null
    groups: string | null
    createdAt: Date
    expiresAt: Date
    createdBy: string | null
    isUsed: boolean
    usedBy: string | null
    usedAt: Date | null
    _count: InviteCountAggregateOutputType | null
    _avg: InviteAvgAggregateOutputType | null
    _sum: InviteSumAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  type GetInviteGroupByPayload<T extends InviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InviteGroupByOutputType[P]>
            : GetScalarType<T[P], InviteGroupByOutputType[P]>
        }
      >
    >


  export type InviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    label?: boolean
    email?: boolean
    name?: boolean
    groups?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    createdBy?: boolean
    isUsed?: boolean
    usedBy?: boolean
    usedAt?: boolean
  }, ExtArgs["result"]["invite"]>

  export type InviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    label?: boolean
    email?: boolean
    name?: boolean
    groups?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    createdBy?: boolean
    isUsed?: boolean
    usedBy?: boolean
    usedAt?: boolean
  }, ExtArgs["result"]["invite"]>

  export type InviteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    label?: boolean
    email?: boolean
    name?: boolean
    groups?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    createdBy?: boolean
    isUsed?: boolean
    usedBy?: boolean
    usedAt?: boolean
  }, ExtArgs["result"]["invite"]>

  export type InviteSelectScalar = {
    id?: boolean
    token?: boolean
    label?: boolean
    email?: boolean
    name?: boolean
    groups?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    createdBy?: boolean
    isUsed?: boolean
    usedBy?: boolean
    usedAt?: boolean
  }

  export type InviteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "label" | "email" | "name" | "groups" | "createdAt" | "expiresAt" | "createdBy" | "isUsed" | "usedBy" | "usedAt", ExtArgs["result"]["invite"]>

  export type $InvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invite"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      label: string | null
      email: string | null
      name: string | null
      groups: string | null
      createdAt: Date
      expiresAt: Date
      createdBy: string | null
      isUsed: boolean
      usedBy: string | null
      usedAt: Date | null
    }, ExtArgs["result"]["invite"]>
    composites: {}
  }

  type InviteGetPayload<S extends boolean | null | undefined | InviteDefaultArgs> = $Result.GetResult<Prisma.$InvitePayload, S>

  type InviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InviteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InviteCountAggregateInputType | true
    }

  export interface InviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invite'], meta: { name: 'Invite' } }
    /**
     * Find zero or one Invite that matches the filter.
     * @param {InviteFindUniqueArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InviteFindUniqueArgs>(args: SelectSubset<T, InviteFindUniqueArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InviteFindUniqueOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InviteFindUniqueOrThrowArgs>(args: SelectSubset<T, InviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindFirstArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InviteFindFirstArgs>(args?: SelectSubset<T, InviteFindFirstArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindFirstOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InviteFindFirstOrThrowArgs>(args?: SelectSubset<T, InviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invites
     * const invites = await prisma.invite.findMany()
     * 
     * // Get first 10 Invites
     * const invites = await prisma.invite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inviteWithIdOnly = await prisma.invite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InviteFindManyArgs>(args?: SelectSubset<T, InviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invite.
     * @param {InviteCreateArgs} args - Arguments to create a Invite.
     * @example
     * // Create one Invite
     * const Invite = await prisma.invite.create({
     *   data: {
     *     // ... data to create a Invite
     *   }
     * })
     * 
     */
    create<T extends InviteCreateArgs>(args: SelectSubset<T, InviteCreateArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invites.
     * @param {InviteCreateManyArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InviteCreateManyArgs>(args?: SelectSubset<T, InviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invites and returns the data saved in the database.
     * @param {InviteCreateManyAndReturnArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invites and only return the `id`
     * const inviteWithIdOnly = await prisma.invite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InviteCreateManyAndReturnArgs>(args?: SelectSubset<T, InviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invite.
     * @param {InviteDeleteArgs} args - Arguments to delete one Invite.
     * @example
     * // Delete one Invite
     * const Invite = await prisma.invite.delete({
     *   where: {
     *     // ... filter to delete one Invite
     *   }
     * })
     * 
     */
    delete<T extends InviteDeleteArgs>(args: SelectSubset<T, InviteDeleteArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invite.
     * @param {InviteUpdateArgs} args - Arguments to update one Invite.
     * @example
     * // Update one Invite
     * const invite = await prisma.invite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InviteUpdateArgs>(args: SelectSubset<T, InviteUpdateArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invites.
     * @param {InviteDeleteManyArgs} args - Arguments to filter Invites to delete.
     * @example
     * // Delete a few Invites
     * const { count } = await prisma.invite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InviteDeleteManyArgs>(args?: SelectSubset<T, InviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invites
     * const invite = await prisma.invite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InviteUpdateManyArgs>(args: SelectSubset<T, InviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invites and returns the data updated in the database.
     * @param {InviteUpdateManyAndReturnArgs} args - Arguments to update many Invites.
     * @example
     * // Update many Invites
     * const invite = await prisma.invite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invites and only return the `id`
     * const inviteWithIdOnly = await prisma.invite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InviteUpdateManyAndReturnArgs>(args: SelectSubset<T, InviteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invite.
     * @param {InviteUpsertArgs} args - Arguments to update or create a Invite.
     * @example
     * // Update or create a Invite
     * const invite = await prisma.invite.upsert({
     *   create: {
     *     // ... data to create a Invite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invite we want to update
     *   }
     * })
     */
    upsert<T extends InviteUpsertArgs>(args: SelectSubset<T, InviteUpsertArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCountArgs} args - Arguments to filter Invites to count.
     * @example
     * // Count the number of Invites
     * const count = await prisma.invite.count({
     *   where: {
     *     // ... the filter for the Invites we want to count
     *   }
     * })
    **/
    count<T extends InviteCountArgs>(
      args?: Subset<T, InviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InviteAggregateArgs>(args: Subset<T, InviteAggregateArgs>): Prisma.PrismaPromise<GetInviteAggregateType<T>>

    /**
     * Group by Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InviteGroupByArgs['orderBy'] }
        : { orderBy?: InviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invite model
   */
  readonly fields: InviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invite model
   */
  interface InviteFieldRefs {
    readonly id: FieldRef<"Invite", 'Int'>
    readonly token: FieldRef<"Invite", 'String'>
    readonly label: FieldRef<"Invite", 'String'>
    readonly email: FieldRef<"Invite", 'String'>
    readonly name: FieldRef<"Invite", 'String'>
    readonly groups: FieldRef<"Invite", 'String'>
    readonly createdAt: FieldRef<"Invite", 'DateTime'>
    readonly expiresAt: FieldRef<"Invite", 'DateTime'>
    readonly createdBy: FieldRef<"Invite", 'String'>
    readonly isUsed: FieldRef<"Invite", 'Boolean'>
    readonly usedBy: FieldRef<"Invite", 'String'>
    readonly usedAt: FieldRef<"Invite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invite findUnique
   */
  export type InviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite findUniqueOrThrow
   */
  export type InviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite findFirst
   */
  export type InviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite findFirstOrThrow
   */
  export type InviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite findMany
   */
  export type InviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Filter, which Invites to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite create
   */
  export type InviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * The data needed to create a Invite.
     */
    data: XOR<InviteCreateInput, InviteUncheckedCreateInput>
  }

  /**
   * Invite createMany
   */
  export type InviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invites.
     */
    data: InviteCreateManyInput | InviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invite createManyAndReturn
   */
  export type InviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * The data used to create many Invites.
     */
    data: InviteCreateManyInput | InviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invite update
   */
  export type InviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * The data needed to update a Invite.
     */
    data: XOR<InviteUpdateInput, InviteUncheckedUpdateInput>
    /**
     * Choose, which Invite to update.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite updateMany
   */
  export type InviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invites.
     */
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyInput>
    /**
     * Filter which Invites to update
     */
    where?: InviteWhereInput
    /**
     * Limit how many Invites to update.
     */
    limit?: number
  }

  /**
   * Invite updateManyAndReturn
   */
  export type InviteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * The data used to update Invites.
     */
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyInput>
    /**
     * Filter which Invites to update
     */
    where?: InviteWhereInput
    /**
     * Limit how many Invites to update.
     */
    limit?: number
  }

  /**
   * Invite upsert
   */
  export type InviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * The filter to search for the Invite to update in case it exists.
     */
    where: InviteWhereUniqueInput
    /**
     * In case the Invite found by the `where` argument doesn't exist, create a new Invite with this data.
     */
    create: XOR<InviteCreateInput, InviteUncheckedCreateInput>
    /**
     * In case the Invite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InviteUpdateInput, InviteUncheckedUpdateInput>
  }

  /**
   * Invite delete
   */
  export type InviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
    /**
     * Filter which Invite to delete.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite deleteMany
   */
  export type InviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invites to delete
     */
    where?: InviteWhereInput
    /**
     * Limit how many Invites to delete.
     */
    limit?: number
  }

  /**
   * Invite without action
   */
  export type InviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invite
     */
    omit?: InviteOmit<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    id: number | null
  }

  export type GroupSumAggregateOutputType = {
    id: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    authentikGroupId: string | null
  }

  export type GroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    authentikGroupId: string | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    authentikGroupId: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    id?: true
  }

  export type GroupSumAggregateInputType = {
    id?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    authentikGroupId?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    authentikGroupId?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    authentikGroupId?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: number
    name: string
    description: string | null
    authentikGroupId: string | null
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    authentikGroupId?: boolean
    users?: boolean | Group$usersArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    authentikGroupId?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    authentikGroupId?: boolean
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    authentikGroupId?: boolean
  }

  export type GroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "authentikGroupId", ExtArgs["result"]["group"]>
  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Group$usersArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      users: Prisma.$UserGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      authentikGroupId: string | null
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {GroupUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Group$usersArgs<ExtArgs> = {}>(args?: Subset<T, Group$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'Int'>
    readonly name: FieldRef<"Group", 'String'>
    readonly description: FieldRef<"Group", 'String'>
    readonly authentikGroupId: FieldRef<"Group", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group updateManyAndReturn
   */
  export type GroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to update.
     */
    limit?: number
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
    /**
     * Limit how many Groups to delete.
     */
    limit?: number
  }

  /**
   * Group.users
   */
  export type Group$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    where?: UserGroupWhereInput
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    cursor?: UserGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Group
     */
    omit?: GroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model UserGroup
   */

  export type AggregateUserGroup = {
    _count: UserGroupCountAggregateOutputType | null
    _avg: UserGroupAvgAggregateOutputType | null
    _sum: UserGroupSumAggregateOutputType | null
    _min: UserGroupMinAggregateOutputType | null
    _max: UserGroupMaxAggregateOutputType | null
  }

  export type UserGroupAvgAggregateOutputType = {
    userId: number | null
    groupId: number | null
  }

  export type UserGroupSumAggregateOutputType = {
    userId: number | null
    groupId: number | null
  }

  export type UserGroupMinAggregateOutputType = {
    userId: number | null
    groupId: number | null
  }

  export type UserGroupMaxAggregateOutputType = {
    userId: number | null
    groupId: number | null
  }

  export type UserGroupCountAggregateOutputType = {
    userId: number
    groupId: number
    _all: number
  }


  export type UserGroupAvgAggregateInputType = {
    userId?: true
    groupId?: true
  }

  export type UserGroupSumAggregateInputType = {
    userId?: true
    groupId?: true
  }

  export type UserGroupMinAggregateInputType = {
    userId?: true
    groupId?: true
  }

  export type UserGroupMaxAggregateInputType = {
    userId?: true
    groupId?: true
  }

  export type UserGroupCountAggregateInputType = {
    userId?: true
    groupId?: true
    _all?: true
  }

  export type UserGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGroup to aggregate.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGroups
    **/
    _count?: true | UserGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGroupMaxAggregateInputType
  }

  export type GetUserGroupAggregateType<T extends UserGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGroup[P]>
      : GetScalarType<T[P], AggregateUserGroup[P]>
  }




  export type UserGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGroupWhereInput
    orderBy?: UserGroupOrderByWithAggregationInput | UserGroupOrderByWithAggregationInput[]
    by: UserGroupScalarFieldEnum[] | UserGroupScalarFieldEnum
    having?: UserGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGroupCountAggregateInputType | true
    _avg?: UserGroupAvgAggregateInputType
    _sum?: UserGroupSumAggregateInputType
    _min?: UserGroupMinAggregateInputType
    _max?: UserGroupMaxAggregateInputType
  }

  export type UserGroupGroupByOutputType = {
    userId: number
    groupId: number
    _count: UserGroupCountAggregateOutputType | null
    _avg: UserGroupAvgAggregateOutputType | null
    _sum: UserGroupSumAggregateOutputType | null
    _min: UserGroupMinAggregateOutputType | null
    _max: UserGroupMaxAggregateOutputType | null
  }

  type GetUserGroupGroupByPayload<T extends UserGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupGroupByOutputType[P]>
        }
      >
    >


  export type UserGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    groupId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroup"]>

  export type UserGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    groupId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroup"]>

  export type UserGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    groupId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGroup"]>

  export type UserGroupSelectScalar = {
    userId?: boolean
    groupId?: boolean
  }

  export type UserGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "groupId", ExtArgs["result"]["userGroup"]>
  export type UserGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type UserGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }
  export type UserGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    group?: boolean | GroupDefaultArgs<ExtArgs>
  }

  export type $UserGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserGroup"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      group: Prisma.$GroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      groupId: number
    }, ExtArgs["result"]["userGroup"]>
    composites: {}
  }

  type UserGroupGetPayload<S extends boolean | null | undefined | UserGroupDefaultArgs> = $Result.GetResult<Prisma.$UserGroupPayload, S>

  type UserGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserGroupCountAggregateInputType | true
    }

  export interface UserGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserGroup'], meta: { name: 'UserGroup' } }
    /**
     * Find zero or one UserGroup that matches the filter.
     * @param {UserGroupFindUniqueArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserGroupFindUniqueArgs>(args: SelectSubset<T, UserGroupFindUniqueArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserGroupFindUniqueOrThrowArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, UserGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindFirstArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserGroupFindFirstArgs>(args?: SelectSubset<T, UserGroupFindFirstArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindFirstOrThrowArgs} args - Arguments to find a UserGroup
     * @example
     * // Get one UserGroup
     * const userGroup = await prisma.userGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, UserGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGroups
     * const userGroups = await prisma.userGroup.findMany()
     * 
     * // Get first 10 UserGroups
     * const userGroups = await prisma.userGroup.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userGroupWithUserIdOnly = await prisma.userGroup.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserGroupFindManyArgs>(args?: SelectSubset<T, UserGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserGroup.
     * @param {UserGroupCreateArgs} args - Arguments to create a UserGroup.
     * @example
     * // Create one UserGroup
     * const UserGroup = await prisma.userGroup.create({
     *   data: {
     *     // ... data to create a UserGroup
     *   }
     * })
     * 
     */
    create<T extends UserGroupCreateArgs>(args: SelectSubset<T, UserGroupCreateArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserGroups.
     * @param {UserGroupCreateManyArgs} args - Arguments to create many UserGroups.
     * @example
     * // Create many UserGroups
     * const userGroup = await prisma.userGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserGroupCreateManyArgs>(args?: SelectSubset<T, UserGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserGroups and returns the data saved in the database.
     * @param {UserGroupCreateManyAndReturnArgs} args - Arguments to create many UserGroups.
     * @example
     * // Create many UserGroups
     * const userGroup = await prisma.userGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserGroups and only return the `userId`
     * const userGroupWithUserIdOnly = await prisma.userGroup.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, UserGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserGroup.
     * @param {UserGroupDeleteArgs} args - Arguments to delete one UserGroup.
     * @example
     * // Delete one UserGroup
     * const UserGroup = await prisma.userGroup.delete({
     *   where: {
     *     // ... filter to delete one UserGroup
     *   }
     * })
     * 
     */
    delete<T extends UserGroupDeleteArgs>(args: SelectSubset<T, UserGroupDeleteArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserGroup.
     * @param {UserGroupUpdateArgs} args - Arguments to update one UserGroup.
     * @example
     * // Update one UserGroup
     * const userGroup = await prisma.userGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserGroupUpdateArgs>(args: SelectSubset<T, UserGroupUpdateArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserGroups.
     * @param {UserGroupDeleteManyArgs} args - Arguments to filter UserGroups to delete.
     * @example
     * // Delete a few UserGroups
     * const { count } = await prisma.userGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserGroupDeleteManyArgs>(args?: SelectSubset<T, UserGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGroups
     * const userGroup = await prisma.userGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserGroupUpdateManyArgs>(args: SelectSubset<T, UserGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGroups and returns the data updated in the database.
     * @param {UserGroupUpdateManyAndReturnArgs} args - Arguments to update many UserGroups.
     * @example
     * // Update many UserGroups
     * const userGroup = await prisma.userGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserGroups and only return the `userId`
     * const userGroupWithUserIdOnly = await prisma.userGroup.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, UserGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserGroup.
     * @param {UserGroupUpsertArgs} args - Arguments to update or create a UserGroup.
     * @example
     * // Update or create a UserGroup
     * const userGroup = await prisma.userGroup.upsert({
     *   create: {
     *     // ... data to create a UserGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGroup we want to update
     *   }
     * })
     */
    upsert<T extends UserGroupUpsertArgs>(args: SelectSubset<T, UserGroupUpsertArgs<ExtArgs>>): Prisma__UserGroupClient<$Result.GetResult<Prisma.$UserGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupCountArgs} args - Arguments to filter UserGroups to count.
     * @example
     * // Count the number of UserGroups
     * const count = await prisma.userGroup.count({
     *   where: {
     *     // ... the filter for the UserGroups we want to count
     *   }
     * })
    **/
    count<T extends UserGroupCountArgs>(
      args?: Subset<T, UserGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGroupAggregateArgs>(args: Subset<T, UserGroupAggregateArgs>): Prisma.PrismaPromise<GetUserGroupAggregateType<T>>

    /**
     * Group by UserGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserGroup model
   */
  readonly fields: UserGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends GroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupDefaultArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserGroup model
   */
  interface UserGroupFieldRefs {
    readonly userId: FieldRef<"UserGroup", 'Int'>
    readonly groupId: FieldRef<"UserGroup", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserGroup findUnique
   */
  export type UserGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup findUniqueOrThrow
   */
  export type UserGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup findFirst
   */
  export type UserGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroups.
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroups.
     */
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup findFirstOrThrow
   */
  export type UserGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroup to fetch.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGroups.
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGroups.
     */
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup findMany
   */
  export type UserGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter, which UserGroups to fetch.
     */
    where?: UserGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGroups to fetch.
     */
    orderBy?: UserGroupOrderByWithRelationInput | UserGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGroups.
     */
    cursor?: UserGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGroups.
     */
    skip?: number
    distinct?: UserGroupScalarFieldEnum | UserGroupScalarFieldEnum[]
  }

  /**
   * UserGroup create
   */
  export type UserGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a UserGroup.
     */
    data: XOR<UserGroupCreateInput, UserGroupUncheckedCreateInput>
  }

  /**
   * UserGroup createMany
   */
  export type UserGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserGroups.
     */
    data: UserGroupCreateManyInput | UserGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserGroup createManyAndReturn
   */
  export type UserGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * The data used to create many UserGroups.
     */
    data: UserGroupCreateManyInput | UserGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGroup update
   */
  export type UserGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a UserGroup.
     */
    data: XOR<UserGroupUpdateInput, UserGroupUncheckedUpdateInput>
    /**
     * Choose, which UserGroup to update.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup updateMany
   */
  export type UserGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserGroups.
     */
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyInput>
    /**
     * Filter which UserGroups to update
     */
    where?: UserGroupWhereInput
    /**
     * Limit how many UserGroups to update.
     */
    limit?: number
  }

  /**
   * UserGroup updateManyAndReturn
   */
  export type UserGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * The data used to update UserGroups.
     */
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyInput>
    /**
     * Filter which UserGroups to update
     */
    where?: UserGroupWhereInput
    /**
     * Limit how many UserGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGroup upsert
   */
  export type UserGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the UserGroup to update in case it exists.
     */
    where: UserGroupWhereUniqueInput
    /**
     * In case the UserGroup found by the `where` argument doesn't exist, create a new UserGroup with this data.
     */
    create: XOR<UserGroupCreateInput, UserGroupUncheckedCreateInput>
    /**
     * In case the UserGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserGroupUpdateInput, UserGroupUncheckedUpdateInput>
  }

  /**
   * UserGroup delete
   */
  export type UserGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
    /**
     * Filter which UserGroup to delete.
     */
    where: UserGroupWhereUniqueInput
  }

  /**
   * UserGroup deleteMany
   */
  export type UserGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGroups to delete
     */
    where?: UserGroupWhereInput
    /**
     * Limit how many UserGroups to delete.
     */
    limit?: number
  }

  /**
   * UserGroup without action
   */
  export type UserGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGroup
     */
    select?: UserGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGroup
     */
    omit?: UserGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGroupInclude<ExtArgs> | null
  }


  /**
   * Model ModeratorPermission
   */

  export type AggregateModeratorPermission = {
    _count: ModeratorPermissionCountAggregateOutputType | null
    _avg: ModeratorPermissionAvgAggregateOutputType | null
    _sum: ModeratorPermissionSumAggregateOutputType | null
    _min: ModeratorPermissionMinAggregateOutputType | null
    _max: ModeratorPermissionMaxAggregateOutputType | null
  }

  export type ModeratorPermissionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ModeratorPermissionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ModeratorPermissionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    permissionType: string | null
    permissionValue: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type ModeratorPermissionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    permissionType: string | null
    permissionValue: string | null
    createdAt: Date | null
    createdBy: string | null
  }

  export type ModeratorPermissionCountAggregateOutputType = {
    id: number
    userId: number
    permissionType: number
    permissionValue: number
    createdAt: number
    createdBy: number
    _all: number
  }


  export type ModeratorPermissionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ModeratorPermissionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ModeratorPermissionMinAggregateInputType = {
    id?: true
    userId?: true
    permissionType?: true
    permissionValue?: true
    createdAt?: true
    createdBy?: true
  }

  export type ModeratorPermissionMaxAggregateInputType = {
    id?: true
    userId?: true
    permissionType?: true
    permissionValue?: true
    createdAt?: true
    createdBy?: true
  }

  export type ModeratorPermissionCountAggregateInputType = {
    id?: true
    userId?: true
    permissionType?: true
    permissionValue?: true
    createdAt?: true
    createdBy?: true
    _all?: true
  }

  export type ModeratorPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModeratorPermission to aggregate.
     */
    where?: ModeratorPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModeratorPermissions to fetch.
     */
    orderBy?: ModeratorPermissionOrderByWithRelationInput | ModeratorPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModeratorPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModeratorPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModeratorPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModeratorPermissions
    **/
    _count?: true | ModeratorPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModeratorPermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModeratorPermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModeratorPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModeratorPermissionMaxAggregateInputType
  }

  export type GetModeratorPermissionAggregateType<T extends ModeratorPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateModeratorPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModeratorPermission[P]>
      : GetScalarType<T[P], AggregateModeratorPermission[P]>
  }




  export type ModeratorPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModeratorPermissionWhereInput
    orderBy?: ModeratorPermissionOrderByWithAggregationInput | ModeratorPermissionOrderByWithAggregationInput[]
    by: ModeratorPermissionScalarFieldEnum[] | ModeratorPermissionScalarFieldEnum
    having?: ModeratorPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModeratorPermissionCountAggregateInputType | true
    _avg?: ModeratorPermissionAvgAggregateInputType
    _sum?: ModeratorPermissionSumAggregateInputType
    _min?: ModeratorPermissionMinAggregateInputType
    _max?: ModeratorPermissionMaxAggregateInputType
  }

  export type ModeratorPermissionGroupByOutputType = {
    id: number
    userId: number
    permissionType: string
    permissionValue: string | null
    createdAt: Date
    createdBy: string
    _count: ModeratorPermissionCountAggregateOutputType | null
    _avg: ModeratorPermissionAvgAggregateOutputType | null
    _sum: ModeratorPermissionSumAggregateOutputType | null
    _min: ModeratorPermissionMinAggregateOutputType | null
    _max: ModeratorPermissionMaxAggregateOutputType | null
  }

  type GetModeratorPermissionGroupByPayload<T extends ModeratorPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModeratorPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModeratorPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModeratorPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], ModeratorPermissionGroupByOutputType[P]>
        }
      >
    >


  export type ModeratorPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissionType?: boolean
    permissionValue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moderatorPermission"]>

  export type ModeratorPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissionType?: boolean
    permissionValue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moderatorPermission"]>

  export type ModeratorPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissionType?: boolean
    permissionValue?: boolean
    createdAt?: boolean
    createdBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moderatorPermission"]>

  export type ModeratorPermissionSelectScalar = {
    id?: boolean
    userId?: boolean
    permissionType?: boolean
    permissionValue?: boolean
    createdAt?: boolean
    createdBy?: boolean
  }

  export type ModeratorPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "permissionType" | "permissionValue" | "createdAt" | "createdBy", ExtArgs["result"]["moderatorPermission"]>
  export type ModeratorPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ModeratorPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ModeratorPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ModeratorPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModeratorPermission"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      permissionType: string
      permissionValue: string | null
      createdAt: Date
      createdBy: string
    }, ExtArgs["result"]["moderatorPermission"]>
    composites: {}
  }

  type ModeratorPermissionGetPayload<S extends boolean | null | undefined | ModeratorPermissionDefaultArgs> = $Result.GetResult<Prisma.$ModeratorPermissionPayload, S>

  type ModeratorPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModeratorPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModeratorPermissionCountAggregateInputType | true
    }

  export interface ModeratorPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModeratorPermission'], meta: { name: 'ModeratorPermission' } }
    /**
     * Find zero or one ModeratorPermission that matches the filter.
     * @param {ModeratorPermissionFindUniqueArgs} args - Arguments to find a ModeratorPermission
     * @example
     * // Get one ModeratorPermission
     * const moderatorPermission = await prisma.moderatorPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModeratorPermissionFindUniqueArgs>(args: SelectSubset<T, ModeratorPermissionFindUniqueArgs<ExtArgs>>): Prisma__ModeratorPermissionClient<$Result.GetResult<Prisma.$ModeratorPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModeratorPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModeratorPermissionFindUniqueOrThrowArgs} args - Arguments to find a ModeratorPermission
     * @example
     * // Get one ModeratorPermission
     * const moderatorPermission = await prisma.moderatorPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModeratorPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ModeratorPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModeratorPermissionClient<$Result.GetResult<Prisma.$ModeratorPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModeratorPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeratorPermissionFindFirstArgs} args - Arguments to find a ModeratorPermission
     * @example
     * // Get one ModeratorPermission
     * const moderatorPermission = await prisma.moderatorPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModeratorPermissionFindFirstArgs>(args?: SelectSubset<T, ModeratorPermissionFindFirstArgs<ExtArgs>>): Prisma__ModeratorPermissionClient<$Result.GetResult<Prisma.$ModeratorPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModeratorPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeratorPermissionFindFirstOrThrowArgs} args - Arguments to find a ModeratorPermission
     * @example
     * // Get one ModeratorPermission
     * const moderatorPermission = await prisma.moderatorPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModeratorPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ModeratorPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModeratorPermissionClient<$Result.GetResult<Prisma.$ModeratorPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModeratorPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeratorPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModeratorPermissions
     * const moderatorPermissions = await prisma.moderatorPermission.findMany()
     * 
     * // Get first 10 ModeratorPermissions
     * const moderatorPermissions = await prisma.moderatorPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moderatorPermissionWithIdOnly = await prisma.moderatorPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModeratorPermissionFindManyArgs>(args?: SelectSubset<T, ModeratorPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModeratorPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModeratorPermission.
     * @param {ModeratorPermissionCreateArgs} args - Arguments to create a ModeratorPermission.
     * @example
     * // Create one ModeratorPermission
     * const ModeratorPermission = await prisma.moderatorPermission.create({
     *   data: {
     *     // ... data to create a ModeratorPermission
     *   }
     * })
     * 
     */
    create<T extends ModeratorPermissionCreateArgs>(args: SelectSubset<T, ModeratorPermissionCreateArgs<ExtArgs>>): Prisma__ModeratorPermissionClient<$Result.GetResult<Prisma.$ModeratorPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModeratorPermissions.
     * @param {ModeratorPermissionCreateManyArgs} args - Arguments to create many ModeratorPermissions.
     * @example
     * // Create many ModeratorPermissions
     * const moderatorPermission = await prisma.moderatorPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModeratorPermissionCreateManyArgs>(args?: SelectSubset<T, ModeratorPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModeratorPermissions and returns the data saved in the database.
     * @param {ModeratorPermissionCreateManyAndReturnArgs} args - Arguments to create many ModeratorPermissions.
     * @example
     * // Create many ModeratorPermissions
     * const moderatorPermission = await prisma.moderatorPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModeratorPermissions and only return the `id`
     * const moderatorPermissionWithIdOnly = await prisma.moderatorPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModeratorPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ModeratorPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModeratorPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModeratorPermission.
     * @param {ModeratorPermissionDeleteArgs} args - Arguments to delete one ModeratorPermission.
     * @example
     * // Delete one ModeratorPermission
     * const ModeratorPermission = await prisma.moderatorPermission.delete({
     *   where: {
     *     // ... filter to delete one ModeratorPermission
     *   }
     * })
     * 
     */
    delete<T extends ModeratorPermissionDeleteArgs>(args: SelectSubset<T, ModeratorPermissionDeleteArgs<ExtArgs>>): Prisma__ModeratorPermissionClient<$Result.GetResult<Prisma.$ModeratorPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModeratorPermission.
     * @param {ModeratorPermissionUpdateArgs} args - Arguments to update one ModeratorPermission.
     * @example
     * // Update one ModeratorPermission
     * const moderatorPermission = await prisma.moderatorPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModeratorPermissionUpdateArgs>(args: SelectSubset<T, ModeratorPermissionUpdateArgs<ExtArgs>>): Prisma__ModeratorPermissionClient<$Result.GetResult<Prisma.$ModeratorPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModeratorPermissions.
     * @param {ModeratorPermissionDeleteManyArgs} args - Arguments to filter ModeratorPermissions to delete.
     * @example
     * // Delete a few ModeratorPermissions
     * const { count } = await prisma.moderatorPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModeratorPermissionDeleteManyArgs>(args?: SelectSubset<T, ModeratorPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModeratorPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeratorPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModeratorPermissions
     * const moderatorPermission = await prisma.moderatorPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModeratorPermissionUpdateManyArgs>(args: SelectSubset<T, ModeratorPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModeratorPermissions and returns the data updated in the database.
     * @param {ModeratorPermissionUpdateManyAndReturnArgs} args - Arguments to update many ModeratorPermissions.
     * @example
     * // Update many ModeratorPermissions
     * const moderatorPermission = await prisma.moderatorPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModeratorPermissions and only return the `id`
     * const moderatorPermissionWithIdOnly = await prisma.moderatorPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModeratorPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ModeratorPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModeratorPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModeratorPermission.
     * @param {ModeratorPermissionUpsertArgs} args - Arguments to update or create a ModeratorPermission.
     * @example
     * // Update or create a ModeratorPermission
     * const moderatorPermission = await prisma.moderatorPermission.upsert({
     *   create: {
     *     // ... data to create a ModeratorPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModeratorPermission we want to update
     *   }
     * })
     */
    upsert<T extends ModeratorPermissionUpsertArgs>(args: SelectSubset<T, ModeratorPermissionUpsertArgs<ExtArgs>>): Prisma__ModeratorPermissionClient<$Result.GetResult<Prisma.$ModeratorPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModeratorPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeratorPermissionCountArgs} args - Arguments to filter ModeratorPermissions to count.
     * @example
     * // Count the number of ModeratorPermissions
     * const count = await prisma.moderatorPermission.count({
     *   where: {
     *     // ... the filter for the ModeratorPermissions we want to count
     *   }
     * })
    **/
    count<T extends ModeratorPermissionCountArgs>(
      args?: Subset<T, ModeratorPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModeratorPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModeratorPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeratorPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModeratorPermissionAggregateArgs>(args: Subset<T, ModeratorPermissionAggregateArgs>): Prisma.PrismaPromise<GetModeratorPermissionAggregateType<T>>

    /**
     * Group by ModeratorPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModeratorPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModeratorPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModeratorPermissionGroupByArgs['orderBy'] }
        : { orderBy?: ModeratorPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModeratorPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModeratorPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModeratorPermission model
   */
  readonly fields: ModeratorPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModeratorPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModeratorPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModeratorPermission model
   */
  interface ModeratorPermissionFieldRefs {
    readonly id: FieldRef<"ModeratorPermission", 'Int'>
    readonly userId: FieldRef<"ModeratorPermission", 'Int'>
    readonly permissionType: FieldRef<"ModeratorPermission", 'String'>
    readonly permissionValue: FieldRef<"ModeratorPermission", 'String'>
    readonly createdAt: FieldRef<"ModeratorPermission", 'DateTime'>
    readonly createdBy: FieldRef<"ModeratorPermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModeratorPermission findUnique
   */
  export type ModeratorPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ModeratorPermission to fetch.
     */
    where: ModeratorPermissionWhereUniqueInput
  }

  /**
   * ModeratorPermission findUniqueOrThrow
   */
  export type ModeratorPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ModeratorPermission to fetch.
     */
    where: ModeratorPermissionWhereUniqueInput
  }

  /**
   * ModeratorPermission findFirst
   */
  export type ModeratorPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ModeratorPermission to fetch.
     */
    where?: ModeratorPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModeratorPermissions to fetch.
     */
    orderBy?: ModeratorPermissionOrderByWithRelationInput | ModeratorPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModeratorPermissions.
     */
    cursor?: ModeratorPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModeratorPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModeratorPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModeratorPermissions.
     */
    distinct?: ModeratorPermissionScalarFieldEnum | ModeratorPermissionScalarFieldEnum[]
  }

  /**
   * ModeratorPermission findFirstOrThrow
   */
  export type ModeratorPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ModeratorPermission to fetch.
     */
    where?: ModeratorPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModeratorPermissions to fetch.
     */
    orderBy?: ModeratorPermissionOrderByWithRelationInput | ModeratorPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModeratorPermissions.
     */
    cursor?: ModeratorPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModeratorPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModeratorPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModeratorPermissions.
     */
    distinct?: ModeratorPermissionScalarFieldEnum | ModeratorPermissionScalarFieldEnum[]
  }

  /**
   * ModeratorPermission findMany
   */
  export type ModeratorPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ModeratorPermissions to fetch.
     */
    where?: ModeratorPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModeratorPermissions to fetch.
     */
    orderBy?: ModeratorPermissionOrderByWithRelationInput | ModeratorPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModeratorPermissions.
     */
    cursor?: ModeratorPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModeratorPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModeratorPermissions.
     */
    skip?: number
    distinct?: ModeratorPermissionScalarFieldEnum | ModeratorPermissionScalarFieldEnum[]
  }

  /**
   * ModeratorPermission create
   */
  export type ModeratorPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a ModeratorPermission.
     */
    data: XOR<ModeratorPermissionCreateInput, ModeratorPermissionUncheckedCreateInput>
  }

  /**
   * ModeratorPermission createMany
   */
  export type ModeratorPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModeratorPermissions.
     */
    data: ModeratorPermissionCreateManyInput | ModeratorPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModeratorPermission createManyAndReturn
   */
  export type ModeratorPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many ModeratorPermissions.
     */
    data: ModeratorPermissionCreateManyInput | ModeratorPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModeratorPermission update
   */
  export type ModeratorPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a ModeratorPermission.
     */
    data: XOR<ModeratorPermissionUpdateInput, ModeratorPermissionUncheckedUpdateInput>
    /**
     * Choose, which ModeratorPermission to update.
     */
    where: ModeratorPermissionWhereUniqueInput
  }

  /**
   * ModeratorPermission updateMany
   */
  export type ModeratorPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModeratorPermissions.
     */
    data: XOR<ModeratorPermissionUpdateManyMutationInput, ModeratorPermissionUncheckedUpdateManyInput>
    /**
     * Filter which ModeratorPermissions to update
     */
    where?: ModeratorPermissionWhereInput
    /**
     * Limit how many ModeratorPermissions to update.
     */
    limit?: number
  }

  /**
   * ModeratorPermission updateManyAndReturn
   */
  export type ModeratorPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * The data used to update ModeratorPermissions.
     */
    data: XOR<ModeratorPermissionUpdateManyMutationInput, ModeratorPermissionUncheckedUpdateManyInput>
    /**
     * Filter which ModeratorPermissions to update
     */
    where?: ModeratorPermissionWhereInput
    /**
     * Limit how many ModeratorPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModeratorPermission upsert
   */
  export type ModeratorPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the ModeratorPermission to update in case it exists.
     */
    where: ModeratorPermissionWhereUniqueInput
    /**
     * In case the ModeratorPermission found by the `where` argument doesn't exist, create a new ModeratorPermission with this data.
     */
    create: XOR<ModeratorPermissionCreateInput, ModeratorPermissionUncheckedCreateInput>
    /**
     * In case the ModeratorPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModeratorPermissionUpdateInput, ModeratorPermissionUncheckedUpdateInput>
  }

  /**
   * ModeratorPermission delete
   */
  export type ModeratorPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionInclude<ExtArgs> | null
    /**
     * Filter which ModeratorPermission to delete.
     */
    where: ModeratorPermissionWhereUniqueInput
  }

  /**
   * ModeratorPermission deleteMany
   */
  export type ModeratorPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModeratorPermissions to delete
     */
    where?: ModeratorPermissionWhereInput
    /**
     * Limit how many ModeratorPermissions to delete.
     */
    limit?: number
  }

  /**
   * ModeratorPermission without action
   */
  export type ModeratorPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModeratorPermission
     */
    select?: ModeratorPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModeratorPermission
     */
    omit?: ModeratorPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModeratorPermissionInclude<ExtArgs> | null
  }


  /**
   * Model MatrixUser
   */

  export type AggregateMatrixUser = {
    _count: MatrixUserCountAggregateOutputType | null
    _min: MatrixUserMinAggregateOutputType | null
    _max: MatrixUserMaxAggregateOutputType | null
  }

  export type MatrixUserMinAggregateOutputType = {
    userId: string | null
    displayName: string | null
    avatarUrl: string | null
    isSignalUser: boolean | null
    lastSeen: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatrixUserMaxAggregateOutputType = {
    userId: string | null
    displayName: string | null
    avatarUrl: string | null
    isSignalUser: boolean | null
    lastSeen: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatrixUserCountAggregateOutputType = {
    userId: number
    displayName: number
    avatarUrl: number
    isSignalUser: number
    lastSeen: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatrixUserMinAggregateInputType = {
    userId?: true
    displayName?: true
    avatarUrl?: true
    isSignalUser?: true
    lastSeen?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatrixUserMaxAggregateInputType = {
    userId?: true
    displayName?: true
    avatarUrl?: true
    isSignalUser?: true
    lastSeen?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatrixUserCountAggregateInputType = {
    userId?: true
    displayName?: true
    avatarUrl?: true
    isSignalUser?: true
    lastSeen?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatrixUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrixUser to aggregate.
     */
    where?: MatrixUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixUsers to fetch.
     */
    orderBy?: MatrixUserOrderByWithRelationInput | MatrixUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatrixUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatrixUsers
    **/
    _count?: true | MatrixUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatrixUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatrixUserMaxAggregateInputType
  }

  export type GetMatrixUserAggregateType<T extends MatrixUserAggregateArgs> = {
        [P in keyof T & keyof AggregateMatrixUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatrixUser[P]>
      : GetScalarType<T[P], AggregateMatrixUser[P]>
  }




  export type MatrixUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatrixUserWhereInput
    orderBy?: MatrixUserOrderByWithAggregationInput | MatrixUserOrderByWithAggregationInput[]
    by: MatrixUserScalarFieldEnum[] | MatrixUserScalarFieldEnum
    having?: MatrixUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatrixUserCountAggregateInputType | true
    _min?: MatrixUserMinAggregateInputType
    _max?: MatrixUserMaxAggregateInputType
  }

  export type MatrixUserGroupByOutputType = {
    userId: string
    displayName: string | null
    avatarUrl: string | null
    isSignalUser: boolean
    lastSeen: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MatrixUserCountAggregateOutputType | null
    _min: MatrixUserMinAggregateOutputType | null
    _max: MatrixUserMaxAggregateOutputType | null
  }

  type GetMatrixUserGroupByPayload<T extends MatrixUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatrixUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatrixUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatrixUserGroupByOutputType[P]>
            : GetScalarType<T[P], MatrixUserGroupByOutputType[P]>
        }
      >
    >


  export type MatrixUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    isSignalUser?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberships?: boolean | MatrixUser$membershipsArgs<ExtArgs>
    _count?: boolean | MatrixUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matrixUser"]>

  export type MatrixUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    isSignalUser?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matrixUser"]>

  export type MatrixUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    isSignalUser?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matrixUser"]>

  export type MatrixUserSelectScalar = {
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    isSignalUser?: boolean
    lastSeen?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatrixUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "displayName" | "avatarUrl" | "isSignalUser" | "lastSeen" | "createdAt" | "updatedAt", ExtArgs["result"]["matrixUser"]>
  export type MatrixUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | MatrixUser$membershipsArgs<ExtArgs>
    _count?: boolean | MatrixUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MatrixUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MatrixUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MatrixUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatrixUser"
    objects: {
      memberships: Prisma.$MatrixRoomMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      displayName: string | null
      avatarUrl: string | null
      isSignalUser: boolean
      lastSeen: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["matrixUser"]>
    composites: {}
  }

  type MatrixUserGetPayload<S extends boolean | null | undefined | MatrixUserDefaultArgs> = $Result.GetResult<Prisma.$MatrixUserPayload, S>

  type MatrixUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatrixUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatrixUserCountAggregateInputType | true
    }

  export interface MatrixUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatrixUser'], meta: { name: 'MatrixUser' } }
    /**
     * Find zero or one MatrixUser that matches the filter.
     * @param {MatrixUserFindUniqueArgs} args - Arguments to find a MatrixUser
     * @example
     * // Get one MatrixUser
     * const matrixUser = await prisma.matrixUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatrixUserFindUniqueArgs>(args: SelectSubset<T, MatrixUserFindUniqueArgs<ExtArgs>>): Prisma__MatrixUserClient<$Result.GetResult<Prisma.$MatrixUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatrixUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatrixUserFindUniqueOrThrowArgs} args - Arguments to find a MatrixUser
     * @example
     * // Get one MatrixUser
     * const matrixUser = await prisma.matrixUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatrixUserFindUniqueOrThrowArgs>(args: SelectSubset<T, MatrixUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatrixUserClient<$Result.GetResult<Prisma.$MatrixUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatrixUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserFindFirstArgs} args - Arguments to find a MatrixUser
     * @example
     * // Get one MatrixUser
     * const matrixUser = await prisma.matrixUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatrixUserFindFirstArgs>(args?: SelectSubset<T, MatrixUserFindFirstArgs<ExtArgs>>): Prisma__MatrixUserClient<$Result.GetResult<Prisma.$MatrixUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatrixUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserFindFirstOrThrowArgs} args - Arguments to find a MatrixUser
     * @example
     * // Get one MatrixUser
     * const matrixUser = await prisma.matrixUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatrixUserFindFirstOrThrowArgs>(args?: SelectSubset<T, MatrixUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatrixUserClient<$Result.GetResult<Prisma.$MatrixUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatrixUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatrixUsers
     * const matrixUsers = await prisma.matrixUser.findMany()
     * 
     * // Get first 10 MatrixUsers
     * const matrixUsers = await prisma.matrixUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const matrixUserWithUserIdOnly = await prisma.matrixUser.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends MatrixUserFindManyArgs>(args?: SelectSubset<T, MatrixUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatrixUser.
     * @param {MatrixUserCreateArgs} args - Arguments to create a MatrixUser.
     * @example
     * // Create one MatrixUser
     * const MatrixUser = await prisma.matrixUser.create({
     *   data: {
     *     // ... data to create a MatrixUser
     *   }
     * })
     * 
     */
    create<T extends MatrixUserCreateArgs>(args: SelectSubset<T, MatrixUserCreateArgs<ExtArgs>>): Prisma__MatrixUserClient<$Result.GetResult<Prisma.$MatrixUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatrixUsers.
     * @param {MatrixUserCreateManyArgs} args - Arguments to create many MatrixUsers.
     * @example
     * // Create many MatrixUsers
     * const matrixUser = await prisma.matrixUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatrixUserCreateManyArgs>(args?: SelectSubset<T, MatrixUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatrixUsers and returns the data saved in the database.
     * @param {MatrixUserCreateManyAndReturnArgs} args - Arguments to create many MatrixUsers.
     * @example
     * // Create many MatrixUsers
     * const matrixUser = await prisma.matrixUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatrixUsers and only return the `userId`
     * const matrixUserWithUserIdOnly = await prisma.matrixUser.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatrixUserCreateManyAndReturnArgs>(args?: SelectSubset<T, MatrixUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatrixUser.
     * @param {MatrixUserDeleteArgs} args - Arguments to delete one MatrixUser.
     * @example
     * // Delete one MatrixUser
     * const MatrixUser = await prisma.matrixUser.delete({
     *   where: {
     *     // ... filter to delete one MatrixUser
     *   }
     * })
     * 
     */
    delete<T extends MatrixUserDeleteArgs>(args: SelectSubset<T, MatrixUserDeleteArgs<ExtArgs>>): Prisma__MatrixUserClient<$Result.GetResult<Prisma.$MatrixUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatrixUser.
     * @param {MatrixUserUpdateArgs} args - Arguments to update one MatrixUser.
     * @example
     * // Update one MatrixUser
     * const matrixUser = await prisma.matrixUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatrixUserUpdateArgs>(args: SelectSubset<T, MatrixUserUpdateArgs<ExtArgs>>): Prisma__MatrixUserClient<$Result.GetResult<Prisma.$MatrixUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatrixUsers.
     * @param {MatrixUserDeleteManyArgs} args - Arguments to filter MatrixUsers to delete.
     * @example
     * // Delete a few MatrixUsers
     * const { count } = await prisma.matrixUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatrixUserDeleteManyArgs>(args?: SelectSubset<T, MatrixUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrixUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatrixUsers
     * const matrixUser = await prisma.matrixUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatrixUserUpdateManyArgs>(args: SelectSubset<T, MatrixUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrixUsers and returns the data updated in the database.
     * @param {MatrixUserUpdateManyAndReturnArgs} args - Arguments to update many MatrixUsers.
     * @example
     * // Update many MatrixUsers
     * const matrixUser = await prisma.matrixUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatrixUsers and only return the `userId`
     * const matrixUserWithUserIdOnly = await prisma.matrixUser.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatrixUserUpdateManyAndReturnArgs>(args: SelectSubset<T, MatrixUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatrixUser.
     * @param {MatrixUserUpsertArgs} args - Arguments to update or create a MatrixUser.
     * @example
     * // Update or create a MatrixUser
     * const matrixUser = await prisma.matrixUser.upsert({
     *   create: {
     *     // ... data to create a MatrixUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatrixUser we want to update
     *   }
     * })
     */
    upsert<T extends MatrixUserUpsertArgs>(args: SelectSubset<T, MatrixUserUpsertArgs<ExtArgs>>): Prisma__MatrixUserClient<$Result.GetResult<Prisma.$MatrixUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatrixUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserCountArgs} args - Arguments to filter MatrixUsers to count.
     * @example
     * // Count the number of MatrixUsers
     * const count = await prisma.matrixUser.count({
     *   where: {
     *     // ... the filter for the MatrixUsers we want to count
     *   }
     * })
    **/
    count<T extends MatrixUserCountArgs>(
      args?: Subset<T, MatrixUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatrixUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatrixUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatrixUserAggregateArgs>(args: Subset<T, MatrixUserAggregateArgs>): Prisma.PrismaPromise<GetMatrixUserAggregateType<T>>

    /**
     * Group by MatrixUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatrixUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatrixUserGroupByArgs['orderBy'] }
        : { orderBy?: MatrixUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatrixUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatrixUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatrixUser model
   */
  readonly fields: MatrixUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatrixUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatrixUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberships<T extends MatrixUser$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, MatrixUser$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatrixUser model
   */
  interface MatrixUserFieldRefs {
    readonly userId: FieldRef<"MatrixUser", 'String'>
    readonly displayName: FieldRef<"MatrixUser", 'String'>
    readonly avatarUrl: FieldRef<"MatrixUser", 'String'>
    readonly isSignalUser: FieldRef<"MatrixUser", 'Boolean'>
    readonly lastSeen: FieldRef<"MatrixUser", 'DateTime'>
    readonly createdAt: FieldRef<"MatrixUser", 'DateTime'>
    readonly updatedAt: FieldRef<"MatrixUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatrixUser findUnique
   */
  export type MatrixUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUser
     */
    select?: MatrixUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUser
     */
    omit?: MatrixUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixUserInclude<ExtArgs> | null
    /**
     * Filter, which MatrixUser to fetch.
     */
    where: MatrixUserWhereUniqueInput
  }

  /**
   * MatrixUser findUniqueOrThrow
   */
  export type MatrixUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUser
     */
    select?: MatrixUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUser
     */
    omit?: MatrixUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixUserInclude<ExtArgs> | null
    /**
     * Filter, which MatrixUser to fetch.
     */
    where: MatrixUserWhereUniqueInput
  }

  /**
   * MatrixUser findFirst
   */
  export type MatrixUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUser
     */
    select?: MatrixUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUser
     */
    omit?: MatrixUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixUserInclude<ExtArgs> | null
    /**
     * Filter, which MatrixUser to fetch.
     */
    where?: MatrixUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixUsers to fetch.
     */
    orderBy?: MatrixUserOrderByWithRelationInput | MatrixUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrixUsers.
     */
    cursor?: MatrixUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrixUsers.
     */
    distinct?: MatrixUserScalarFieldEnum | MatrixUserScalarFieldEnum[]
  }

  /**
   * MatrixUser findFirstOrThrow
   */
  export type MatrixUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUser
     */
    select?: MatrixUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUser
     */
    omit?: MatrixUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixUserInclude<ExtArgs> | null
    /**
     * Filter, which MatrixUser to fetch.
     */
    where?: MatrixUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixUsers to fetch.
     */
    orderBy?: MatrixUserOrderByWithRelationInput | MatrixUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrixUsers.
     */
    cursor?: MatrixUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrixUsers.
     */
    distinct?: MatrixUserScalarFieldEnum | MatrixUserScalarFieldEnum[]
  }

  /**
   * MatrixUser findMany
   */
  export type MatrixUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUser
     */
    select?: MatrixUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUser
     */
    omit?: MatrixUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixUserInclude<ExtArgs> | null
    /**
     * Filter, which MatrixUsers to fetch.
     */
    where?: MatrixUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixUsers to fetch.
     */
    orderBy?: MatrixUserOrderByWithRelationInput | MatrixUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatrixUsers.
     */
    cursor?: MatrixUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixUsers.
     */
    skip?: number
    distinct?: MatrixUserScalarFieldEnum | MatrixUserScalarFieldEnum[]
  }

  /**
   * MatrixUser create
   */
  export type MatrixUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUser
     */
    select?: MatrixUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUser
     */
    omit?: MatrixUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixUserInclude<ExtArgs> | null
    /**
     * The data needed to create a MatrixUser.
     */
    data: XOR<MatrixUserCreateInput, MatrixUserUncheckedCreateInput>
  }

  /**
   * MatrixUser createMany
   */
  export type MatrixUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatrixUsers.
     */
    data: MatrixUserCreateManyInput | MatrixUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrixUser createManyAndReturn
   */
  export type MatrixUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUser
     */
    select?: MatrixUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUser
     */
    omit?: MatrixUserOmit<ExtArgs> | null
    /**
     * The data used to create many MatrixUsers.
     */
    data: MatrixUserCreateManyInput | MatrixUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrixUser update
   */
  export type MatrixUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUser
     */
    select?: MatrixUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUser
     */
    omit?: MatrixUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixUserInclude<ExtArgs> | null
    /**
     * The data needed to update a MatrixUser.
     */
    data: XOR<MatrixUserUpdateInput, MatrixUserUncheckedUpdateInput>
    /**
     * Choose, which MatrixUser to update.
     */
    where: MatrixUserWhereUniqueInput
  }

  /**
   * MatrixUser updateMany
   */
  export type MatrixUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatrixUsers.
     */
    data: XOR<MatrixUserUpdateManyMutationInput, MatrixUserUncheckedUpdateManyInput>
    /**
     * Filter which MatrixUsers to update
     */
    where?: MatrixUserWhereInput
    /**
     * Limit how many MatrixUsers to update.
     */
    limit?: number
  }

  /**
   * MatrixUser updateManyAndReturn
   */
  export type MatrixUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUser
     */
    select?: MatrixUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUser
     */
    omit?: MatrixUserOmit<ExtArgs> | null
    /**
     * The data used to update MatrixUsers.
     */
    data: XOR<MatrixUserUpdateManyMutationInput, MatrixUserUncheckedUpdateManyInput>
    /**
     * Filter which MatrixUsers to update
     */
    where?: MatrixUserWhereInput
    /**
     * Limit how many MatrixUsers to update.
     */
    limit?: number
  }

  /**
   * MatrixUser upsert
   */
  export type MatrixUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUser
     */
    select?: MatrixUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUser
     */
    omit?: MatrixUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixUserInclude<ExtArgs> | null
    /**
     * The filter to search for the MatrixUser to update in case it exists.
     */
    where: MatrixUserWhereUniqueInput
    /**
     * In case the MatrixUser found by the `where` argument doesn't exist, create a new MatrixUser with this data.
     */
    create: XOR<MatrixUserCreateInput, MatrixUserUncheckedCreateInput>
    /**
     * In case the MatrixUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatrixUserUpdateInput, MatrixUserUncheckedUpdateInput>
  }

  /**
   * MatrixUser delete
   */
  export type MatrixUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUser
     */
    select?: MatrixUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUser
     */
    omit?: MatrixUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixUserInclude<ExtArgs> | null
    /**
     * Filter which MatrixUser to delete.
     */
    where: MatrixUserWhereUniqueInput
  }

  /**
   * MatrixUser deleteMany
   */
  export type MatrixUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrixUsers to delete
     */
    where?: MatrixUserWhereInput
    /**
     * Limit how many MatrixUsers to delete.
     */
    limit?: number
  }

  /**
   * MatrixUser.memberships
   */
  export type MatrixUser$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipInclude<ExtArgs> | null
    where?: MatrixRoomMembershipWhereInput
    orderBy?: MatrixRoomMembershipOrderByWithRelationInput | MatrixRoomMembershipOrderByWithRelationInput[]
    cursor?: MatrixRoomMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatrixRoomMembershipScalarFieldEnum | MatrixRoomMembershipScalarFieldEnum[]
  }

  /**
   * MatrixUser without action
   */
  export type MatrixUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUser
     */
    select?: MatrixUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUser
     */
    omit?: MatrixUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixUserInclude<ExtArgs> | null
  }


  /**
   * Model MatrixRoom
   */

  export type AggregateMatrixRoom = {
    _count: MatrixRoomCountAggregateOutputType | null
    _avg: MatrixRoomAvgAggregateOutputType | null
    _sum: MatrixRoomSumAggregateOutputType | null
    _min: MatrixRoomMinAggregateOutputType | null
    _max: MatrixRoomMaxAggregateOutputType | null
  }

  export type MatrixRoomAvgAggregateOutputType = {
    memberCount: number | null
  }

  export type MatrixRoomSumAggregateOutputType = {
    memberCount: number | null
  }

  export type MatrixRoomMinAggregateOutputType = {
    roomId: string | null
    name: string | null
    displayName: string | null
    topic: string | null
    canonicalAlias: string | null
    memberCount: number | null
    roomType: string | null
    isDirect: boolean | null
    isEncrypted: boolean | null
    lastSynced: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatrixRoomMaxAggregateOutputType = {
    roomId: string | null
    name: string | null
    displayName: string | null
    topic: string | null
    canonicalAlias: string | null
    memberCount: number | null
    roomType: string | null
    isDirect: boolean | null
    isEncrypted: boolean | null
    lastSynced: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatrixRoomCountAggregateOutputType = {
    roomId: number
    name: number
    displayName: number
    topic: number
    canonicalAlias: number
    memberCount: number
    roomType: number
    isDirect: number
    isEncrypted: number
    lastSynced: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatrixRoomAvgAggregateInputType = {
    memberCount?: true
  }

  export type MatrixRoomSumAggregateInputType = {
    memberCount?: true
  }

  export type MatrixRoomMinAggregateInputType = {
    roomId?: true
    name?: true
    displayName?: true
    topic?: true
    canonicalAlias?: true
    memberCount?: true
    roomType?: true
    isDirect?: true
    isEncrypted?: true
    lastSynced?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatrixRoomMaxAggregateInputType = {
    roomId?: true
    name?: true
    displayName?: true
    topic?: true
    canonicalAlias?: true
    memberCount?: true
    roomType?: true
    isDirect?: true
    isEncrypted?: true
    lastSynced?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatrixRoomCountAggregateInputType = {
    roomId?: true
    name?: true
    displayName?: true
    topic?: true
    canonicalAlias?: true
    memberCount?: true
    roomType?: true
    isDirect?: true
    isEncrypted?: true
    lastSynced?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatrixRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrixRoom to aggregate.
     */
    where?: MatrixRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixRooms to fetch.
     */
    orderBy?: MatrixRoomOrderByWithRelationInput | MatrixRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatrixRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatrixRooms
    **/
    _count?: true | MatrixRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatrixRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatrixRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatrixRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatrixRoomMaxAggregateInputType
  }

  export type GetMatrixRoomAggregateType<T extends MatrixRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateMatrixRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatrixRoom[P]>
      : GetScalarType<T[P], AggregateMatrixRoom[P]>
  }




  export type MatrixRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatrixRoomWhereInput
    orderBy?: MatrixRoomOrderByWithAggregationInput | MatrixRoomOrderByWithAggregationInput[]
    by: MatrixRoomScalarFieldEnum[] | MatrixRoomScalarFieldEnum
    having?: MatrixRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatrixRoomCountAggregateInputType | true
    _avg?: MatrixRoomAvgAggregateInputType
    _sum?: MatrixRoomSumAggregateInputType
    _min?: MatrixRoomMinAggregateInputType
    _max?: MatrixRoomMaxAggregateInputType
  }

  export type MatrixRoomGroupByOutputType = {
    roomId: string
    name: string | null
    displayName: string | null
    topic: string | null
    canonicalAlias: string | null
    memberCount: number
    roomType: string | null
    isDirect: boolean
    isEncrypted: boolean
    lastSynced: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MatrixRoomCountAggregateOutputType | null
    _avg: MatrixRoomAvgAggregateOutputType | null
    _sum: MatrixRoomSumAggregateOutputType | null
    _min: MatrixRoomMinAggregateOutputType | null
    _max: MatrixRoomMaxAggregateOutputType | null
  }

  type GetMatrixRoomGroupByPayload<T extends MatrixRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatrixRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatrixRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatrixRoomGroupByOutputType[P]>
            : GetScalarType<T[P], MatrixRoomGroupByOutputType[P]>
        }
      >
    >


  export type MatrixRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomId?: boolean
    name?: boolean
    displayName?: boolean
    topic?: boolean
    canonicalAlias?: boolean
    memberCount?: boolean
    roomType?: boolean
    isDirect?: boolean
    isEncrypted?: boolean
    lastSynced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberships?: boolean | MatrixRoom$membershipsArgs<ExtArgs>
    _count?: boolean | MatrixRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matrixRoom"]>

  export type MatrixRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomId?: boolean
    name?: boolean
    displayName?: boolean
    topic?: boolean
    canonicalAlias?: boolean
    memberCount?: boolean
    roomType?: boolean
    isDirect?: boolean
    isEncrypted?: boolean
    lastSynced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matrixRoom"]>

  export type MatrixRoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomId?: boolean
    name?: boolean
    displayName?: boolean
    topic?: boolean
    canonicalAlias?: boolean
    memberCount?: boolean
    roomType?: boolean
    isDirect?: boolean
    isEncrypted?: boolean
    lastSynced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matrixRoom"]>

  export type MatrixRoomSelectScalar = {
    roomId?: boolean
    name?: boolean
    displayName?: boolean
    topic?: boolean
    canonicalAlias?: boolean
    memberCount?: boolean
    roomType?: boolean
    isDirect?: boolean
    isEncrypted?: boolean
    lastSynced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatrixRoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roomId" | "name" | "displayName" | "topic" | "canonicalAlias" | "memberCount" | "roomType" | "isDirect" | "isEncrypted" | "lastSynced" | "createdAt" | "updatedAt", ExtArgs["result"]["matrixRoom"]>
  export type MatrixRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | MatrixRoom$membershipsArgs<ExtArgs>
    _count?: boolean | MatrixRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MatrixRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MatrixRoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MatrixRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatrixRoom"
    objects: {
      memberships: Prisma.$MatrixRoomMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      roomId: string
      name: string | null
      displayName: string | null
      topic: string | null
      canonicalAlias: string | null
      memberCount: number
      roomType: string | null
      isDirect: boolean
      isEncrypted: boolean
      lastSynced: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["matrixRoom"]>
    composites: {}
  }

  type MatrixRoomGetPayload<S extends boolean | null | undefined | MatrixRoomDefaultArgs> = $Result.GetResult<Prisma.$MatrixRoomPayload, S>

  type MatrixRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatrixRoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatrixRoomCountAggregateInputType | true
    }

  export interface MatrixRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatrixRoom'], meta: { name: 'MatrixRoom' } }
    /**
     * Find zero or one MatrixRoom that matches the filter.
     * @param {MatrixRoomFindUniqueArgs} args - Arguments to find a MatrixRoom
     * @example
     * // Get one MatrixRoom
     * const matrixRoom = await prisma.matrixRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatrixRoomFindUniqueArgs>(args: SelectSubset<T, MatrixRoomFindUniqueArgs<ExtArgs>>): Prisma__MatrixRoomClient<$Result.GetResult<Prisma.$MatrixRoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatrixRoom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatrixRoomFindUniqueOrThrowArgs} args - Arguments to find a MatrixRoom
     * @example
     * // Get one MatrixRoom
     * const matrixRoom = await prisma.matrixRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatrixRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, MatrixRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatrixRoomClient<$Result.GetResult<Prisma.$MatrixRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatrixRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomFindFirstArgs} args - Arguments to find a MatrixRoom
     * @example
     * // Get one MatrixRoom
     * const matrixRoom = await prisma.matrixRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatrixRoomFindFirstArgs>(args?: SelectSubset<T, MatrixRoomFindFirstArgs<ExtArgs>>): Prisma__MatrixRoomClient<$Result.GetResult<Prisma.$MatrixRoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatrixRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomFindFirstOrThrowArgs} args - Arguments to find a MatrixRoom
     * @example
     * // Get one MatrixRoom
     * const matrixRoom = await prisma.matrixRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatrixRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, MatrixRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatrixRoomClient<$Result.GetResult<Prisma.$MatrixRoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatrixRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatrixRooms
     * const matrixRooms = await prisma.matrixRoom.findMany()
     * 
     * // Get first 10 MatrixRooms
     * const matrixRooms = await prisma.matrixRoom.findMany({ take: 10 })
     * 
     * // Only select the `roomId`
     * const matrixRoomWithRoomIdOnly = await prisma.matrixRoom.findMany({ select: { roomId: true } })
     * 
     */
    findMany<T extends MatrixRoomFindManyArgs>(args?: SelectSubset<T, MatrixRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatrixRoom.
     * @param {MatrixRoomCreateArgs} args - Arguments to create a MatrixRoom.
     * @example
     * // Create one MatrixRoom
     * const MatrixRoom = await prisma.matrixRoom.create({
     *   data: {
     *     // ... data to create a MatrixRoom
     *   }
     * })
     * 
     */
    create<T extends MatrixRoomCreateArgs>(args: SelectSubset<T, MatrixRoomCreateArgs<ExtArgs>>): Prisma__MatrixRoomClient<$Result.GetResult<Prisma.$MatrixRoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatrixRooms.
     * @param {MatrixRoomCreateManyArgs} args - Arguments to create many MatrixRooms.
     * @example
     * // Create many MatrixRooms
     * const matrixRoom = await prisma.matrixRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatrixRoomCreateManyArgs>(args?: SelectSubset<T, MatrixRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatrixRooms and returns the data saved in the database.
     * @param {MatrixRoomCreateManyAndReturnArgs} args - Arguments to create many MatrixRooms.
     * @example
     * // Create many MatrixRooms
     * const matrixRoom = await prisma.matrixRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatrixRooms and only return the `roomId`
     * const matrixRoomWithRoomIdOnly = await prisma.matrixRoom.createManyAndReturn({
     *   select: { roomId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatrixRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, MatrixRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixRoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatrixRoom.
     * @param {MatrixRoomDeleteArgs} args - Arguments to delete one MatrixRoom.
     * @example
     * // Delete one MatrixRoom
     * const MatrixRoom = await prisma.matrixRoom.delete({
     *   where: {
     *     // ... filter to delete one MatrixRoom
     *   }
     * })
     * 
     */
    delete<T extends MatrixRoomDeleteArgs>(args: SelectSubset<T, MatrixRoomDeleteArgs<ExtArgs>>): Prisma__MatrixRoomClient<$Result.GetResult<Prisma.$MatrixRoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatrixRoom.
     * @param {MatrixRoomUpdateArgs} args - Arguments to update one MatrixRoom.
     * @example
     * // Update one MatrixRoom
     * const matrixRoom = await prisma.matrixRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatrixRoomUpdateArgs>(args: SelectSubset<T, MatrixRoomUpdateArgs<ExtArgs>>): Prisma__MatrixRoomClient<$Result.GetResult<Prisma.$MatrixRoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatrixRooms.
     * @param {MatrixRoomDeleteManyArgs} args - Arguments to filter MatrixRooms to delete.
     * @example
     * // Delete a few MatrixRooms
     * const { count } = await prisma.matrixRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatrixRoomDeleteManyArgs>(args?: SelectSubset<T, MatrixRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrixRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatrixRooms
     * const matrixRoom = await prisma.matrixRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatrixRoomUpdateManyArgs>(args: SelectSubset<T, MatrixRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrixRooms and returns the data updated in the database.
     * @param {MatrixRoomUpdateManyAndReturnArgs} args - Arguments to update many MatrixRooms.
     * @example
     * // Update many MatrixRooms
     * const matrixRoom = await prisma.matrixRoom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatrixRooms and only return the `roomId`
     * const matrixRoomWithRoomIdOnly = await prisma.matrixRoom.updateManyAndReturn({
     *   select: { roomId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatrixRoomUpdateManyAndReturnArgs>(args: SelectSubset<T, MatrixRoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixRoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatrixRoom.
     * @param {MatrixRoomUpsertArgs} args - Arguments to update or create a MatrixRoom.
     * @example
     * // Update or create a MatrixRoom
     * const matrixRoom = await prisma.matrixRoom.upsert({
     *   create: {
     *     // ... data to create a MatrixRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatrixRoom we want to update
     *   }
     * })
     */
    upsert<T extends MatrixRoomUpsertArgs>(args: SelectSubset<T, MatrixRoomUpsertArgs<ExtArgs>>): Prisma__MatrixRoomClient<$Result.GetResult<Prisma.$MatrixRoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatrixRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomCountArgs} args - Arguments to filter MatrixRooms to count.
     * @example
     * // Count the number of MatrixRooms
     * const count = await prisma.matrixRoom.count({
     *   where: {
     *     // ... the filter for the MatrixRooms we want to count
     *   }
     * })
    **/
    count<T extends MatrixRoomCountArgs>(
      args?: Subset<T, MatrixRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatrixRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatrixRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatrixRoomAggregateArgs>(args: Subset<T, MatrixRoomAggregateArgs>): Prisma.PrismaPromise<GetMatrixRoomAggregateType<T>>

    /**
     * Group by MatrixRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatrixRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatrixRoomGroupByArgs['orderBy'] }
        : { orderBy?: MatrixRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatrixRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatrixRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatrixRoom model
   */
  readonly fields: MatrixRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatrixRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatrixRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberships<T extends MatrixRoom$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, MatrixRoom$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatrixRoom model
   */
  interface MatrixRoomFieldRefs {
    readonly roomId: FieldRef<"MatrixRoom", 'String'>
    readonly name: FieldRef<"MatrixRoom", 'String'>
    readonly displayName: FieldRef<"MatrixRoom", 'String'>
    readonly topic: FieldRef<"MatrixRoom", 'String'>
    readonly canonicalAlias: FieldRef<"MatrixRoom", 'String'>
    readonly memberCount: FieldRef<"MatrixRoom", 'Int'>
    readonly roomType: FieldRef<"MatrixRoom", 'String'>
    readonly isDirect: FieldRef<"MatrixRoom", 'Boolean'>
    readonly isEncrypted: FieldRef<"MatrixRoom", 'Boolean'>
    readonly lastSynced: FieldRef<"MatrixRoom", 'DateTime'>
    readonly createdAt: FieldRef<"MatrixRoom", 'DateTime'>
    readonly updatedAt: FieldRef<"MatrixRoom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatrixRoom findUnique
   */
  export type MatrixRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoom
     */
    select?: MatrixRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoom
     */
    omit?: MatrixRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomInclude<ExtArgs> | null
    /**
     * Filter, which MatrixRoom to fetch.
     */
    where: MatrixRoomWhereUniqueInput
  }

  /**
   * MatrixRoom findUniqueOrThrow
   */
  export type MatrixRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoom
     */
    select?: MatrixRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoom
     */
    omit?: MatrixRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomInclude<ExtArgs> | null
    /**
     * Filter, which MatrixRoom to fetch.
     */
    where: MatrixRoomWhereUniqueInput
  }

  /**
   * MatrixRoom findFirst
   */
  export type MatrixRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoom
     */
    select?: MatrixRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoom
     */
    omit?: MatrixRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomInclude<ExtArgs> | null
    /**
     * Filter, which MatrixRoom to fetch.
     */
    where?: MatrixRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixRooms to fetch.
     */
    orderBy?: MatrixRoomOrderByWithRelationInput | MatrixRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrixRooms.
     */
    cursor?: MatrixRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrixRooms.
     */
    distinct?: MatrixRoomScalarFieldEnum | MatrixRoomScalarFieldEnum[]
  }

  /**
   * MatrixRoom findFirstOrThrow
   */
  export type MatrixRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoom
     */
    select?: MatrixRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoom
     */
    omit?: MatrixRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomInclude<ExtArgs> | null
    /**
     * Filter, which MatrixRoom to fetch.
     */
    where?: MatrixRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixRooms to fetch.
     */
    orderBy?: MatrixRoomOrderByWithRelationInput | MatrixRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrixRooms.
     */
    cursor?: MatrixRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrixRooms.
     */
    distinct?: MatrixRoomScalarFieldEnum | MatrixRoomScalarFieldEnum[]
  }

  /**
   * MatrixRoom findMany
   */
  export type MatrixRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoom
     */
    select?: MatrixRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoom
     */
    omit?: MatrixRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomInclude<ExtArgs> | null
    /**
     * Filter, which MatrixRooms to fetch.
     */
    where?: MatrixRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixRooms to fetch.
     */
    orderBy?: MatrixRoomOrderByWithRelationInput | MatrixRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatrixRooms.
     */
    cursor?: MatrixRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixRooms.
     */
    skip?: number
    distinct?: MatrixRoomScalarFieldEnum | MatrixRoomScalarFieldEnum[]
  }

  /**
   * MatrixRoom create
   */
  export type MatrixRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoom
     */
    select?: MatrixRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoom
     */
    omit?: MatrixRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a MatrixRoom.
     */
    data: XOR<MatrixRoomCreateInput, MatrixRoomUncheckedCreateInput>
  }

  /**
   * MatrixRoom createMany
   */
  export type MatrixRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatrixRooms.
     */
    data: MatrixRoomCreateManyInput | MatrixRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrixRoom createManyAndReturn
   */
  export type MatrixRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoom
     */
    select?: MatrixRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoom
     */
    omit?: MatrixRoomOmit<ExtArgs> | null
    /**
     * The data used to create many MatrixRooms.
     */
    data: MatrixRoomCreateManyInput | MatrixRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrixRoom update
   */
  export type MatrixRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoom
     */
    select?: MatrixRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoom
     */
    omit?: MatrixRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a MatrixRoom.
     */
    data: XOR<MatrixRoomUpdateInput, MatrixRoomUncheckedUpdateInput>
    /**
     * Choose, which MatrixRoom to update.
     */
    where: MatrixRoomWhereUniqueInput
  }

  /**
   * MatrixRoom updateMany
   */
  export type MatrixRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatrixRooms.
     */
    data: XOR<MatrixRoomUpdateManyMutationInput, MatrixRoomUncheckedUpdateManyInput>
    /**
     * Filter which MatrixRooms to update
     */
    where?: MatrixRoomWhereInput
    /**
     * Limit how many MatrixRooms to update.
     */
    limit?: number
  }

  /**
   * MatrixRoom updateManyAndReturn
   */
  export type MatrixRoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoom
     */
    select?: MatrixRoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoom
     */
    omit?: MatrixRoomOmit<ExtArgs> | null
    /**
     * The data used to update MatrixRooms.
     */
    data: XOR<MatrixRoomUpdateManyMutationInput, MatrixRoomUncheckedUpdateManyInput>
    /**
     * Filter which MatrixRooms to update
     */
    where?: MatrixRoomWhereInput
    /**
     * Limit how many MatrixRooms to update.
     */
    limit?: number
  }

  /**
   * MatrixRoom upsert
   */
  export type MatrixRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoom
     */
    select?: MatrixRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoom
     */
    omit?: MatrixRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the MatrixRoom to update in case it exists.
     */
    where: MatrixRoomWhereUniqueInput
    /**
     * In case the MatrixRoom found by the `where` argument doesn't exist, create a new MatrixRoom with this data.
     */
    create: XOR<MatrixRoomCreateInput, MatrixRoomUncheckedCreateInput>
    /**
     * In case the MatrixRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatrixRoomUpdateInput, MatrixRoomUncheckedUpdateInput>
  }

  /**
   * MatrixRoom delete
   */
  export type MatrixRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoom
     */
    select?: MatrixRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoom
     */
    omit?: MatrixRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomInclude<ExtArgs> | null
    /**
     * Filter which MatrixRoom to delete.
     */
    where: MatrixRoomWhereUniqueInput
  }

  /**
   * MatrixRoom deleteMany
   */
  export type MatrixRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrixRooms to delete
     */
    where?: MatrixRoomWhereInput
    /**
     * Limit how many MatrixRooms to delete.
     */
    limit?: number
  }

  /**
   * MatrixRoom.memberships
   */
  export type MatrixRoom$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipInclude<ExtArgs> | null
    where?: MatrixRoomMembershipWhereInput
    orderBy?: MatrixRoomMembershipOrderByWithRelationInput | MatrixRoomMembershipOrderByWithRelationInput[]
    cursor?: MatrixRoomMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatrixRoomMembershipScalarFieldEnum | MatrixRoomMembershipScalarFieldEnum[]
  }

  /**
   * MatrixRoom without action
   */
  export type MatrixRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoom
     */
    select?: MatrixRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoom
     */
    omit?: MatrixRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomInclude<ExtArgs> | null
  }


  /**
   * Model MatrixRoomMembership
   */

  export type AggregateMatrixRoomMembership = {
    _count: MatrixRoomMembershipCountAggregateOutputType | null
    _avg: MatrixRoomMembershipAvgAggregateOutputType | null
    _sum: MatrixRoomMembershipSumAggregateOutputType | null
    _min: MatrixRoomMembershipMinAggregateOutputType | null
    _max: MatrixRoomMembershipMaxAggregateOutputType | null
  }

  export type MatrixRoomMembershipAvgAggregateOutputType = {
    id: number | null
  }

  export type MatrixRoomMembershipSumAggregateOutputType = {
    id: number | null
  }

  export type MatrixRoomMembershipMinAggregateOutputType = {
    id: number | null
    roomId: string | null
    userId: string | null
    membershipStatus: string | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatrixRoomMembershipMaxAggregateOutputType = {
    id: number | null
    roomId: string | null
    userId: string | null
    membershipStatus: string | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatrixRoomMembershipCountAggregateOutputType = {
    id: number
    roomId: number
    userId: number
    membershipStatus: number
    joinedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatrixRoomMembershipAvgAggregateInputType = {
    id?: true
  }

  export type MatrixRoomMembershipSumAggregateInputType = {
    id?: true
  }

  export type MatrixRoomMembershipMinAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    membershipStatus?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatrixRoomMembershipMaxAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    membershipStatus?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatrixRoomMembershipCountAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    membershipStatus?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatrixRoomMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrixRoomMembership to aggregate.
     */
    where?: MatrixRoomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixRoomMemberships to fetch.
     */
    orderBy?: MatrixRoomMembershipOrderByWithRelationInput | MatrixRoomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatrixRoomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixRoomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixRoomMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatrixRoomMemberships
    **/
    _count?: true | MatrixRoomMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatrixRoomMembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatrixRoomMembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatrixRoomMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatrixRoomMembershipMaxAggregateInputType
  }

  export type GetMatrixRoomMembershipAggregateType<T extends MatrixRoomMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateMatrixRoomMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatrixRoomMembership[P]>
      : GetScalarType<T[P], AggregateMatrixRoomMembership[P]>
  }




  export type MatrixRoomMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatrixRoomMembershipWhereInput
    orderBy?: MatrixRoomMembershipOrderByWithAggregationInput | MatrixRoomMembershipOrderByWithAggregationInput[]
    by: MatrixRoomMembershipScalarFieldEnum[] | MatrixRoomMembershipScalarFieldEnum
    having?: MatrixRoomMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatrixRoomMembershipCountAggregateInputType | true
    _avg?: MatrixRoomMembershipAvgAggregateInputType
    _sum?: MatrixRoomMembershipSumAggregateInputType
    _min?: MatrixRoomMembershipMinAggregateInputType
    _max?: MatrixRoomMembershipMaxAggregateInputType
  }

  export type MatrixRoomMembershipGroupByOutputType = {
    id: number
    roomId: string
    userId: string
    membershipStatus: string
    joinedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MatrixRoomMembershipCountAggregateOutputType | null
    _avg: MatrixRoomMembershipAvgAggregateOutputType | null
    _sum: MatrixRoomMembershipSumAggregateOutputType | null
    _min: MatrixRoomMembershipMinAggregateOutputType | null
    _max: MatrixRoomMembershipMaxAggregateOutputType | null
  }

  type GetMatrixRoomMembershipGroupByPayload<T extends MatrixRoomMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatrixRoomMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatrixRoomMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatrixRoomMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], MatrixRoomMembershipGroupByOutputType[P]>
        }
      >
    >


  export type MatrixRoomMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    membershipStatus?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | MatrixUserDefaultArgs<ExtArgs>
    room?: boolean | MatrixRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matrixRoomMembership"]>

  export type MatrixRoomMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    membershipStatus?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | MatrixUserDefaultArgs<ExtArgs>
    room?: boolean | MatrixRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matrixRoomMembership"]>

  export type MatrixRoomMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    membershipStatus?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | MatrixUserDefaultArgs<ExtArgs>
    room?: boolean | MatrixRoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matrixRoomMembership"]>

  export type MatrixRoomMembershipSelectScalar = {
    id?: boolean
    roomId?: boolean
    userId?: boolean
    membershipStatus?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatrixRoomMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "userId" | "membershipStatus" | "joinedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["matrixRoomMembership"]>
  export type MatrixRoomMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MatrixUserDefaultArgs<ExtArgs>
    room?: boolean | MatrixRoomDefaultArgs<ExtArgs>
  }
  export type MatrixRoomMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MatrixUserDefaultArgs<ExtArgs>
    room?: boolean | MatrixRoomDefaultArgs<ExtArgs>
  }
  export type MatrixRoomMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | MatrixUserDefaultArgs<ExtArgs>
    room?: boolean | MatrixRoomDefaultArgs<ExtArgs>
  }

  export type $MatrixRoomMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatrixRoomMembership"
    objects: {
      user: Prisma.$MatrixUserPayload<ExtArgs>
      room: Prisma.$MatrixRoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roomId: string
      userId: string
      membershipStatus: string
      joinedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["matrixRoomMembership"]>
    composites: {}
  }

  type MatrixRoomMembershipGetPayload<S extends boolean | null | undefined | MatrixRoomMembershipDefaultArgs> = $Result.GetResult<Prisma.$MatrixRoomMembershipPayload, S>

  type MatrixRoomMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatrixRoomMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatrixRoomMembershipCountAggregateInputType | true
    }

  export interface MatrixRoomMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatrixRoomMembership'], meta: { name: 'MatrixRoomMembership' } }
    /**
     * Find zero or one MatrixRoomMembership that matches the filter.
     * @param {MatrixRoomMembershipFindUniqueArgs} args - Arguments to find a MatrixRoomMembership
     * @example
     * // Get one MatrixRoomMembership
     * const matrixRoomMembership = await prisma.matrixRoomMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatrixRoomMembershipFindUniqueArgs>(args: SelectSubset<T, MatrixRoomMembershipFindUniqueArgs<ExtArgs>>): Prisma__MatrixRoomMembershipClient<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatrixRoomMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatrixRoomMembershipFindUniqueOrThrowArgs} args - Arguments to find a MatrixRoomMembership
     * @example
     * // Get one MatrixRoomMembership
     * const matrixRoomMembership = await prisma.matrixRoomMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatrixRoomMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, MatrixRoomMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatrixRoomMembershipClient<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatrixRoomMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMembershipFindFirstArgs} args - Arguments to find a MatrixRoomMembership
     * @example
     * // Get one MatrixRoomMembership
     * const matrixRoomMembership = await prisma.matrixRoomMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatrixRoomMembershipFindFirstArgs>(args?: SelectSubset<T, MatrixRoomMembershipFindFirstArgs<ExtArgs>>): Prisma__MatrixRoomMembershipClient<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatrixRoomMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMembershipFindFirstOrThrowArgs} args - Arguments to find a MatrixRoomMembership
     * @example
     * // Get one MatrixRoomMembership
     * const matrixRoomMembership = await prisma.matrixRoomMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatrixRoomMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, MatrixRoomMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatrixRoomMembershipClient<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatrixRoomMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatrixRoomMemberships
     * const matrixRoomMemberships = await prisma.matrixRoomMembership.findMany()
     * 
     * // Get first 10 MatrixRoomMemberships
     * const matrixRoomMemberships = await prisma.matrixRoomMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matrixRoomMembershipWithIdOnly = await prisma.matrixRoomMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatrixRoomMembershipFindManyArgs>(args?: SelectSubset<T, MatrixRoomMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatrixRoomMembership.
     * @param {MatrixRoomMembershipCreateArgs} args - Arguments to create a MatrixRoomMembership.
     * @example
     * // Create one MatrixRoomMembership
     * const MatrixRoomMembership = await prisma.matrixRoomMembership.create({
     *   data: {
     *     // ... data to create a MatrixRoomMembership
     *   }
     * })
     * 
     */
    create<T extends MatrixRoomMembershipCreateArgs>(args: SelectSubset<T, MatrixRoomMembershipCreateArgs<ExtArgs>>): Prisma__MatrixRoomMembershipClient<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatrixRoomMemberships.
     * @param {MatrixRoomMembershipCreateManyArgs} args - Arguments to create many MatrixRoomMemberships.
     * @example
     * // Create many MatrixRoomMemberships
     * const matrixRoomMembership = await prisma.matrixRoomMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatrixRoomMembershipCreateManyArgs>(args?: SelectSubset<T, MatrixRoomMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatrixRoomMemberships and returns the data saved in the database.
     * @param {MatrixRoomMembershipCreateManyAndReturnArgs} args - Arguments to create many MatrixRoomMemberships.
     * @example
     * // Create many MatrixRoomMemberships
     * const matrixRoomMembership = await prisma.matrixRoomMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatrixRoomMemberships and only return the `id`
     * const matrixRoomMembershipWithIdOnly = await prisma.matrixRoomMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatrixRoomMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, MatrixRoomMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatrixRoomMembership.
     * @param {MatrixRoomMembershipDeleteArgs} args - Arguments to delete one MatrixRoomMembership.
     * @example
     * // Delete one MatrixRoomMembership
     * const MatrixRoomMembership = await prisma.matrixRoomMembership.delete({
     *   where: {
     *     // ... filter to delete one MatrixRoomMembership
     *   }
     * })
     * 
     */
    delete<T extends MatrixRoomMembershipDeleteArgs>(args: SelectSubset<T, MatrixRoomMembershipDeleteArgs<ExtArgs>>): Prisma__MatrixRoomMembershipClient<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatrixRoomMembership.
     * @param {MatrixRoomMembershipUpdateArgs} args - Arguments to update one MatrixRoomMembership.
     * @example
     * // Update one MatrixRoomMembership
     * const matrixRoomMembership = await prisma.matrixRoomMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatrixRoomMembershipUpdateArgs>(args: SelectSubset<T, MatrixRoomMembershipUpdateArgs<ExtArgs>>): Prisma__MatrixRoomMembershipClient<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatrixRoomMemberships.
     * @param {MatrixRoomMembershipDeleteManyArgs} args - Arguments to filter MatrixRoomMemberships to delete.
     * @example
     * // Delete a few MatrixRoomMemberships
     * const { count } = await prisma.matrixRoomMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatrixRoomMembershipDeleteManyArgs>(args?: SelectSubset<T, MatrixRoomMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrixRoomMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatrixRoomMemberships
     * const matrixRoomMembership = await prisma.matrixRoomMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatrixRoomMembershipUpdateManyArgs>(args: SelectSubset<T, MatrixRoomMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrixRoomMemberships and returns the data updated in the database.
     * @param {MatrixRoomMembershipUpdateManyAndReturnArgs} args - Arguments to update many MatrixRoomMemberships.
     * @example
     * // Update many MatrixRoomMemberships
     * const matrixRoomMembership = await prisma.matrixRoomMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatrixRoomMemberships and only return the `id`
     * const matrixRoomMembershipWithIdOnly = await prisma.matrixRoomMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatrixRoomMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, MatrixRoomMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatrixRoomMembership.
     * @param {MatrixRoomMembershipUpsertArgs} args - Arguments to update or create a MatrixRoomMembership.
     * @example
     * // Update or create a MatrixRoomMembership
     * const matrixRoomMembership = await prisma.matrixRoomMembership.upsert({
     *   create: {
     *     // ... data to create a MatrixRoomMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatrixRoomMembership we want to update
     *   }
     * })
     */
    upsert<T extends MatrixRoomMembershipUpsertArgs>(args: SelectSubset<T, MatrixRoomMembershipUpsertArgs<ExtArgs>>): Prisma__MatrixRoomMembershipClient<$Result.GetResult<Prisma.$MatrixRoomMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatrixRoomMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMembershipCountArgs} args - Arguments to filter MatrixRoomMemberships to count.
     * @example
     * // Count the number of MatrixRoomMemberships
     * const count = await prisma.matrixRoomMembership.count({
     *   where: {
     *     // ... the filter for the MatrixRoomMemberships we want to count
     *   }
     * })
    **/
    count<T extends MatrixRoomMembershipCountArgs>(
      args?: Subset<T, MatrixRoomMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatrixRoomMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatrixRoomMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatrixRoomMembershipAggregateArgs>(args: Subset<T, MatrixRoomMembershipAggregateArgs>): Prisma.PrismaPromise<GetMatrixRoomMembershipAggregateType<T>>

    /**
     * Group by MatrixRoomMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixRoomMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatrixRoomMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatrixRoomMembershipGroupByArgs['orderBy'] }
        : { orderBy?: MatrixRoomMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatrixRoomMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatrixRoomMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatrixRoomMembership model
   */
  readonly fields: MatrixRoomMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatrixRoomMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatrixRoomMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends MatrixUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatrixUserDefaultArgs<ExtArgs>>): Prisma__MatrixUserClient<$Result.GetResult<Prisma.$MatrixUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    room<T extends MatrixRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatrixRoomDefaultArgs<ExtArgs>>): Prisma__MatrixRoomClient<$Result.GetResult<Prisma.$MatrixRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatrixRoomMembership model
   */
  interface MatrixRoomMembershipFieldRefs {
    readonly id: FieldRef<"MatrixRoomMembership", 'Int'>
    readonly roomId: FieldRef<"MatrixRoomMembership", 'String'>
    readonly userId: FieldRef<"MatrixRoomMembership", 'String'>
    readonly membershipStatus: FieldRef<"MatrixRoomMembership", 'String'>
    readonly joinedAt: FieldRef<"MatrixRoomMembership", 'DateTime'>
    readonly createdAt: FieldRef<"MatrixRoomMembership", 'DateTime'>
    readonly updatedAt: FieldRef<"MatrixRoomMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatrixRoomMembership findUnique
   */
  export type MatrixRoomMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which MatrixRoomMembership to fetch.
     */
    where: MatrixRoomMembershipWhereUniqueInput
  }

  /**
   * MatrixRoomMembership findUniqueOrThrow
   */
  export type MatrixRoomMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which MatrixRoomMembership to fetch.
     */
    where: MatrixRoomMembershipWhereUniqueInput
  }

  /**
   * MatrixRoomMembership findFirst
   */
  export type MatrixRoomMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which MatrixRoomMembership to fetch.
     */
    where?: MatrixRoomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixRoomMemberships to fetch.
     */
    orderBy?: MatrixRoomMembershipOrderByWithRelationInput | MatrixRoomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrixRoomMemberships.
     */
    cursor?: MatrixRoomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixRoomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixRoomMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrixRoomMemberships.
     */
    distinct?: MatrixRoomMembershipScalarFieldEnum | MatrixRoomMembershipScalarFieldEnum[]
  }

  /**
   * MatrixRoomMembership findFirstOrThrow
   */
  export type MatrixRoomMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which MatrixRoomMembership to fetch.
     */
    where?: MatrixRoomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixRoomMemberships to fetch.
     */
    orderBy?: MatrixRoomMembershipOrderByWithRelationInput | MatrixRoomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrixRoomMemberships.
     */
    cursor?: MatrixRoomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixRoomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixRoomMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrixRoomMemberships.
     */
    distinct?: MatrixRoomMembershipScalarFieldEnum | MatrixRoomMembershipScalarFieldEnum[]
  }

  /**
   * MatrixRoomMembership findMany
   */
  export type MatrixRoomMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which MatrixRoomMemberships to fetch.
     */
    where?: MatrixRoomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixRoomMemberships to fetch.
     */
    orderBy?: MatrixRoomMembershipOrderByWithRelationInput | MatrixRoomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatrixRoomMemberships.
     */
    cursor?: MatrixRoomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixRoomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixRoomMemberships.
     */
    skip?: number
    distinct?: MatrixRoomMembershipScalarFieldEnum | MatrixRoomMembershipScalarFieldEnum[]
  }

  /**
   * MatrixRoomMembership create
   */
  export type MatrixRoomMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a MatrixRoomMembership.
     */
    data: XOR<MatrixRoomMembershipCreateInput, MatrixRoomMembershipUncheckedCreateInput>
  }

  /**
   * MatrixRoomMembership createMany
   */
  export type MatrixRoomMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatrixRoomMemberships.
     */
    data: MatrixRoomMembershipCreateManyInput | MatrixRoomMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrixRoomMembership createManyAndReturn
   */
  export type MatrixRoomMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many MatrixRoomMemberships.
     */
    data: MatrixRoomMembershipCreateManyInput | MatrixRoomMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatrixRoomMembership update
   */
  export type MatrixRoomMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a MatrixRoomMembership.
     */
    data: XOR<MatrixRoomMembershipUpdateInput, MatrixRoomMembershipUncheckedUpdateInput>
    /**
     * Choose, which MatrixRoomMembership to update.
     */
    where: MatrixRoomMembershipWhereUniqueInput
  }

  /**
   * MatrixRoomMembership updateMany
   */
  export type MatrixRoomMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatrixRoomMemberships.
     */
    data: XOR<MatrixRoomMembershipUpdateManyMutationInput, MatrixRoomMembershipUncheckedUpdateManyInput>
    /**
     * Filter which MatrixRoomMemberships to update
     */
    where?: MatrixRoomMembershipWhereInput
    /**
     * Limit how many MatrixRoomMemberships to update.
     */
    limit?: number
  }

  /**
   * MatrixRoomMembership updateManyAndReturn
   */
  export type MatrixRoomMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * The data used to update MatrixRoomMemberships.
     */
    data: XOR<MatrixRoomMembershipUpdateManyMutationInput, MatrixRoomMembershipUncheckedUpdateManyInput>
    /**
     * Filter which MatrixRoomMemberships to update
     */
    where?: MatrixRoomMembershipWhereInput
    /**
     * Limit how many MatrixRoomMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatrixRoomMembership upsert
   */
  export type MatrixRoomMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the MatrixRoomMembership to update in case it exists.
     */
    where: MatrixRoomMembershipWhereUniqueInput
    /**
     * In case the MatrixRoomMembership found by the `where` argument doesn't exist, create a new MatrixRoomMembership with this data.
     */
    create: XOR<MatrixRoomMembershipCreateInput, MatrixRoomMembershipUncheckedCreateInput>
    /**
     * In case the MatrixRoomMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatrixRoomMembershipUpdateInput, MatrixRoomMembershipUncheckedUpdateInput>
  }

  /**
   * MatrixRoomMembership delete
   */
  export type MatrixRoomMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipInclude<ExtArgs> | null
    /**
     * Filter which MatrixRoomMembership to delete.
     */
    where: MatrixRoomMembershipWhereUniqueInput
  }

  /**
   * MatrixRoomMembership deleteMany
   */
  export type MatrixRoomMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrixRoomMemberships to delete
     */
    where?: MatrixRoomMembershipWhereInput
    /**
     * Limit how many MatrixRoomMemberships to delete.
     */
    limit?: number
  }

  /**
   * MatrixRoomMembership without action
   */
  export type MatrixRoomMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixRoomMembership
     */
    select?: MatrixRoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixRoomMembership
     */
    omit?: MatrixRoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatrixRoomMembershipInclude<ExtArgs> | null
  }


  /**
   * Model MatrixSyncStatus
   */

  export type AggregateMatrixSyncStatus = {
    _count: MatrixSyncStatusCountAggregateOutputType | null
    _avg: MatrixSyncStatusAvgAggregateOutputType | null
    _sum: MatrixSyncStatusSumAggregateOutputType | null
    _min: MatrixSyncStatusMinAggregateOutputType | null
    _max: MatrixSyncStatusMaxAggregateOutputType | null
  }

  export type MatrixSyncStatusAvgAggregateOutputType = {
    id: number | null
    totalItems: number | null
    processedItems: number | null
    syncDurationSeconds: number | null
  }

  export type MatrixSyncStatusSumAggregateOutputType = {
    id: number | null
    totalItems: number | null
    processedItems: number | null
    syncDurationSeconds: number | null
  }

  export type MatrixSyncStatusMinAggregateOutputType = {
    id: number | null
    syncType: string | null
    status: string | null
    lastSync: Date | null
    totalItems: number | null
    processedItems: number | null
    errorMessage: string | null
    syncDurationSeconds: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatrixSyncStatusMaxAggregateOutputType = {
    id: number | null
    syncType: string | null
    status: string | null
    lastSync: Date | null
    totalItems: number | null
    processedItems: number | null
    errorMessage: string | null
    syncDurationSeconds: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MatrixSyncStatusCountAggregateOutputType = {
    id: number
    syncType: number
    status: number
    lastSync: number
    totalItems: number
    processedItems: number
    errorMessage: number
    syncDurationSeconds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MatrixSyncStatusAvgAggregateInputType = {
    id?: true
    totalItems?: true
    processedItems?: true
    syncDurationSeconds?: true
  }

  export type MatrixSyncStatusSumAggregateInputType = {
    id?: true
    totalItems?: true
    processedItems?: true
    syncDurationSeconds?: true
  }

  export type MatrixSyncStatusMinAggregateInputType = {
    id?: true
    syncType?: true
    status?: true
    lastSync?: true
    totalItems?: true
    processedItems?: true
    errorMessage?: true
    syncDurationSeconds?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatrixSyncStatusMaxAggregateInputType = {
    id?: true
    syncType?: true
    status?: true
    lastSync?: true
    totalItems?: true
    processedItems?: true
    errorMessage?: true
    syncDurationSeconds?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MatrixSyncStatusCountAggregateInputType = {
    id?: true
    syncType?: true
    status?: true
    lastSync?: true
    totalItems?: true
    processedItems?: true
    errorMessage?: true
    syncDurationSeconds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MatrixSyncStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrixSyncStatus to aggregate.
     */
    where?: MatrixSyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixSyncStatuses to fetch.
     */
    orderBy?: MatrixSyncStatusOrderByWithRelationInput | MatrixSyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatrixSyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixSyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixSyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatrixSyncStatuses
    **/
    _count?: true | MatrixSyncStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatrixSyncStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatrixSyncStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatrixSyncStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatrixSyncStatusMaxAggregateInputType
  }

  export type GetMatrixSyncStatusAggregateType<T extends MatrixSyncStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateMatrixSyncStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatrixSyncStatus[P]>
      : GetScalarType<T[P], AggregateMatrixSyncStatus[P]>
  }




  export type MatrixSyncStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatrixSyncStatusWhereInput
    orderBy?: MatrixSyncStatusOrderByWithAggregationInput | MatrixSyncStatusOrderByWithAggregationInput[]
    by: MatrixSyncStatusScalarFieldEnum[] | MatrixSyncStatusScalarFieldEnum
    having?: MatrixSyncStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatrixSyncStatusCountAggregateInputType | true
    _avg?: MatrixSyncStatusAvgAggregateInputType
    _sum?: MatrixSyncStatusSumAggregateInputType
    _min?: MatrixSyncStatusMinAggregateInputType
    _max?: MatrixSyncStatusMaxAggregateInputType
  }

  export type MatrixSyncStatusGroupByOutputType = {
    id: number
    syncType: string
    status: string
    lastSync: Date | null
    totalItems: number
    processedItems: number
    errorMessage: string | null
    syncDurationSeconds: number | null
    createdAt: Date
    updatedAt: Date
    _count: MatrixSyncStatusCountAggregateOutputType | null
    _avg: MatrixSyncStatusAvgAggregateOutputType | null
    _sum: MatrixSyncStatusSumAggregateOutputType | null
    _min: MatrixSyncStatusMinAggregateOutputType | null
    _max: MatrixSyncStatusMaxAggregateOutputType | null
  }

  type GetMatrixSyncStatusGroupByPayload<T extends MatrixSyncStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatrixSyncStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatrixSyncStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatrixSyncStatusGroupByOutputType[P]>
            : GetScalarType<T[P], MatrixSyncStatusGroupByOutputType[P]>
        }
      >
    >


  export type MatrixSyncStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncType?: boolean
    status?: boolean
    lastSync?: boolean
    totalItems?: boolean
    processedItems?: boolean
    errorMessage?: boolean
    syncDurationSeconds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matrixSyncStatus"]>

  export type MatrixSyncStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncType?: boolean
    status?: boolean
    lastSync?: boolean
    totalItems?: boolean
    processedItems?: boolean
    errorMessage?: boolean
    syncDurationSeconds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matrixSyncStatus"]>

  export type MatrixSyncStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncType?: boolean
    status?: boolean
    lastSync?: boolean
    totalItems?: boolean
    processedItems?: boolean
    errorMessage?: boolean
    syncDurationSeconds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["matrixSyncStatus"]>

  export type MatrixSyncStatusSelectScalar = {
    id?: boolean
    syncType?: boolean
    status?: boolean
    lastSync?: boolean
    totalItems?: boolean
    processedItems?: boolean
    errorMessage?: boolean
    syncDurationSeconds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MatrixSyncStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "syncType" | "status" | "lastSync" | "totalItems" | "processedItems" | "errorMessage" | "syncDurationSeconds" | "createdAt" | "updatedAt", ExtArgs["result"]["matrixSyncStatus"]>

  export type $MatrixSyncStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatrixSyncStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      syncType: string
      status: string
      lastSync: Date | null
      totalItems: number
      processedItems: number
      errorMessage: string | null
      syncDurationSeconds: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["matrixSyncStatus"]>
    composites: {}
  }

  type MatrixSyncStatusGetPayload<S extends boolean | null | undefined | MatrixSyncStatusDefaultArgs> = $Result.GetResult<Prisma.$MatrixSyncStatusPayload, S>

  type MatrixSyncStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatrixSyncStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatrixSyncStatusCountAggregateInputType | true
    }

  export interface MatrixSyncStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatrixSyncStatus'], meta: { name: 'MatrixSyncStatus' } }
    /**
     * Find zero or one MatrixSyncStatus that matches the filter.
     * @param {MatrixSyncStatusFindUniqueArgs} args - Arguments to find a MatrixSyncStatus
     * @example
     * // Get one MatrixSyncStatus
     * const matrixSyncStatus = await prisma.matrixSyncStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatrixSyncStatusFindUniqueArgs>(args: SelectSubset<T, MatrixSyncStatusFindUniqueArgs<ExtArgs>>): Prisma__MatrixSyncStatusClient<$Result.GetResult<Prisma.$MatrixSyncStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatrixSyncStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatrixSyncStatusFindUniqueOrThrowArgs} args - Arguments to find a MatrixSyncStatus
     * @example
     * // Get one MatrixSyncStatus
     * const matrixSyncStatus = await prisma.matrixSyncStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatrixSyncStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, MatrixSyncStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatrixSyncStatusClient<$Result.GetResult<Prisma.$MatrixSyncStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatrixSyncStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixSyncStatusFindFirstArgs} args - Arguments to find a MatrixSyncStatus
     * @example
     * // Get one MatrixSyncStatus
     * const matrixSyncStatus = await prisma.matrixSyncStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatrixSyncStatusFindFirstArgs>(args?: SelectSubset<T, MatrixSyncStatusFindFirstArgs<ExtArgs>>): Prisma__MatrixSyncStatusClient<$Result.GetResult<Prisma.$MatrixSyncStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatrixSyncStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixSyncStatusFindFirstOrThrowArgs} args - Arguments to find a MatrixSyncStatus
     * @example
     * // Get one MatrixSyncStatus
     * const matrixSyncStatus = await prisma.matrixSyncStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatrixSyncStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, MatrixSyncStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatrixSyncStatusClient<$Result.GetResult<Prisma.$MatrixSyncStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatrixSyncStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixSyncStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatrixSyncStatuses
     * const matrixSyncStatuses = await prisma.matrixSyncStatus.findMany()
     * 
     * // Get first 10 MatrixSyncStatuses
     * const matrixSyncStatuses = await prisma.matrixSyncStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matrixSyncStatusWithIdOnly = await prisma.matrixSyncStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatrixSyncStatusFindManyArgs>(args?: SelectSubset<T, MatrixSyncStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixSyncStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatrixSyncStatus.
     * @param {MatrixSyncStatusCreateArgs} args - Arguments to create a MatrixSyncStatus.
     * @example
     * // Create one MatrixSyncStatus
     * const MatrixSyncStatus = await prisma.matrixSyncStatus.create({
     *   data: {
     *     // ... data to create a MatrixSyncStatus
     *   }
     * })
     * 
     */
    create<T extends MatrixSyncStatusCreateArgs>(args: SelectSubset<T, MatrixSyncStatusCreateArgs<ExtArgs>>): Prisma__MatrixSyncStatusClient<$Result.GetResult<Prisma.$MatrixSyncStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatrixSyncStatuses.
     * @param {MatrixSyncStatusCreateManyArgs} args - Arguments to create many MatrixSyncStatuses.
     * @example
     * // Create many MatrixSyncStatuses
     * const matrixSyncStatus = await prisma.matrixSyncStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatrixSyncStatusCreateManyArgs>(args?: SelectSubset<T, MatrixSyncStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatrixSyncStatuses and returns the data saved in the database.
     * @param {MatrixSyncStatusCreateManyAndReturnArgs} args - Arguments to create many MatrixSyncStatuses.
     * @example
     * // Create many MatrixSyncStatuses
     * const matrixSyncStatus = await prisma.matrixSyncStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatrixSyncStatuses and only return the `id`
     * const matrixSyncStatusWithIdOnly = await prisma.matrixSyncStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatrixSyncStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, MatrixSyncStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixSyncStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatrixSyncStatus.
     * @param {MatrixSyncStatusDeleteArgs} args - Arguments to delete one MatrixSyncStatus.
     * @example
     * // Delete one MatrixSyncStatus
     * const MatrixSyncStatus = await prisma.matrixSyncStatus.delete({
     *   where: {
     *     // ... filter to delete one MatrixSyncStatus
     *   }
     * })
     * 
     */
    delete<T extends MatrixSyncStatusDeleteArgs>(args: SelectSubset<T, MatrixSyncStatusDeleteArgs<ExtArgs>>): Prisma__MatrixSyncStatusClient<$Result.GetResult<Prisma.$MatrixSyncStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatrixSyncStatus.
     * @param {MatrixSyncStatusUpdateArgs} args - Arguments to update one MatrixSyncStatus.
     * @example
     * // Update one MatrixSyncStatus
     * const matrixSyncStatus = await prisma.matrixSyncStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatrixSyncStatusUpdateArgs>(args: SelectSubset<T, MatrixSyncStatusUpdateArgs<ExtArgs>>): Prisma__MatrixSyncStatusClient<$Result.GetResult<Prisma.$MatrixSyncStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatrixSyncStatuses.
     * @param {MatrixSyncStatusDeleteManyArgs} args - Arguments to filter MatrixSyncStatuses to delete.
     * @example
     * // Delete a few MatrixSyncStatuses
     * const { count } = await prisma.matrixSyncStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatrixSyncStatusDeleteManyArgs>(args?: SelectSubset<T, MatrixSyncStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrixSyncStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixSyncStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatrixSyncStatuses
     * const matrixSyncStatus = await prisma.matrixSyncStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatrixSyncStatusUpdateManyArgs>(args: SelectSubset<T, MatrixSyncStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrixSyncStatuses and returns the data updated in the database.
     * @param {MatrixSyncStatusUpdateManyAndReturnArgs} args - Arguments to update many MatrixSyncStatuses.
     * @example
     * // Update many MatrixSyncStatuses
     * const matrixSyncStatus = await prisma.matrixSyncStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatrixSyncStatuses and only return the `id`
     * const matrixSyncStatusWithIdOnly = await prisma.matrixSyncStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatrixSyncStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, MatrixSyncStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixSyncStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatrixSyncStatus.
     * @param {MatrixSyncStatusUpsertArgs} args - Arguments to update or create a MatrixSyncStatus.
     * @example
     * // Update or create a MatrixSyncStatus
     * const matrixSyncStatus = await prisma.matrixSyncStatus.upsert({
     *   create: {
     *     // ... data to create a MatrixSyncStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatrixSyncStatus we want to update
     *   }
     * })
     */
    upsert<T extends MatrixSyncStatusUpsertArgs>(args: SelectSubset<T, MatrixSyncStatusUpsertArgs<ExtArgs>>): Prisma__MatrixSyncStatusClient<$Result.GetResult<Prisma.$MatrixSyncStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatrixSyncStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixSyncStatusCountArgs} args - Arguments to filter MatrixSyncStatuses to count.
     * @example
     * // Count the number of MatrixSyncStatuses
     * const count = await prisma.matrixSyncStatus.count({
     *   where: {
     *     // ... the filter for the MatrixSyncStatuses we want to count
     *   }
     * })
    **/
    count<T extends MatrixSyncStatusCountArgs>(
      args?: Subset<T, MatrixSyncStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatrixSyncStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatrixSyncStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixSyncStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatrixSyncStatusAggregateArgs>(args: Subset<T, MatrixSyncStatusAggregateArgs>): Prisma.PrismaPromise<GetMatrixSyncStatusAggregateType<T>>

    /**
     * Group by MatrixSyncStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixSyncStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatrixSyncStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatrixSyncStatusGroupByArgs['orderBy'] }
        : { orderBy?: MatrixSyncStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatrixSyncStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatrixSyncStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatrixSyncStatus model
   */
  readonly fields: MatrixSyncStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatrixSyncStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatrixSyncStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatrixSyncStatus model
   */
  interface MatrixSyncStatusFieldRefs {
    readonly id: FieldRef<"MatrixSyncStatus", 'Int'>
    readonly syncType: FieldRef<"MatrixSyncStatus", 'String'>
    readonly status: FieldRef<"MatrixSyncStatus", 'String'>
    readonly lastSync: FieldRef<"MatrixSyncStatus", 'DateTime'>
    readonly totalItems: FieldRef<"MatrixSyncStatus", 'Int'>
    readonly processedItems: FieldRef<"MatrixSyncStatus", 'Int'>
    readonly errorMessage: FieldRef<"MatrixSyncStatus", 'String'>
    readonly syncDurationSeconds: FieldRef<"MatrixSyncStatus", 'Int'>
    readonly createdAt: FieldRef<"MatrixSyncStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"MatrixSyncStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatrixSyncStatus findUnique
   */
  export type MatrixSyncStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixSyncStatus
     */
    select?: MatrixSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixSyncStatus
     */
    omit?: MatrixSyncStatusOmit<ExtArgs> | null
    /**
     * Filter, which MatrixSyncStatus to fetch.
     */
    where: MatrixSyncStatusWhereUniqueInput
  }

  /**
   * MatrixSyncStatus findUniqueOrThrow
   */
  export type MatrixSyncStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixSyncStatus
     */
    select?: MatrixSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixSyncStatus
     */
    omit?: MatrixSyncStatusOmit<ExtArgs> | null
    /**
     * Filter, which MatrixSyncStatus to fetch.
     */
    where: MatrixSyncStatusWhereUniqueInput
  }

  /**
   * MatrixSyncStatus findFirst
   */
  export type MatrixSyncStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixSyncStatus
     */
    select?: MatrixSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixSyncStatus
     */
    omit?: MatrixSyncStatusOmit<ExtArgs> | null
    /**
     * Filter, which MatrixSyncStatus to fetch.
     */
    where?: MatrixSyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixSyncStatuses to fetch.
     */
    orderBy?: MatrixSyncStatusOrderByWithRelationInput | MatrixSyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrixSyncStatuses.
     */
    cursor?: MatrixSyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixSyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixSyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrixSyncStatuses.
     */
    distinct?: MatrixSyncStatusScalarFieldEnum | MatrixSyncStatusScalarFieldEnum[]
  }

  /**
   * MatrixSyncStatus findFirstOrThrow
   */
  export type MatrixSyncStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixSyncStatus
     */
    select?: MatrixSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixSyncStatus
     */
    omit?: MatrixSyncStatusOmit<ExtArgs> | null
    /**
     * Filter, which MatrixSyncStatus to fetch.
     */
    where?: MatrixSyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixSyncStatuses to fetch.
     */
    orderBy?: MatrixSyncStatusOrderByWithRelationInput | MatrixSyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrixSyncStatuses.
     */
    cursor?: MatrixSyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixSyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixSyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrixSyncStatuses.
     */
    distinct?: MatrixSyncStatusScalarFieldEnum | MatrixSyncStatusScalarFieldEnum[]
  }

  /**
   * MatrixSyncStatus findMany
   */
  export type MatrixSyncStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixSyncStatus
     */
    select?: MatrixSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixSyncStatus
     */
    omit?: MatrixSyncStatusOmit<ExtArgs> | null
    /**
     * Filter, which MatrixSyncStatuses to fetch.
     */
    where?: MatrixSyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixSyncStatuses to fetch.
     */
    orderBy?: MatrixSyncStatusOrderByWithRelationInput | MatrixSyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatrixSyncStatuses.
     */
    cursor?: MatrixSyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixSyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixSyncStatuses.
     */
    skip?: number
    distinct?: MatrixSyncStatusScalarFieldEnum | MatrixSyncStatusScalarFieldEnum[]
  }

  /**
   * MatrixSyncStatus create
   */
  export type MatrixSyncStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixSyncStatus
     */
    select?: MatrixSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixSyncStatus
     */
    omit?: MatrixSyncStatusOmit<ExtArgs> | null
    /**
     * The data needed to create a MatrixSyncStatus.
     */
    data: XOR<MatrixSyncStatusCreateInput, MatrixSyncStatusUncheckedCreateInput>
  }

  /**
   * MatrixSyncStatus createMany
   */
  export type MatrixSyncStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatrixSyncStatuses.
     */
    data: MatrixSyncStatusCreateManyInput | MatrixSyncStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrixSyncStatus createManyAndReturn
   */
  export type MatrixSyncStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixSyncStatus
     */
    select?: MatrixSyncStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixSyncStatus
     */
    omit?: MatrixSyncStatusOmit<ExtArgs> | null
    /**
     * The data used to create many MatrixSyncStatuses.
     */
    data: MatrixSyncStatusCreateManyInput | MatrixSyncStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrixSyncStatus update
   */
  export type MatrixSyncStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixSyncStatus
     */
    select?: MatrixSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixSyncStatus
     */
    omit?: MatrixSyncStatusOmit<ExtArgs> | null
    /**
     * The data needed to update a MatrixSyncStatus.
     */
    data: XOR<MatrixSyncStatusUpdateInput, MatrixSyncStatusUncheckedUpdateInput>
    /**
     * Choose, which MatrixSyncStatus to update.
     */
    where: MatrixSyncStatusWhereUniqueInput
  }

  /**
   * MatrixSyncStatus updateMany
   */
  export type MatrixSyncStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatrixSyncStatuses.
     */
    data: XOR<MatrixSyncStatusUpdateManyMutationInput, MatrixSyncStatusUncheckedUpdateManyInput>
    /**
     * Filter which MatrixSyncStatuses to update
     */
    where?: MatrixSyncStatusWhereInput
    /**
     * Limit how many MatrixSyncStatuses to update.
     */
    limit?: number
  }

  /**
   * MatrixSyncStatus updateManyAndReturn
   */
  export type MatrixSyncStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixSyncStatus
     */
    select?: MatrixSyncStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixSyncStatus
     */
    omit?: MatrixSyncStatusOmit<ExtArgs> | null
    /**
     * The data used to update MatrixSyncStatuses.
     */
    data: XOR<MatrixSyncStatusUpdateManyMutationInput, MatrixSyncStatusUncheckedUpdateManyInput>
    /**
     * Filter which MatrixSyncStatuses to update
     */
    where?: MatrixSyncStatusWhereInput
    /**
     * Limit how many MatrixSyncStatuses to update.
     */
    limit?: number
  }

  /**
   * MatrixSyncStatus upsert
   */
  export type MatrixSyncStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixSyncStatus
     */
    select?: MatrixSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixSyncStatus
     */
    omit?: MatrixSyncStatusOmit<ExtArgs> | null
    /**
     * The filter to search for the MatrixSyncStatus to update in case it exists.
     */
    where: MatrixSyncStatusWhereUniqueInput
    /**
     * In case the MatrixSyncStatus found by the `where` argument doesn't exist, create a new MatrixSyncStatus with this data.
     */
    create: XOR<MatrixSyncStatusCreateInput, MatrixSyncStatusUncheckedCreateInput>
    /**
     * In case the MatrixSyncStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatrixSyncStatusUpdateInput, MatrixSyncStatusUncheckedUpdateInput>
  }

  /**
   * MatrixSyncStatus delete
   */
  export type MatrixSyncStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixSyncStatus
     */
    select?: MatrixSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixSyncStatus
     */
    omit?: MatrixSyncStatusOmit<ExtArgs> | null
    /**
     * Filter which MatrixSyncStatus to delete.
     */
    where: MatrixSyncStatusWhereUniqueInput
  }

  /**
   * MatrixSyncStatus deleteMany
   */
  export type MatrixSyncStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrixSyncStatuses to delete
     */
    where?: MatrixSyncStatusWhereInput
    /**
     * Limit how many MatrixSyncStatuses to delete.
     */
    limit?: number
  }

  /**
   * MatrixSyncStatus without action
   */
  export type MatrixSyncStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixSyncStatus
     */
    select?: MatrixSyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixSyncStatus
     */
    omit?: MatrixSyncStatusOmit<ExtArgs> | null
  }


  /**
   * Model MatrixUserCache
   */

  export type AggregateMatrixUserCache = {
    _count: MatrixUserCacheCountAggregateOutputType | null
    _avg: MatrixUserCacheAvgAggregateOutputType | null
    _sum: MatrixUserCacheSumAggregateOutputType | null
    _min: MatrixUserCacheMinAggregateOutputType | null
    _max: MatrixUserCacheMaxAggregateOutputType | null
  }

  export type MatrixUserCacheAvgAggregateOutputType = {
    roomCount: number | null
  }

  export type MatrixUserCacheSumAggregateOutputType = {
    roomCount: number | null
  }

  export type MatrixUserCacheMinAggregateOutputType = {
    userId: string | null
    displayName: string | null
    avatarUrl: string | null
    isSignalUser: boolean | null
    roomCount: number | null
    lastActivity: Date | null
    cacheUpdated: Date | null
  }

  export type MatrixUserCacheMaxAggregateOutputType = {
    userId: string | null
    displayName: string | null
    avatarUrl: string | null
    isSignalUser: boolean | null
    roomCount: number | null
    lastActivity: Date | null
    cacheUpdated: Date | null
  }

  export type MatrixUserCacheCountAggregateOutputType = {
    userId: number
    displayName: number
    avatarUrl: number
    isSignalUser: number
    roomCount: number
    lastActivity: number
    cacheUpdated: number
    _all: number
  }


  export type MatrixUserCacheAvgAggregateInputType = {
    roomCount?: true
  }

  export type MatrixUserCacheSumAggregateInputType = {
    roomCount?: true
  }

  export type MatrixUserCacheMinAggregateInputType = {
    userId?: true
    displayName?: true
    avatarUrl?: true
    isSignalUser?: true
    roomCount?: true
    lastActivity?: true
    cacheUpdated?: true
  }

  export type MatrixUserCacheMaxAggregateInputType = {
    userId?: true
    displayName?: true
    avatarUrl?: true
    isSignalUser?: true
    roomCount?: true
    lastActivity?: true
    cacheUpdated?: true
  }

  export type MatrixUserCacheCountAggregateInputType = {
    userId?: true
    displayName?: true
    avatarUrl?: true
    isSignalUser?: true
    roomCount?: true
    lastActivity?: true
    cacheUpdated?: true
    _all?: true
  }

  export type MatrixUserCacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrixUserCache to aggregate.
     */
    where?: MatrixUserCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixUserCaches to fetch.
     */
    orderBy?: MatrixUserCacheOrderByWithRelationInput | MatrixUserCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatrixUserCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixUserCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixUserCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatrixUserCaches
    **/
    _count?: true | MatrixUserCacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatrixUserCacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatrixUserCacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatrixUserCacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatrixUserCacheMaxAggregateInputType
  }

  export type GetMatrixUserCacheAggregateType<T extends MatrixUserCacheAggregateArgs> = {
        [P in keyof T & keyof AggregateMatrixUserCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatrixUserCache[P]>
      : GetScalarType<T[P], AggregateMatrixUserCache[P]>
  }




  export type MatrixUserCacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatrixUserCacheWhereInput
    orderBy?: MatrixUserCacheOrderByWithAggregationInput | MatrixUserCacheOrderByWithAggregationInput[]
    by: MatrixUserCacheScalarFieldEnum[] | MatrixUserCacheScalarFieldEnum
    having?: MatrixUserCacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatrixUserCacheCountAggregateInputType | true
    _avg?: MatrixUserCacheAvgAggregateInputType
    _sum?: MatrixUserCacheSumAggregateInputType
    _min?: MatrixUserCacheMinAggregateInputType
    _max?: MatrixUserCacheMaxAggregateInputType
  }

  export type MatrixUserCacheGroupByOutputType = {
    userId: string
    displayName: string | null
    avatarUrl: string | null
    isSignalUser: boolean
    roomCount: number
    lastActivity: Date | null
    cacheUpdated: Date
    _count: MatrixUserCacheCountAggregateOutputType | null
    _avg: MatrixUserCacheAvgAggregateOutputType | null
    _sum: MatrixUserCacheSumAggregateOutputType | null
    _min: MatrixUserCacheMinAggregateOutputType | null
    _max: MatrixUserCacheMaxAggregateOutputType | null
  }

  type GetMatrixUserCacheGroupByPayload<T extends MatrixUserCacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatrixUserCacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatrixUserCacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatrixUserCacheGroupByOutputType[P]>
            : GetScalarType<T[P], MatrixUserCacheGroupByOutputType[P]>
        }
      >
    >


  export type MatrixUserCacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    isSignalUser?: boolean
    roomCount?: boolean
    lastActivity?: boolean
    cacheUpdated?: boolean
  }, ExtArgs["result"]["matrixUserCache"]>

  export type MatrixUserCacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    isSignalUser?: boolean
    roomCount?: boolean
    lastActivity?: boolean
    cacheUpdated?: boolean
  }, ExtArgs["result"]["matrixUserCache"]>

  export type MatrixUserCacheSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    isSignalUser?: boolean
    roomCount?: boolean
    lastActivity?: boolean
    cacheUpdated?: boolean
  }, ExtArgs["result"]["matrixUserCache"]>

  export type MatrixUserCacheSelectScalar = {
    userId?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    isSignalUser?: boolean
    roomCount?: boolean
    lastActivity?: boolean
    cacheUpdated?: boolean
  }

  export type MatrixUserCacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "displayName" | "avatarUrl" | "isSignalUser" | "roomCount" | "lastActivity" | "cacheUpdated", ExtArgs["result"]["matrixUserCache"]>

  export type $MatrixUserCachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatrixUserCache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      displayName: string | null
      avatarUrl: string | null
      isSignalUser: boolean
      roomCount: number
      lastActivity: Date | null
      cacheUpdated: Date
    }, ExtArgs["result"]["matrixUserCache"]>
    composites: {}
  }

  type MatrixUserCacheGetPayload<S extends boolean | null | undefined | MatrixUserCacheDefaultArgs> = $Result.GetResult<Prisma.$MatrixUserCachePayload, S>

  type MatrixUserCacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatrixUserCacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatrixUserCacheCountAggregateInputType | true
    }

  export interface MatrixUserCacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatrixUserCache'], meta: { name: 'MatrixUserCache' } }
    /**
     * Find zero or one MatrixUserCache that matches the filter.
     * @param {MatrixUserCacheFindUniqueArgs} args - Arguments to find a MatrixUserCache
     * @example
     * // Get one MatrixUserCache
     * const matrixUserCache = await prisma.matrixUserCache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatrixUserCacheFindUniqueArgs>(args: SelectSubset<T, MatrixUserCacheFindUniqueArgs<ExtArgs>>): Prisma__MatrixUserCacheClient<$Result.GetResult<Prisma.$MatrixUserCachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatrixUserCache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatrixUserCacheFindUniqueOrThrowArgs} args - Arguments to find a MatrixUserCache
     * @example
     * // Get one MatrixUserCache
     * const matrixUserCache = await prisma.matrixUserCache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatrixUserCacheFindUniqueOrThrowArgs>(args: SelectSubset<T, MatrixUserCacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatrixUserCacheClient<$Result.GetResult<Prisma.$MatrixUserCachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatrixUserCache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserCacheFindFirstArgs} args - Arguments to find a MatrixUserCache
     * @example
     * // Get one MatrixUserCache
     * const matrixUserCache = await prisma.matrixUserCache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatrixUserCacheFindFirstArgs>(args?: SelectSubset<T, MatrixUserCacheFindFirstArgs<ExtArgs>>): Prisma__MatrixUserCacheClient<$Result.GetResult<Prisma.$MatrixUserCachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatrixUserCache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserCacheFindFirstOrThrowArgs} args - Arguments to find a MatrixUserCache
     * @example
     * // Get one MatrixUserCache
     * const matrixUserCache = await prisma.matrixUserCache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatrixUserCacheFindFirstOrThrowArgs>(args?: SelectSubset<T, MatrixUserCacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatrixUserCacheClient<$Result.GetResult<Prisma.$MatrixUserCachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatrixUserCaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserCacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatrixUserCaches
     * const matrixUserCaches = await prisma.matrixUserCache.findMany()
     * 
     * // Get first 10 MatrixUserCaches
     * const matrixUserCaches = await prisma.matrixUserCache.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const matrixUserCacheWithUserIdOnly = await prisma.matrixUserCache.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends MatrixUserCacheFindManyArgs>(args?: SelectSubset<T, MatrixUserCacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixUserCachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatrixUserCache.
     * @param {MatrixUserCacheCreateArgs} args - Arguments to create a MatrixUserCache.
     * @example
     * // Create one MatrixUserCache
     * const MatrixUserCache = await prisma.matrixUserCache.create({
     *   data: {
     *     // ... data to create a MatrixUserCache
     *   }
     * })
     * 
     */
    create<T extends MatrixUserCacheCreateArgs>(args: SelectSubset<T, MatrixUserCacheCreateArgs<ExtArgs>>): Prisma__MatrixUserCacheClient<$Result.GetResult<Prisma.$MatrixUserCachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatrixUserCaches.
     * @param {MatrixUserCacheCreateManyArgs} args - Arguments to create many MatrixUserCaches.
     * @example
     * // Create many MatrixUserCaches
     * const matrixUserCache = await prisma.matrixUserCache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatrixUserCacheCreateManyArgs>(args?: SelectSubset<T, MatrixUserCacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatrixUserCaches and returns the data saved in the database.
     * @param {MatrixUserCacheCreateManyAndReturnArgs} args - Arguments to create many MatrixUserCaches.
     * @example
     * // Create many MatrixUserCaches
     * const matrixUserCache = await prisma.matrixUserCache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatrixUserCaches and only return the `userId`
     * const matrixUserCacheWithUserIdOnly = await prisma.matrixUserCache.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatrixUserCacheCreateManyAndReturnArgs>(args?: SelectSubset<T, MatrixUserCacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixUserCachePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatrixUserCache.
     * @param {MatrixUserCacheDeleteArgs} args - Arguments to delete one MatrixUserCache.
     * @example
     * // Delete one MatrixUserCache
     * const MatrixUserCache = await prisma.matrixUserCache.delete({
     *   where: {
     *     // ... filter to delete one MatrixUserCache
     *   }
     * })
     * 
     */
    delete<T extends MatrixUserCacheDeleteArgs>(args: SelectSubset<T, MatrixUserCacheDeleteArgs<ExtArgs>>): Prisma__MatrixUserCacheClient<$Result.GetResult<Prisma.$MatrixUserCachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatrixUserCache.
     * @param {MatrixUserCacheUpdateArgs} args - Arguments to update one MatrixUserCache.
     * @example
     * // Update one MatrixUserCache
     * const matrixUserCache = await prisma.matrixUserCache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatrixUserCacheUpdateArgs>(args: SelectSubset<T, MatrixUserCacheUpdateArgs<ExtArgs>>): Prisma__MatrixUserCacheClient<$Result.GetResult<Prisma.$MatrixUserCachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatrixUserCaches.
     * @param {MatrixUserCacheDeleteManyArgs} args - Arguments to filter MatrixUserCaches to delete.
     * @example
     * // Delete a few MatrixUserCaches
     * const { count } = await prisma.matrixUserCache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatrixUserCacheDeleteManyArgs>(args?: SelectSubset<T, MatrixUserCacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrixUserCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserCacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatrixUserCaches
     * const matrixUserCache = await prisma.matrixUserCache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatrixUserCacheUpdateManyArgs>(args: SelectSubset<T, MatrixUserCacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatrixUserCaches and returns the data updated in the database.
     * @param {MatrixUserCacheUpdateManyAndReturnArgs} args - Arguments to update many MatrixUserCaches.
     * @example
     * // Update many MatrixUserCaches
     * const matrixUserCache = await prisma.matrixUserCache.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatrixUserCaches and only return the `userId`
     * const matrixUserCacheWithUserIdOnly = await prisma.matrixUserCache.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatrixUserCacheUpdateManyAndReturnArgs>(args: SelectSubset<T, MatrixUserCacheUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatrixUserCachePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatrixUserCache.
     * @param {MatrixUserCacheUpsertArgs} args - Arguments to update or create a MatrixUserCache.
     * @example
     * // Update or create a MatrixUserCache
     * const matrixUserCache = await prisma.matrixUserCache.upsert({
     *   create: {
     *     // ... data to create a MatrixUserCache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatrixUserCache we want to update
     *   }
     * })
     */
    upsert<T extends MatrixUserCacheUpsertArgs>(args: SelectSubset<T, MatrixUserCacheUpsertArgs<ExtArgs>>): Prisma__MatrixUserCacheClient<$Result.GetResult<Prisma.$MatrixUserCachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatrixUserCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserCacheCountArgs} args - Arguments to filter MatrixUserCaches to count.
     * @example
     * // Count the number of MatrixUserCaches
     * const count = await prisma.matrixUserCache.count({
     *   where: {
     *     // ... the filter for the MatrixUserCaches we want to count
     *   }
     * })
    **/
    count<T extends MatrixUserCacheCountArgs>(
      args?: Subset<T, MatrixUserCacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatrixUserCacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatrixUserCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserCacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatrixUserCacheAggregateArgs>(args: Subset<T, MatrixUserCacheAggregateArgs>): Prisma.PrismaPromise<GetMatrixUserCacheAggregateType<T>>

    /**
     * Group by MatrixUserCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatrixUserCacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatrixUserCacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatrixUserCacheGroupByArgs['orderBy'] }
        : { orderBy?: MatrixUserCacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatrixUserCacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatrixUserCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatrixUserCache model
   */
  readonly fields: MatrixUserCacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatrixUserCache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatrixUserCacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatrixUserCache model
   */
  interface MatrixUserCacheFieldRefs {
    readonly userId: FieldRef<"MatrixUserCache", 'String'>
    readonly displayName: FieldRef<"MatrixUserCache", 'String'>
    readonly avatarUrl: FieldRef<"MatrixUserCache", 'String'>
    readonly isSignalUser: FieldRef<"MatrixUserCache", 'Boolean'>
    readonly roomCount: FieldRef<"MatrixUserCache", 'Int'>
    readonly lastActivity: FieldRef<"MatrixUserCache", 'DateTime'>
    readonly cacheUpdated: FieldRef<"MatrixUserCache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatrixUserCache findUnique
   */
  export type MatrixUserCacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCache
     */
    select?: MatrixUserCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUserCache
     */
    omit?: MatrixUserCacheOmit<ExtArgs> | null
    /**
     * Filter, which MatrixUserCache to fetch.
     */
    where: MatrixUserCacheWhereUniqueInput
  }

  /**
   * MatrixUserCache findUniqueOrThrow
   */
  export type MatrixUserCacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCache
     */
    select?: MatrixUserCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUserCache
     */
    omit?: MatrixUserCacheOmit<ExtArgs> | null
    /**
     * Filter, which MatrixUserCache to fetch.
     */
    where: MatrixUserCacheWhereUniqueInput
  }

  /**
   * MatrixUserCache findFirst
   */
  export type MatrixUserCacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCache
     */
    select?: MatrixUserCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUserCache
     */
    omit?: MatrixUserCacheOmit<ExtArgs> | null
    /**
     * Filter, which MatrixUserCache to fetch.
     */
    where?: MatrixUserCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixUserCaches to fetch.
     */
    orderBy?: MatrixUserCacheOrderByWithRelationInput | MatrixUserCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrixUserCaches.
     */
    cursor?: MatrixUserCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixUserCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixUserCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrixUserCaches.
     */
    distinct?: MatrixUserCacheScalarFieldEnum | MatrixUserCacheScalarFieldEnum[]
  }

  /**
   * MatrixUserCache findFirstOrThrow
   */
  export type MatrixUserCacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCache
     */
    select?: MatrixUserCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUserCache
     */
    omit?: MatrixUserCacheOmit<ExtArgs> | null
    /**
     * Filter, which MatrixUserCache to fetch.
     */
    where?: MatrixUserCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixUserCaches to fetch.
     */
    orderBy?: MatrixUserCacheOrderByWithRelationInput | MatrixUserCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatrixUserCaches.
     */
    cursor?: MatrixUserCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixUserCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixUserCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatrixUserCaches.
     */
    distinct?: MatrixUserCacheScalarFieldEnum | MatrixUserCacheScalarFieldEnum[]
  }

  /**
   * MatrixUserCache findMany
   */
  export type MatrixUserCacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCache
     */
    select?: MatrixUserCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUserCache
     */
    omit?: MatrixUserCacheOmit<ExtArgs> | null
    /**
     * Filter, which MatrixUserCaches to fetch.
     */
    where?: MatrixUserCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatrixUserCaches to fetch.
     */
    orderBy?: MatrixUserCacheOrderByWithRelationInput | MatrixUserCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatrixUserCaches.
     */
    cursor?: MatrixUserCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatrixUserCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatrixUserCaches.
     */
    skip?: number
    distinct?: MatrixUserCacheScalarFieldEnum | MatrixUserCacheScalarFieldEnum[]
  }

  /**
   * MatrixUserCache create
   */
  export type MatrixUserCacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCache
     */
    select?: MatrixUserCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUserCache
     */
    omit?: MatrixUserCacheOmit<ExtArgs> | null
    /**
     * The data needed to create a MatrixUserCache.
     */
    data: XOR<MatrixUserCacheCreateInput, MatrixUserCacheUncheckedCreateInput>
  }

  /**
   * MatrixUserCache createMany
   */
  export type MatrixUserCacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatrixUserCaches.
     */
    data: MatrixUserCacheCreateManyInput | MatrixUserCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrixUserCache createManyAndReturn
   */
  export type MatrixUserCacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCache
     */
    select?: MatrixUserCacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUserCache
     */
    omit?: MatrixUserCacheOmit<ExtArgs> | null
    /**
     * The data used to create many MatrixUserCaches.
     */
    data: MatrixUserCacheCreateManyInput | MatrixUserCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatrixUserCache update
   */
  export type MatrixUserCacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCache
     */
    select?: MatrixUserCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUserCache
     */
    omit?: MatrixUserCacheOmit<ExtArgs> | null
    /**
     * The data needed to update a MatrixUserCache.
     */
    data: XOR<MatrixUserCacheUpdateInput, MatrixUserCacheUncheckedUpdateInput>
    /**
     * Choose, which MatrixUserCache to update.
     */
    where: MatrixUserCacheWhereUniqueInput
  }

  /**
   * MatrixUserCache updateMany
   */
  export type MatrixUserCacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatrixUserCaches.
     */
    data: XOR<MatrixUserCacheUpdateManyMutationInput, MatrixUserCacheUncheckedUpdateManyInput>
    /**
     * Filter which MatrixUserCaches to update
     */
    where?: MatrixUserCacheWhereInput
    /**
     * Limit how many MatrixUserCaches to update.
     */
    limit?: number
  }

  /**
   * MatrixUserCache updateManyAndReturn
   */
  export type MatrixUserCacheUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCache
     */
    select?: MatrixUserCacheSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUserCache
     */
    omit?: MatrixUserCacheOmit<ExtArgs> | null
    /**
     * The data used to update MatrixUserCaches.
     */
    data: XOR<MatrixUserCacheUpdateManyMutationInput, MatrixUserCacheUncheckedUpdateManyInput>
    /**
     * Filter which MatrixUserCaches to update
     */
    where?: MatrixUserCacheWhereInput
    /**
     * Limit how many MatrixUserCaches to update.
     */
    limit?: number
  }

  /**
   * MatrixUserCache upsert
   */
  export type MatrixUserCacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCache
     */
    select?: MatrixUserCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUserCache
     */
    omit?: MatrixUserCacheOmit<ExtArgs> | null
    /**
     * The filter to search for the MatrixUserCache to update in case it exists.
     */
    where: MatrixUserCacheWhereUniqueInput
    /**
     * In case the MatrixUserCache found by the `where` argument doesn't exist, create a new MatrixUserCache with this data.
     */
    create: XOR<MatrixUserCacheCreateInput, MatrixUserCacheUncheckedCreateInput>
    /**
     * In case the MatrixUserCache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatrixUserCacheUpdateInput, MatrixUserCacheUncheckedUpdateInput>
  }

  /**
   * MatrixUserCache delete
   */
  export type MatrixUserCacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCache
     */
    select?: MatrixUserCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUserCache
     */
    omit?: MatrixUserCacheOmit<ExtArgs> | null
    /**
     * Filter which MatrixUserCache to delete.
     */
    where: MatrixUserCacheWhereUniqueInput
  }

  /**
   * MatrixUserCache deleteMany
   */
  export type MatrixUserCacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatrixUserCaches to delete
     */
    where?: MatrixUserCacheWhereInput
    /**
     * Limit how many MatrixUserCaches to delete.
     */
    limit?: number
  }

  /**
   * MatrixUserCache without action
   */
  export type MatrixUserCacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatrixUserCache
     */
    select?: MatrixUserCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatrixUserCache
     */
    omit?: MatrixUserCacheOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    password: 'password',
    isActive: 'isActive',
    isAdmin: 'isAdmin',
    isModerator: 'isModerator',
    dateJoined: 'dateJoined',
    lastLogin: 'lastLogin',
    attributes: 'attributes',
    authentikId: 'authentikId',
    signalIdentity: 'signalIdentity',
    matrixUsername: 'matrixUsername'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    username: 'username',
    details: 'details',
    timestamp: 'timestamp'
  };

  export type AdminEventScalarFieldEnum = (typeof AdminEventScalarFieldEnum)[keyof typeof AdminEventScalarFieldEnum]


  export const DashboardSettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DashboardSettingsScalarFieldEnum = (typeof DashboardSettingsScalarFieldEnum)[keyof typeof DashboardSettingsScalarFieldEnum]


  export const CommunityBookmarkScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    url: 'url',
    icon: 'icon',
    category: 'category',
    order: 'order',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunityBookmarkScalarFieldEnum = (typeof CommunityBookmarkScalarFieldEnum)[keyof typeof CommunityBookmarkScalarFieldEnum]


  export const DashboardAnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    type: 'type',
    isActive: 'isActive',
    priority: 'priority',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type DashboardAnnouncementScalarFieldEnum = (typeof DashboardAnnouncementScalarFieldEnum)[keyof typeof DashboardAnnouncementScalarFieldEnum]


  export const UserInvitationScalarFieldEnum: {
    id: 'id',
    inviterUserId: 'inviterUserId',
    inviteeEmail: 'inviteeEmail',
    inviteeName: 'inviteeName',
    inviteePhone: 'inviteePhone',
    roomIds: 'roomIds',
    status: 'status',
    inviteToken: 'inviteToken',
    message: 'message',
    expiresAt: 'expiresAt',
    acceptedAt: 'acceptedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserInvitationScalarFieldEnum = (typeof UserInvitationScalarFieldEnum)[keyof typeof UserInvitationScalarFieldEnum]


  export const CommunityEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    username: 'username',
    details: 'details',
    timestamp: 'timestamp',
    isPublic: 'isPublic',
    category: 'category'
  };

  export type CommunityEventScalarFieldEnum = (typeof CommunityEventScalarFieldEnum)[keyof typeof CommunityEventScalarFieldEnum]


  export const VerificationCodeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    code: 'code',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type VerificationCodeScalarFieldEnum = (typeof VerificationCodeScalarFieldEnum)[keyof typeof VerificationCodeScalarFieldEnum]


  export const MatrixRoomMemberScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    userId: 'userId',
    displayName: 'displayName',
    avatarUrl: 'avatarUrl',
    membership: 'membership',
    lastUpdated: 'lastUpdated'
  };

  export type MatrixRoomMemberScalarFieldEnum = (typeof MatrixRoomMemberScalarFieldEnum)[keyof typeof MatrixRoomMemberScalarFieldEnum]


  export const UserNoteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    lastEditedBy: 'lastEditedBy'
  };

  export type UserNoteScalarFieldEnum = (typeof UserNoteScalarFieldEnum)[keyof typeof UserNoteScalarFieldEnum]


  export const InviteScalarFieldEnum: {
    id: 'id',
    token: 'token',
    label: 'label',
    email: 'email',
    name: 'name',
    groups: 'groups',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    createdBy: 'createdBy',
    isUsed: 'isUsed',
    usedBy: 'usedBy',
    usedAt: 'usedAt'
  };

  export type InviteScalarFieldEnum = (typeof InviteScalarFieldEnum)[keyof typeof InviteScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    authentikGroupId: 'authentikGroupId'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const UserGroupScalarFieldEnum: {
    userId: 'userId',
    groupId: 'groupId'
  };

  export type UserGroupScalarFieldEnum = (typeof UserGroupScalarFieldEnum)[keyof typeof UserGroupScalarFieldEnum]


  export const ModeratorPermissionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    permissionType: 'permissionType',
    permissionValue: 'permissionValue',
    createdAt: 'createdAt',
    createdBy: 'createdBy'
  };

  export type ModeratorPermissionScalarFieldEnum = (typeof ModeratorPermissionScalarFieldEnum)[keyof typeof ModeratorPermissionScalarFieldEnum]


  export const MatrixUserScalarFieldEnum: {
    userId: 'userId',
    displayName: 'displayName',
    avatarUrl: 'avatarUrl',
    isSignalUser: 'isSignalUser',
    lastSeen: 'lastSeen',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatrixUserScalarFieldEnum = (typeof MatrixUserScalarFieldEnum)[keyof typeof MatrixUserScalarFieldEnum]


  export const MatrixRoomScalarFieldEnum: {
    roomId: 'roomId',
    name: 'name',
    displayName: 'displayName',
    topic: 'topic',
    canonicalAlias: 'canonicalAlias',
    memberCount: 'memberCount',
    roomType: 'roomType',
    isDirect: 'isDirect',
    isEncrypted: 'isEncrypted',
    lastSynced: 'lastSynced',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatrixRoomScalarFieldEnum = (typeof MatrixRoomScalarFieldEnum)[keyof typeof MatrixRoomScalarFieldEnum]


  export const MatrixRoomMembershipScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    userId: 'userId',
    membershipStatus: 'membershipStatus',
    joinedAt: 'joinedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatrixRoomMembershipScalarFieldEnum = (typeof MatrixRoomMembershipScalarFieldEnum)[keyof typeof MatrixRoomMembershipScalarFieldEnum]


  export const MatrixSyncStatusScalarFieldEnum: {
    id: 'id',
    syncType: 'syncType',
    status: 'status',
    lastSync: 'lastSync',
    totalItems: 'totalItems',
    processedItems: 'processedItems',
    errorMessage: 'errorMessage',
    syncDurationSeconds: 'syncDurationSeconds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MatrixSyncStatusScalarFieldEnum = (typeof MatrixSyncStatusScalarFieldEnum)[keyof typeof MatrixSyncStatusScalarFieldEnum]


  export const MatrixUserCacheScalarFieldEnum: {
    userId: 'userId',
    displayName: 'displayName',
    avatarUrl: 'avatarUrl',
    isSignalUser: 'isSignalUser',
    roomCount: 'roomCount',
    lastActivity: 'lastActivity',
    cacheUpdated: 'cacheUpdated'
  };

  export type MatrixUserCacheScalarFieldEnum = (typeof MatrixUserCacheScalarFieldEnum)[keyof typeof MatrixUserCacheScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    isAdmin?: BoolFilter<"User"> | boolean
    isModerator?: BoolFilter<"User"> | boolean
    dateJoined?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    attributes?: JsonNullableFilter<"User">
    authentikId?: StringNullableFilter<"User"> | string | null
    signalIdentity?: StringNullableFilter<"User"> | string | null
    matrixUsername?: StringNullableFilter<"User"> | string | null
    notes?: UserNoteListRelationFilter
    groups?: UserGroupListRelationFilter
    moderatorPermissions?: ModeratorPermissionListRelationFilter
    sentInvitations?: UserInvitationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isAdmin?: SortOrder
    isModerator?: SortOrder
    dateJoined?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    authentikId?: SortOrderInput | SortOrder
    signalIdentity?: SortOrderInput | SortOrder
    matrixUsername?: SortOrderInput | SortOrder
    notes?: UserNoteOrderByRelationAggregateInput
    groups?: UserGroupOrderByRelationAggregateInput
    moderatorPermissions?: ModeratorPermissionOrderByRelationAggregateInput
    sentInvitations?: UserInvitationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    authentikId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    email?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    isAdmin?: BoolFilter<"User"> | boolean
    isModerator?: BoolFilter<"User"> | boolean
    dateJoined?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    attributes?: JsonNullableFilter<"User">
    signalIdentity?: StringNullableFilter<"User"> | string | null
    matrixUsername?: StringNullableFilter<"User"> | string | null
    notes?: UserNoteListRelationFilter
    groups?: UserGroupListRelationFilter
    moderatorPermissions?: ModeratorPermissionListRelationFilter
    sentInvitations?: UserInvitationListRelationFilter
  }, "id" | "username" | "authentikId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isAdmin?: SortOrder
    isModerator?: SortOrder
    dateJoined?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    authentikId?: SortOrderInput | SortOrder
    signalIdentity?: SortOrderInput | SortOrder
    matrixUsername?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    isModerator?: BoolWithAggregatesFilter<"User"> | boolean
    dateJoined?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    attributes?: JsonNullableWithAggregatesFilter<"User">
    authentikId?: StringNullableWithAggregatesFilter<"User"> | string | null
    signalIdentity?: StringNullableWithAggregatesFilter<"User"> | string | null
    matrixUsername?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AdminEventWhereInput = {
    AND?: AdminEventWhereInput | AdminEventWhereInput[]
    OR?: AdminEventWhereInput[]
    NOT?: AdminEventWhereInput | AdminEventWhereInput[]
    id?: IntFilter<"AdminEvent"> | number
    eventType?: StringFilter<"AdminEvent"> | string
    username?: StringNullableFilter<"AdminEvent"> | string | null
    details?: StringNullableFilter<"AdminEvent"> | string | null
    timestamp?: DateTimeFilter<"AdminEvent"> | Date | string
  }

  export type AdminEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    username?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type AdminEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdminEventWhereInput | AdminEventWhereInput[]
    OR?: AdminEventWhereInput[]
    NOT?: AdminEventWhereInput | AdminEventWhereInput[]
    eventType?: StringFilter<"AdminEvent"> | string
    username?: StringNullableFilter<"AdminEvent"> | string | null
    details?: StringNullableFilter<"AdminEvent"> | string | null
    timestamp?: DateTimeFilter<"AdminEvent"> | Date | string
  }, "id">

  export type AdminEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    username?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AdminEventCountOrderByAggregateInput
    _avg?: AdminEventAvgOrderByAggregateInput
    _max?: AdminEventMaxOrderByAggregateInput
    _min?: AdminEventMinOrderByAggregateInput
    _sum?: AdminEventSumOrderByAggregateInput
  }

  export type AdminEventScalarWhereWithAggregatesInput = {
    AND?: AdminEventScalarWhereWithAggregatesInput | AdminEventScalarWhereWithAggregatesInput[]
    OR?: AdminEventScalarWhereWithAggregatesInput[]
    NOT?: AdminEventScalarWhereWithAggregatesInput | AdminEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AdminEvent"> | number
    eventType?: StringWithAggregatesFilter<"AdminEvent"> | string
    username?: StringNullableWithAggregatesFilter<"AdminEvent"> | string | null
    details?: StringNullableWithAggregatesFilter<"AdminEvent"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AdminEvent"> | Date | string
  }

  export type DashboardSettingsWhereInput = {
    AND?: DashboardSettingsWhereInput | DashboardSettingsWhereInput[]
    OR?: DashboardSettingsWhereInput[]
    NOT?: DashboardSettingsWhereInput | DashboardSettingsWhereInput[]
    id?: IntFilter<"DashboardSettings"> | number
    key?: StringFilter<"DashboardSettings"> | string
    value?: JsonFilter<"DashboardSettings">
    createdAt?: DateTimeFilter<"DashboardSettings"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardSettings"> | Date | string
  }

  export type DashboardSettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: DashboardSettingsWhereInput | DashboardSettingsWhereInput[]
    OR?: DashboardSettingsWhereInput[]
    NOT?: DashboardSettingsWhereInput | DashboardSettingsWhereInput[]
    value?: JsonFilter<"DashboardSettings">
    createdAt?: DateTimeFilter<"DashboardSettings"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardSettings"> | Date | string
  }, "id" | "key">

  export type DashboardSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DashboardSettingsCountOrderByAggregateInput
    _avg?: DashboardSettingsAvgOrderByAggregateInput
    _max?: DashboardSettingsMaxOrderByAggregateInput
    _min?: DashboardSettingsMinOrderByAggregateInput
    _sum?: DashboardSettingsSumOrderByAggregateInput
  }

  export type DashboardSettingsScalarWhereWithAggregatesInput = {
    AND?: DashboardSettingsScalarWhereWithAggregatesInput | DashboardSettingsScalarWhereWithAggregatesInput[]
    OR?: DashboardSettingsScalarWhereWithAggregatesInput[]
    NOT?: DashboardSettingsScalarWhereWithAggregatesInput | DashboardSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DashboardSettings"> | number
    key?: StringWithAggregatesFilter<"DashboardSettings"> | string
    value?: JsonWithAggregatesFilter<"DashboardSettings">
    createdAt?: DateTimeWithAggregatesFilter<"DashboardSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DashboardSettings"> | Date | string
  }

  export type CommunityBookmarkWhereInput = {
    AND?: CommunityBookmarkWhereInput | CommunityBookmarkWhereInput[]
    OR?: CommunityBookmarkWhereInput[]
    NOT?: CommunityBookmarkWhereInput | CommunityBookmarkWhereInput[]
    id?: IntFilter<"CommunityBookmark"> | number
    title?: StringFilter<"CommunityBookmark"> | string
    description?: StringNullableFilter<"CommunityBookmark"> | string | null
    url?: StringFilter<"CommunityBookmark"> | string
    icon?: StringNullableFilter<"CommunityBookmark"> | string | null
    category?: StringFilter<"CommunityBookmark"> | string
    order?: IntFilter<"CommunityBookmark"> | number
    isActive?: BoolFilter<"CommunityBookmark"> | boolean
    createdAt?: DateTimeFilter<"CommunityBookmark"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityBookmark"> | Date | string
  }

  export type CommunityBookmarkOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityBookmarkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityBookmarkWhereInput | CommunityBookmarkWhereInput[]
    OR?: CommunityBookmarkWhereInput[]
    NOT?: CommunityBookmarkWhereInput | CommunityBookmarkWhereInput[]
    title?: StringFilter<"CommunityBookmark"> | string
    description?: StringNullableFilter<"CommunityBookmark"> | string | null
    url?: StringFilter<"CommunityBookmark"> | string
    icon?: StringNullableFilter<"CommunityBookmark"> | string | null
    category?: StringFilter<"CommunityBookmark"> | string
    order?: IntFilter<"CommunityBookmark"> | number
    isActive?: BoolFilter<"CommunityBookmark"> | boolean
    createdAt?: DateTimeFilter<"CommunityBookmark"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityBookmark"> | Date | string
  }, "id">

  export type CommunityBookmarkOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunityBookmarkCountOrderByAggregateInput
    _avg?: CommunityBookmarkAvgOrderByAggregateInput
    _max?: CommunityBookmarkMaxOrderByAggregateInput
    _min?: CommunityBookmarkMinOrderByAggregateInput
    _sum?: CommunityBookmarkSumOrderByAggregateInput
  }

  export type CommunityBookmarkScalarWhereWithAggregatesInput = {
    AND?: CommunityBookmarkScalarWhereWithAggregatesInput | CommunityBookmarkScalarWhereWithAggregatesInput[]
    OR?: CommunityBookmarkScalarWhereWithAggregatesInput[]
    NOT?: CommunityBookmarkScalarWhereWithAggregatesInput | CommunityBookmarkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommunityBookmark"> | number
    title?: StringWithAggregatesFilter<"CommunityBookmark"> | string
    description?: StringNullableWithAggregatesFilter<"CommunityBookmark"> | string | null
    url?: StringWithAggregatesFilter<"CommunityBookmark"> | string
    icon?: StringNullableWithAggregatesFilter<"CommunityBookmark"> | string | null
    category?: StringWithAggregatesFilter<"CommunityBookmark"> | string
    order?: IntWithAggregatesFilter<"CommunityBookmark"> | number
    isActive?: BoolWithAggregatesFilter<"CommunityBookmark"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CommunityBookmark"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommunityBookmark"> | Date | string
  }

  export type DashboardAnnouncementWhereInput = {
    AND?: DashboardAnnouncementWhereInput | DashboardAnnouncementWhereInput[]
    OR?: DashboardAnnouncementWhereInput[]
    NOT?: DashboardAnnouncementWhereInput | DashboardAnnouncementWhereInput[]
    id?: IntFilter<"DashboardAnnouncement"> | number
    title?: StringFilter<"DashboardAnnouncement"> | string
    content?: StringFilter<"DashboardAnnouncement"> | string
    type?: StringFilter<"DashboardAnnouncement"> | string
    isActive?: BoolFilter<"DashboardAnnouncement"> | boolean
    priority?: IntFilter<"DashboardAnnouncement"> | number
    expiresAt?: DateTimeNullableFilter<"DashboardAnnouncement"> | Date | string | null
    createdAt?: DateTimeFilter<"DashboardAnnouncement"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardAnnouncement"> | Date | string
    createdBy?: StringFilter<"DashboardAnnouncement"> | string
  }

  export type DashboardAnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DashboardAnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DashboardAnnouncementWhereInput | DashboardAnnouncementWhereInput[]
    OR?: DashboardAnnouncementWhereInput[]
    NOT?: DashboardAnnouncementWhereInput | DashboardAnnouncementWhereInput[]
    title?: StringFilter<"DashboardAnnouncement"> | string
    content?: StringFilter<"DashboardAnnouncement"> | string
    type?: StringFilter<"DashboardAnnouncement"> | string
    isActive?: BoolFilter<"DashboardAnnouncement"> | boolean
    priority?: IntFilter<"DashboardAnnouncement"> | number
    expiresAt?: DateTimeNullableFilter<"DashboardAnnouncement"> | Date | string | null
    createdAt?: DateTimeFilter<"DashboardAnnouncement"> | Date | string
    updatedAt?: DateTimeFilter<"DashboardAnnouncement"> | Date | string
    createdBy?: StringFilter<"DashboardAnnouncement"> | string
  }, "id">

  export type DashboardAnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    _count?: DashboardAnnouncementCountOrderByAggregateInput
    _avg?: DashboardAnnouncementAvgOrderByAggregateInput
    _max?: DashboardAnnouncementMaxOrderByAggregateInput
    _min?: DashboardAnnouncementMinOrderByAggregateInput
    _sum?: DashboardAnnouncementSumOrderByAggregateInput
  }

  export type DashboardAnnouncementScalarWhereWithAggregatesInput = {
    AND?: DashboardAnnouncementScalarWhereWithAggregatesInput | DashboardAnnouncementScalarWhereWithAggregatesInput[]
    OR?: DashboardAnnouncementScalarWhereWithAggregatesInput[]
    NOT?: DashboardAnnouncementScalarWhereWithAggregatesInput | DashboardAnnouncementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DashboardAnnouncement"> | number
    title?: StringWithAggregatesFilter<"DashboardAnnouncement"> | string
    content?: StringWithAggregatesFilter<"DashboardAnnouncement"> | string
    type?: StringWithAggregatesFilter<"DashboardAnnouncement"> | string
    isActive?: BoolWithAggregatesFilter<"DashboardAnnouncement"> | boolean
    priority?: IntWithAggregatesFilter<"DashboardAnnouncement"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"DashboardAnnouncement"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DashboardAnnouncement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DashboardAnnouncement"> | Date | string
    createdBy?: StringWithAggregatesFilter<"DashboardAnnouncement"> | string
  }

  export type UserInvitationWhereInput = {
    AND?: UserInvitationWhereInput | UserInvitationWhereInput[]
    OR?: UserInvitationWhereInput[]
    NOT?: UserInvitationWhereInput | UserInvitationWhereInput[]
    id?: IntFilter<"UserInvitation"> | number
    inviterUserId?: IntNullableFilter<"UserInvitation"> | number | null
    inviteeEmail?: StringFilter<"UserInvitation"> | string
    inviteeName?: StringNullableFilter<"UserInvitation"> | string | null
    inviteePhone?: StringNullableFilter<"UserInvitation"> | string | null
    roomIds?: StringNullableListFilter<"UserInvitation">
    status?: StringFilter<"UserInvitation"> | string
    inviteToken?: StringNullableFilter<"UserInvitation"> | string | null
    message?: StringNullableFilter<"UserInvitation"> | string | null
    expiresAt?: DateTimeFilter<"UserInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"UserInvitation"> | Date | string | null
    createdAt?: DateTimeFilter<"UserInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"UserInvitation"> | Date | string
    inviter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type UserInvitationOrderByWithRelationInput = {
    id?: SortOrder
    inviterUserId?: SortOrderInput | SortOrder
    inviteeEmail?: SortOrder
    inviteeName?: SortOrderInput | SortOrder
    inviteePhone?: SortOrderInput | SortOrder
    roomIds?: SortOrder
    status?: SortOrder
    inviteToken?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inviter?: UserOrderByWithRelationInput
  }

  export type UserInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserInvitationWhereInput | UserInvitationWhereInput[]
    OR?: UserInvitationWhereInput[]
    NOT?: UserInvitationWhereInput | UserInvitationWhereInput[]
    inviterUserId?: IntNullableFilter<"UserInvitation"> | number | null
    inviteeEmail?: StringFilter<"UserInvitation"> | string
    inviteeName?: StringNullableFilter<"UserInvitation"> | string | null
    inviteePhone?: StringNullableFilter<"UserInvitation"> | string | null
    roomIds?: StringNullableListFilter<"UserInvitation">
    status?: StringFilter<"UserInvitation"> | string
    inviteToken?: StringNullableFilter<"UserInvitation"> | string | null
    message?: StringNullableFilter<"UserInvitation"> | string | null
    expiresAt?: DateTimeFilter<"UserInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"UserInvitation"> | Date | string | null
    createdAt?: DateTimeFilter<"UserInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"UserInvitation"> | Date | string
    inviter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type UserInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    inviterUserId?: SortOrderInput | SortOrder
    inviteeEmail?: SortOrder
    inviteeName?: SortOrderInput | SortOrder
    inviteePhone?: SortOrderInput | SortOrder
    roomIds?: SortOrder
    status?: SortOrder
    inviteToken?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserInvitationCountOrderByAggregateInput
    _avg?: UserInvitationAvgOrderByAggregateInput
    _max?: UserInvitationMaxOrderByAggregateInput
    _min?: UserInvitationMinOrderByAggregateInput
    _sum?: UserInvitationSumOrderByAggregateInput
  }

  export type UserInvitationScalarWhereWithAggregatesInput = {
    AND?: UserInvitationScalarWhereWithAggregatesInput | UserInvitationScalarWhereWithAggregatesInput[]
    OR?: UserInvitationScalarWhereWithAggregatesInput[]
    NOT?: UserInvitationScalarWhereWithAggregatesInput | UserInvitationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserInvitation"> | number
    inviterUserId?: IntNullableWithAggregatesFilter<"UserInvitation"> | number | null
    inviteeEmail?: StringWithAggregatesFilter<"UserInvitation"> | string
    inviteeName?: StringNullableWithAggregatesFilter<"UserInvitation"> | string | null
    inviteePhone?: StringNullableWithAggregatesFilter<"UserInvitation"> | string | null
    roomIds?: StringNullableListFilter<"UserInvitation">
    status?: StringWithAggregatesFilter<"UserInvitation"> | string
    inviteToken?: StringNullableWithAggregatesFilter<"UserInvitation"> | string | null
    message?: StringNullableWithAggregatesFilter<"UserInvitation"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"UserInvitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"UserInvitation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserInvitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserInvitation"> | Date | string
  }

  export type CommunityEventWhereInput = {
    AND?: CommunityEventWhereInput | CommunityEventWhereInput[]
    OR?: CommunityEventWhereInput[]
    NOT?: CommunityEventWhereInput | CommunityEventWhereInput[]
    id?: IntFilter<"CommunityEvent"> | number
    eventType?: StringFilter<"CommunityEvent"> | string
    username?: StringFilter<"CommunityEvent"> | string
    details?: StringFilter<"CommunityEvent"> | string
    timestamp?: DateTimeFilter<"CommunityEvent"> | Date | string
    isPublic?: BoolFilter<"CommunityEvent"> | boolean
    category?: StringNullableFilter<"CommunityEvent"> | string | null
  }

  export type CommunityEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    username?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    isPublic?: SortOrder
    category?: SortOrderInput | SortOrder
  }

  export type CommunityEventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommunityEventWhereInput | CommunityEventWhereInput[]
    OR?: CommunityEventWhereInput[]
    NOT?: CommunityEventWhereInput | CommunityEventWhereInput[]
    eventType?: StringFilter<"CommunityEvent"> | string
    username?: StringFilter<"CommunityEvent"> | string
    details?: StringFilter<"CommunityEvent"> | string
    timestamp?: DateTimeFilter<"CommunityEvent"> | Date | string
    isPublic?: BoolFilter<"CommunityEvent"> | boolean
    category?: StringNullableFilter<"CommunityEvent"> | string | null
  }, "id">

  export type CommunityEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    username?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    isPublic?: SortOrder
    category?: SortOrderInput | SortOrder
    _count?: CommunityEventCountOrderByAggregateInput
    _avg?: CommunityEventAvgOrderByAggregateInput
    _max?: CommunityEventMaxOrderByAggregateInput
    _min?: CommunityEventMinOrderByAggregateInput
    _sum?: CommunityEventSumOrderByAggregateInput
  }

  export type CommunityEventScalarWhereWithAggregatesInput = {
    AND?: CommunityEventScalarWhereWithAggregatesInput | CommunityEventScalarWhereWithAggregatesInput[]
    OR?: CommunityEventScalarWhereWithAggregatesInput[]
    NOT?: CommunityEventScalarWhereWithAggregatesInput | CommunityEventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommunityEvent"> | number
    eventType?: StringWithAggregatesFilter<"CommunityEvent"> | string
    username?: StringWithAggregatesFilter<"CommunityEvent"> | string
    details?: StringWithAggregatesFilter<"CommunityEvent"> | string
    timestamp?: DateTimeWithAggregatesFilter<"CommunityEvent"> | Date | string
    isPublic?: BoolWithAggregatesFilter<"CommunityEvent"> | boolean
    category?: StringNullableWithAggregatesFilter<"CommunityEvent"> | string | null
  }

  export type VerificationCodeWhereInput = {
    AND?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    OR?: VerificationCodeWhereInput[]
    NOT?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    id?: IntFilter<"VerificationCode"> | number
    userId?: StringFilter<"VerificationCode"> | string
    code?: StringFilter<"VerificationCode"> | string
    createdAt?: DateTimeFilter<"VerificationCode"> | Date | string
    expiresAt?: DateTimeFilter<"VerificationCode"> | Date | string
  }

  export type VerificationCodeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    OR?: VerificationCodeWhereInput[]
    NOT?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    userId?: StringFilter<"VerificationCode"> | string
    code?: StringFilter<"VerificationCode"> | string
    createdAt?: DateTimeFilter<"VerificationCode"> | Date | string
    expiresAt?: DateTimeFilter<"VerificationCode"> | Date | string
  }, "id">

  export type VerificationCodeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: VerificationCodeCountOrderByAggregateInput
    _avg?: VerificationCodeAvgOrderByAggregateInput
    _max?: VerificationCodeMaxOrderByAggregateInput
    _min?: VerificationCodeMinOrderByAggregateInput
    _sum?: VerificationCodeSumOrderByAggregateInput
  }

  export type VerificationCodeScalarWhereWithAggregatesInput = {
    AND?: VerificationCodeScalarWhereWithAggregatesInput | VerificationCodeScalarWhereWithAggregatesInput[]
    OR?: VerificationCodeScalarWhereWithAggregatesInput[]
    NOT?: VerificationCodeScalarWhereWithAggregatesInput | VerificationCodeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VerificationCode"> | number
    userId?: StringWithAggregatesFilter<"VerificationCode"> | string
    code?: StringWithAggregatesFilter<"VerificationCode"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VerificationCode"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"VerificationCode"> | Date | string
  }

  export type MatrixRoomMemberWhereInput = {
    AND?: MatrixRoomMemberWhereInput | MatrixRoomMemberWhereInput[]
    OR?: MatrixRoomMemberWhereInput[]
    NOT?: MatrixRoomMemberWhereInput | MatrixRoomMemberWhereInput[]
    id?: IntFilter<"MatrixRoomMember"> | number
    roomId?: StringFilter<"MatrixRoomMember"> | string
    userId?: StringFilter<"MatrixRoomMember"> | string
    displayName?: StringNullableFilter<"MatrixRoomMember"> | string | null
    avatarUrl?: StringNullableFilter<"MatrixRoomMember"> | string | null
    membership?: StringNullableFilter<"MatrixRoomMember"> | string | null
    lastUpdated?: DateTimeFilter<"MatrixRoomMember"> | Date | string
  }

  export type MatrixRoomMemberOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    membership?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
  }

  export type MatrixRoomMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    idx_matrix_room_member_room_user?: MatrixRoomMemberIdx_matrix_room_member_room_userCompoundUniqueInput
    AND?: MatrixRoomMemberWhereInput | MatrixRoomMemberWhereInput[]
    OR?: MatrixRoomMemberWhereInput[]
    NOT?: MatrixRoomMemberWhereInput | MatrixRoomMemberWhereInput[]
    roomId?: StringFilter<"MatrixRoomMember"> | string
    userId?: StringFilter<"MatrixRoomMember"> | string
    displayName?: StringNullableFilter<"MatrixRoomMember"> | string | null
    avatarUrl?: StringNullableFilter<"MatrixRoomMember"> | string | null
    membership?: StringNullableFilter<"MatrixRoomMember"> | string | null
    lastUpdated?: DateTimeFilter<"MatrixRoomMember"> | Date | string
  }, "id" | "idx_matrix_room_member_room_user">

  export type MatrixRoomMemberOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    membership?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    _count?: MatrixRoomMemberCountOrderByAggregateInput
    _avg?: MatrixRoomMemberAvgOrderByAggregateInput
    _max?: MatrixRoomMemberMaxOrderByAggregateInput
    _min?: MatrixRoomMemberMinOrderByAggregateInput
    _sum?: MatrixRoomMemberSumOrderByAggregateInput
  }

  export type MatrixRoomMemberScalarWhereWithAggregatesInput = {
    AND?: MatrixRoomMemberScalarWhereWithAggregatesInput | MatrixRoomMemberScalarWhereWithAggregatesInput[]
    OR?: MatrixRoomMemberScalarWhereWithAggregatesInput[]
    NOT?: MatrixRoomMemberScalarWhereWithAggregatesInput | MatrixRoomMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MatrixRoomMember"> | number
    roomId?: StringWithAggregatesFilter<"MatrixRoomMember"> | string
    userId?: StringWithAggregatesFilter<"MatrixRoomMember"> | string
    displayName?: StringNullableWithAggregatesFilter<"MatrixRoomMember"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"MatrixRoomMember"> | string | null
    membership?: StringNullableWithAggregatesFilter<"MatrixRoomMember"> | string | null
    lastUpdated?: DateTimeWithAggregatesFilter<"MatrixRoomMember"> | Date | string
  }

  export type UserNoteWhereInput = {
    AND?: UserNoteWhereInput | UserNoteWhereInput[]
    OR?: UserNoteWhereInput[]
    NOT?: UserNoteWhereInput | UserNoteWhereInput[]
    id?: IntFilter<"UserNote"> | number
    userId?: IntFilter<"UserNote"> | number
    content?: StringFilter<"UserNote"> | string
    createdAt?: DateTimeFilter<"UserNote"> | Date | string
    updatedAt?: DateTimeFilter<"UserNote"> | Date | string
    createdBy?: StringFilter<"UserNote"> | string
    lastEditedBy?: StringNullableFilter<"UserNote"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserNoteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    lastEditedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserNoteWhereInput | UserNoteWhereInput[]
    OR?: UserNoteWhereInput[]
    NOT?: UserNoteWhereInput | UserNoteWhereInput[]
    userId?: IntFilter<"UserNote"> | number
    content?: StringFilter<"UserNote"> | string
    createdAt?: DateTimeFilter<"UserNote"> | Date | string
    updatedAt?: DateTimeFilter<"UserNote"> | Date | string
    createdBy?: StringFilter<"UserNote"> | string
    lastEditedBy?: StringNullableFilter<"UserNote"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserNoteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    lastEditedBy?: SortOrderInput | SortOrder
    _count?: UserNoteCountOrderByAggregateInput
    _avg?: UserNoteAvgOrderByAggregateInput
    _max?: UserNoteMaxOrderByAggregateInput
    _min?: UserNoteMinOrderByAggregateInput
    _sum?: UserNoteSumOrderByAggregateInput
  }

  export type UserNoteScalarWhereWithAggregatesInput = {
    AND?: UserNoteScalarWhereWithAggregatesInput | UserNoteScalarWhereWithAggregatesInput[]
    OR?: UserNoteScalarWhereWithAggregatesInput[]
    NOT?: UserNoteScalarWhereWithAggregatesInput | UserNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserNote"> | number
    userId?: IntWithAggregatesFilter<"UserNote"> | number
    content?: StringWithAggregatesFilter<"UserNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserNote"> | Date | string
    createdBy?: StringWithAggregatesFilter<"UserNote"> | string
    lastEditedBy?: StringNullableWithAggregatesFilter<"UserNote"> | string | null
  }

  export type InviteWhereInput = {
    AND?: InviteWhereInput | InviteWhereInput[]
    OR?: InviteWhereInput[]
    NOT?: InviteWhereInput | InviteWhereInput[]
    id?: IntFilter<"Invite"> | number
    token?: StringFilter<"Invite"> | string
    label?: StringNullableFilter<"Invite"> | string | null
    email?: StringNullableFilter<"Invite"> | string | null
    name?: StringNullableFilter<"Invite"> | string | null
    groups?: StringNullableFilter<"Invite"> | string | null
    createdAt?: DateTimeFilter<"Invite"> | Date | string
    expiresAt?: DateTimeFilter<"Invite"> | Date | string
    createdBy?: StringNullableFilter<"Invite"> | string | null
    isUsed?: BoolFilter<"Invite"> | boolean
    usedBy?: StringNullableFilter<"Invite"> | string | null
    usedAt?: DateTimeNullableFilter<"Invite"> | Date | string | null
  }

  export type InviteOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    label?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    groups?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    isUsed?: SortOrder
    usedBy?: SortOrderInput | SortOrder
    usedAt?: SortOrderInput | SortOrder
  }

  export type InviteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: InviteWhereInput | InviteWhereInput[]
    OR?: InviteWhereInput[]
    NOT?: InviteWhereInput | InviteWhereInput[]
    label?: StringNullableFilter<"Invite"> | string | null
    email?: StringNullableFilter<"Invite"> | string | null
    name?: StringNullableFilter<"Invite"> | string | null
    groups?: StringNullableFilter<"Invite"> | string | null
    createdAt?: DateTimeFilter<"Invite"> | Date | string
    expiresAt?: DateTimeFilter<"Invite"> | Date | string
    createdBy?: StringNullableFilter<"Invite"> | string | null
    isUsed?: BoolFilter<"Invite"> | boolean
    usedBy?: StringNullableFilter<"Invite"> | string | null
    usedAt?: DateTimeNullableFilter<"Invite"> | Date | string | null
  }, "id" | "token">

  export type InviteOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    label?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    groups?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    isUsed?: SortOrder
    usedBy?: SortOrderInput | SortOrder
    usedAt?: SortOrderInput | SortOrder
    _count?: InviteCountOrderByAggregateInput
    _avg?: InviteAvgOrderByAggregateInput
    _max?: InviteMaxOrderByAggregateInput
    _min?: InviteMinOrderByAggregateInput
    _sum?: InviteSumOrderByAggregateInput
  }

  export type InviteScalarWhereWithAggregatesInput = {
    AND?: InviteScalarWhereWithAggregatesInput | InviteScalarWhereWithAggregatesInput[]
    OR?: InviteScalarWhereWithAggregatesInput[]
    NOT?: InviteScalarWhereWithAggregatesInput | InviteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invite"> | number
    token?: StringWithAggregatesFilter<"Invite"> | string
    label?: StringNullableWithAggregatesFilter<"Invite"> | string | null
    email?: StringNullableWithAggregatesFilter<"Invite"> | string | null
    name?: StringNullableWithAggregatesFilter<"Invite"> | string | null
    groups?: StringNullableWithAggregatesFilter<"Invite"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invite"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Invite"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Invite"> | string | null
    isUsed?: BoolWithAggregatesFilter<"Invite"> | boolean
    usedBy?: StringNullableWithAggregatesFilter<"Invite"> | string | null
    usedAt?: DateTimeNullableWithAggregatesFilter<"Invite"> | Date | string | null
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: IntFilter<"Group"> | number
    name?: StringFilter<"Group"> | string
    description?: StringNullableFilter<"Group"> | string | null
    authentikGroupId?: StringNullableFilter<"Group"> | string | null
    users?: UserGroupListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    authentikGroupId?: SortOrderInput | SortOrder
    users?: UserGroupOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    description?: StringNullableFilter<"Group"> | string | null
    authentikGroupId?: StringNullableFilter<"Group"> | string | null
    users?: UserGroupListRelationFilter
  }, "id" | "name">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    authentikGroupId?: SortOrderInput | SortOrder
    _count?: GroupCountOrderByAggregateInput
    _avg?: GroupAvgOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
    _sum?: GroupSumOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Group"> | number
    name?: StringWithAggregatesFilter<"Group"> | string
    description?: StringNullableWithAggregatesFilter<"Group"> | string | null
    authentikGroupId?: StringNullableWithAggregatesFilter<"Group"> | string | null
  }

  export type UserGroupWhereInput = {
    AND?: UserGroupWhereInput | UserGroupWhereInput[]
    OR?: UserGroupWhereInput[]
    NOT?: UserGroupWhereInput | UserGroupWhereInput[]
    userId?: IntFilter<"UserGroup"> | number
    groupId?: IntFilter<"UserGroup"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }

  export type UserGroupOrderByWithRelationInput = {
    userId?: SortOrder
    groupId?: SortOrder
    user?: UserOrderByWithRelationInput
    group?: GroupOrderByWithRelationInput
  }

  export type UserGroupWhereUniqueInput = Prisma.AtLeast<{
    userId_groupId?: UserGroupUserIdGroupIdCompoundUniqueInput
    AND?: UserGroupWhereInput | UserGroupWhereInput[]
    OR?: UserGroupWhereInput[]
    NOT?: UserGroupWhereInput | UserGroupWhereInput[]
    userId?: IntFilter<"UserGroup"> | number
    groupId?: IntFilter<"UserGroup"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    group?: XOR<GroupScalarRelationFilter, GroupWhereInput>
  }, "userId_groupId">

  export type UserGroupOrderByWithAggregationInput = {
    userId?: SortOrder
    groupId?: SortOrder
    _count?: UserGroupCountOrderByAggregateInput
    _avg?: UserGroupAvgOrderByAggregateInput
    _max?: UserGroupMaxOrderByAggregateInput
    _min?: UserGroupMinOrderByAggregateInput
    _sum?: UserGroupSumOrderByAggregateInput
  }

  export type UserGroupScalarWhereWithAggregatesInput = {
    AND?: UserGroupScalarWhereWithAggregatesInput | UserGroupScalarWhereWithAggregatesInput[]
    OR?: UserGroupScalarWhereWithAggregatesInput[]
    NOT?: UserGroupScalarWhereWithAggregatesInput | UserGroupScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserGroup"> | number
    groupId?: IntWithAggregatesFilter<"UserGroup"> | number
  }

  export type ModeratorPermissionWhereInput = {
    AND?: ModeratorPermissionWhereInput | ModeratorPermissionWhereInput[]
    OR?: ModeratorPermissionWhereInput[]
    NOT?: ModeratorPermissionWhereInput | ModeratorPermissionWhereInput[]
    id?: IntFilter<"ModeratorPermission"> | number
    userId?: IntFilter<"ModeratorPermission"> | number
    permissionType?: StringFilter<"ModeratorPermission"> | string
    permissionValue?: StringNullableFilter<"ModeratorPermission"> | string | null
    createdAt?: DateTimeFilter<"ModeratorPermission"> | Date | string
    createdBy?: StringFilter<"ModeratorPermission"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ModeratorPermissionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissionType?: SortOrder
    permissionValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ModeratorPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ModeratorPermissionWhereInput | ModeratorPermissionWhereInput[]
    OR?: ModeratorPermissionWhereInput[]
    NOT?: ModeratorPermissionWhereInput | ModeratorPermissionWhereInput[]
    userId?: IntFilter<"ModeratorPermission"> | number
    permissionType?: StringFilter<"ModeratorPermission"> | string
    permissionValue?: StringNullableFilter<"ModeratorPermission"> | string | null
    createdAt?: DateTimeFilter<"ModeratorPermission"> | Date | string
    createdBy?: StringFilter<"ModeratorPermission"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ModeratorPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissionType?: SortOrder
    permissionValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    _count?: ModeratorPermissionCountOrderByAggregateInput
    _avg?: ModeratorPermissionAvgOrderByAggregateInput
    _max?: ModeratorPermissionMaxOrderByAggregateInput
    _min?: ModeratorPermissionMinOrderByAggregateInput
    _sum?: ModeratorPermissionSumOrderByAggregateInput
  }

  export type ModeratorPermissionScalarWhereWithAggregatesInput = {
    AND?: ModeratorPermissionScalarWhereWithAggregatesInput | ModeratorPermissionScalarWhereWithAggregatesInput[]
    OR?: ModeratorPermissionScalarWhereWithAggregatesInput[]
    NOT?: ModeratorPermissionScalarWhereWithAggregatesInput | ModeratorPermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ModeratorPermission"> | number
    userId?: IntWithAggregatesFilter<"ModeratorPermission"> | number
    permissionType?: StringWithAggregatesFilter<"ModeratorPermission"> | string
    permissionValue?: StringNullableWithAggregatesFilter<"ModeratorPermission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ModeratorPermission"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ModeratorPermission"> | string
  }

  export type MatrixUserWhereInput = {
    AND?: MatrixUserWhereInput | MatrixUserWhereInput[]
    OR?: MatrixUserWhereInput[]
    NOT?: MatrixUserWhereInput | MatrixUserWhereInput[]
    userId?: StringFilter<"MatrixUser"> | string
    displayName?: StringNullableFilter<"MatrixUser"> | string | null
    avatarUrl?: StringNullableFilter<"MatrixUser"> | string | null
    isSignalUser?: BoolFilter<"MatrixUser"> | boolean
    lastSeen?: DateTimeNullableFilter<"MatrixUser"> | Date | string | null
    createdAt?: DateTimeFilter<"MatrixUser"> | Date | string
    updatedAt?: DateTimeFilter<"MatrixUser"> | Date | string
    memberships?: MatrixRoomMembershipListRelationFilter
  }

  export type MatrixUserOrderByWithRelationInput = {
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isSignalUser?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberships?: MatrixRoomMembershipOrderByRelationAggregateInput
  }

  export type MatrixUserWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: MatrixUserWhereInput | MatrixUserWhereInput[]
    OR?: MatrixUserWhereInput[]
    NOT?: MatrixUserWhereInput | MatrixUserWhereInput[]
    displayName?: StringNullableFilter<"MatrixUser"> | string | null
    avatarUrl?: StringNullableFilter<"MatrixUser"> | string | null
    isSignalUser?: BoolFilter<"MatrixUser"> | boolean
    lastSeen?: DateTimeNullableFilter<"MatrixUser"> | Date | string | null
    createdAt?: DateTimeFilter<"MatrixUser"> | Date | string
    updatedAt?: DateTimeFilter<"MatrixUser"> | Date | string
    memberships?: MatrixRoomMembershipListRelationFilter
  }, "userId">

  export type MatrixUserOrderByWithAggregationInput = {
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isSignalUser?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatrixUserCountOrderByAggregateInput
    _max?: MatrixUserMaxOrderByAggregateInput
    _min?: MatrixUserMinOrderByAggregateInput
  }

  export type MatrixUserScalarWhereWithAggregatesInput = {
    AND?: MatrixUserScalarWhereWithAggregatesInput | MatrixUserScalarWhereWithAggregatesInput[]
    OR?: MatrixUserScalarWhereWithAggregatesInput[]
    NOT?: MatrixUserScalarWhereWithAggregatesInput | MatrixUserScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"MatrixUser"> | string
    displayName?: StringNullableWithAggregatesFilter<"MatrixUser"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"MatrixUser"> | string | null
    isSignalUser?: BoolWithAggregatesFilter<"MatrixUser"> | boolean
    lastSeen?: DateTimeNullableWithAggregatesFilter<"MatrixUser"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MatrixUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MatrixUser"> | Date | string
  }

  export type MatrixRoomWhereInput = {
    AND?: MatrixRoomWhereInput | MatrixRoomWhereInput[]
    OR?: MatrixRoomWhereInput[]
    NOT?: MatrixRoomWhereInput | MatrixRoomWhereInput[]
    roomId?: StringFilter<"MatrixRoom"> | string
    name?: StringNullableFilter<"MatrixRoom"> | string | null
    displayName?: StringNullableFilter<"MatrixRoom"> | string | null
    topic?: StringNullableFilter<"MatrixRoom"> | string | null
    canonicalAlias?: StringNullableFilter<"MatrixRoom"> | string | null
    memberCount?: IntFilter<"MatrixRoom"> | number
    roomType?: StringNullableFilter<"MatrixRoom"> | string | null
    isDirect?: BoolFilter<"MatrixRoom"> | boolean
    isEncrypted?: BoolFilter<"MatrixRoom"> | boolean
    lastSynced?: DateTimeNullableFilter<"MatrixRoom"> | Date | string | null
    createdAt?: DateTimeFilter<"MatrixRoom"> | Date | string
    updatedAt?: DateTimeFilter<"MatrixRoom"> | Date | string
    memberships?: MatrixRoomMembershipListRelationFilter
  }

  export type MatrixRoomOrderByWithRelationInput = {
    roomId?: SortOrder
    name?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    canonicalAlias?: SortOrderInput | SortOrder
    memberCount?: SortOrder
    roomType?: SortOrderInput | SortOrder
    isDirect?: SortOrder
    isEncrypted?: SortOrder
    lastSynced?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberships?: MatrixRoomMembershipOrderByRelationAggregateInput
  }

  export type MatrixRoomWhereUniqueInput = Prisma.AtLeast<{
    roomId?: string
    AND?: MatrixRoomWhereInput | MatrixRoomWhereInput[]
    OR?: MatrixRoomWhereInput[]
    NOT?: MatrixRoomWhereInput | MatrixRoomWhereInput[]
    name?: StringNullableFilter<"MatrixRoom"> | string | null
    displayName?: StringNullableFilter<"MatrixRoom"> | string | null
    topic?: StringNullableFilter<"MatrixRoom"> | string | null
    canonicalAlias?: StringNullableFilter<"MatrixRoom"> | string | null
    memberCount?: IntFilter<"MatrixRoom"> | number
    roomType?: StringNullableFilter<"MatrixRoom"> | string | null
    isDirect?: BoolFilter<"MatrixRoom"> | boolean
    isEncrypted?: BoolFilter<"MatrixRoom"> | boolean
    lastSynced?: DateTimeNullableFilter<"MatrixRoom"> | Date | string | null
    createdAt?: DateTimeFilter<"MatrixRoom"> | Date | string
    updatedAt?: DateTimeFilter<"MatrixRoom"> | Date | string
    memberships?: MatrixRoomMembershipListRelationFilter
  }, "roomId">

  export type MatrixRoomOrderByWithAggregationInput = {
    roomId?: SortOrder
    name?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    canonicalAlias?: SortOrderInput | SortOrder
    memberCount?: SortOrder
    roomType?: SortOrderInput | SortOrder
    isDirect?: SortOrder
    isEncrypted?: SortOrder
    lastSynced?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatrixRoomCountOrderByAggregateInput
    _avg?: MatrixRoomAvgOrderByAggregateInput
    _max?: MatrixRoomMaxOrderByAggregateInput
    _min?: MatrixRoomMinOrderByAggregateInput
    _sum?: MatrixRoomSumOrderByAggregateInput
  }

  export type MatrixRoomScalarWhereWithAggregatesInput = {
    AND?: MatrixRoomScalarWhereWithAggregatesInput | MatrixRoomScalarWhereWithAggregatesInput[]
    OR?: MatrixRoomScalarWhereWithAggregatesInput[]
    NOT?: MatrixRoomScalarWhereWithAggregatesInput | MatrixRoomScalarWhereWithAggregatesInput[]
    roomId?: StringWithAggregatesFilter<"MatrixRoom"> | string
    name?: StringNullableWithAggregatesFilter<"MatrixRoom"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"MatrixRoom"> | string | null
    topic?: StringNullableWithAggregatesFilter<"MatrixRoom"> | string | null
    canonicalAlias?: StringNullableWithAggregatesFilter<"MatrixRoom"> | string | null
    memberCount?: IntWithAggregatesFilter<"MatrixRoom"> | number
    roomType?: StringNullableWithAggregatesFilter<"MatrixRoom"> | string | null
    isDirect?: BoolWithAggregatesFilter<"MatrixRoom"> | boolean
    isEncrypted?: BoolWithAggregatesFilter<"MatrixRoom"> | boolean
    lastSynced?: DateTimeNullableWithAggregatesFilter<"MatrixRoom"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MatrixRoom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MatrixRoom"> | Date | string
  }

  export type MatrixRoomMembershipWhereInput = {
    AND?: MatrixRoomMembershipWhereInput | MatrixRoomMembershipWhereInput[]
    OR?: MatrixRoomMembershipWhereInput[]
    NOT?: MatrixRoomMembershipWhereInput | MatrixRoomMembershipWhereInput[]
    id?: IntFilter<"MatrixRoomMembership"> | number
    roomId?: StringFilter<"MatrixRoomMembership"> | string
    userId?: StringFilter<"MatrixRoomMembership"> | string
    membershipStatus?: StringFilter<"MatrixRoomMembership"> | string
    joinedAt?: DateTimeNullableFilter<"MatrixRoomMembership"> | Date | string | null
    createdAt?: DateTimeFilter<"MatrixRoomMembership"> | Date | string
    updatedAt?: DateTimeFilter<"MatrixRoomMembership"> | Date | string
    user?: XOR<MatrixUserScalarRelationFilter, MatrixUserWhereInput>
    room?: XOR<MatrixRoomScalarRelationFilter, MatrixRoomWhereInput>
  }

  export type MatrixRoomMembershipOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    membershipStatus?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: MatrixUserOrderByWithRelationInput
    room?: MatrixRoomOrderByWithRelationInput
  }

  export type MatrixRoomMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roomId_userId?: MatrixRoomMembershipRoomIdUserIdCompoundUniqueInput
    AND?: MatrixRoomMembershipWhereInput | MatrixRoomMembershipWhereInput[]
    OR?: MatrixRoomMembershipWhereInput[]
    NOT?: MatrixRoomMembershipWhereInput | MatrixRoomMembershipWhereInput[]
    roomId?: StringFilter<"MatrixRoomMembership"> | string
    userId?: StringFilter<"MatrixRoomMembership"> | string
    membershipStatus?: StringFilter<"MatrixRoomMembership"> | string
    joinedAt?: DateTimeNullableFilter<"MatrixRoomMembership"> | Date | string | null
    createdAt?: DateTimeFilter<"MatrixRoomMembership"> | Date | string
    updatedAt?: DateTimeFilter<"MatrixRoomMembership"> | Date | string
    user?: XOR<MatrixUserScalarRelationFilter, MatrixUserWhereInput>
    room?: XOR<MatrixRoomScalarRelationFilter, MatrixRoomWhereInput>
  }, "id" | "roomId_userId">

  export type MatrixRoomMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    membershipStatus?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatrixRoomMembershipCountOrderByAggregateInput
    _avg?: MatrixRoomMembershipAvgOrderByAggregateInput
    _max?: MatrixRoomMembershipMaxOrderByAggregateInput
    _min?: MatrixRoomMembershipMinOrderByAggregateInput
    _sum?: MatrixRoomMembershipSumOrderByAggregateInput
  }

  export type MatrixRoomMembershipScalarWhereWithAggregatesInput = {
    AND?: MatrixRoomMembershipScalarWhereWithAggregatesInput | MatrixRoomMembershipScalarWhereWithAggregatesInput[]
    OR?: MatrixRoomMembershipScalarWhereWithAggregatesInput[]
    NOT?: MatrixRoomMembershipScalarWhereWithAggregatesInput | MatrixRoomMembershipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MatrixRoomMembership"> | number
    roomId?: StringWithAggregatesFilter<"MatrixRoomMembership"> | string
    userId?: StringWithAggregatesFilter<"MatrixRoomMembership"> | string
    membershipStatus?: StringWithAggregatesFilter<"MatrixRoomMembership"> | string
    joinedAt?: DateTimeNullableWithAggregatesFilter<"MatrixRoomMembership"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MatrixRoomMembership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MatrixRoomMembership"> | Date | string
  }

  export type MatrixSyncStatusWhereInput = {
    AND?: MatrixSyncStatusWhereInput | MatrixSyncStatusWhereInput[]
    OR?: MatrixSyncStatusWhereInput[]
    NOT?: MatrixSyncStatusWhereInput | MatrixSyncStatusWhereInput[]
    id?: IntFilter<"MatrixSyncStatus"> | number
    syncType?: StringFilter<"MatrixSyncStatus"> | string
    status?: StringFilter<"MatrixSyncStatus"> | string
    lastSync?: DateTimeNullableFilter<"MatrixSyncStatus"> | Date | string | null
    totalItems?: IntFilter<"MatrixSyncStatus"> | number
    processedItems?: IntFilter<"MatrixSyncStatus"> | number
    errorMessage?: StringNullableFilter<"MatrixSyncStatus"> | string | null
    syncDurationSeconds?: IntNullableFilter<"MatrixSyncStatus"> | number | null
    createdAt?: DateTimeFilter<"MatrixSyncStatus"> | Date | string
    updatedAt?: DateTimeFilter<"MatrixSyncStatus"> | Date | string
  }

  export type MatrixSyncStatusOrderByWithRelationInput = {
    id?: SortOrder
    syncType?: SortOrder
    status?: SortOrder
    lastSync?: SortOrderInput | SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    syncDurationSeconds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixSyncStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MatrixSyncStatusWhereInput | MatrixSyncStatusWhereInput[]
    OR?: MatrixSyncStatusWhereInput[]
    NOT?: MatrixSyncStatusWhereInput | MatrixSyncStatusWhereInput[]
    syncType?: StringFilter<"MatrixSyncStatus"> | string
    status?: StringFilter<"MatrixSyncStatus"> | string
    lastSync?: DateTimeNullableFilter<"MatrixSyncStatus"> | Date | string | null
    totalItems?: IntFilter<"MatrixSyncStatus"> | number
    processedItems?: IntFilter<"MatrixSyncStatus"> | number
    errorMessage?: StringNullableFilter<"MatrixSyncStatus"> | string | null
    syncDurationSeconds?: IntNullableFilter<"MatrixSyncStatus"> | number | null
    createdAt?: DateTimeFilter<"MatrixSyncStatus"> | Date | string
    updatedAt?: DateTimeFilter<"MatrixSyncStatus"> | Date | string
  }, "id">

  export type MatrixSyncStatusOrderByWithAggregationInput = {
    id?: SortOrder
    syncType?: SortOrder
    status?: SortOrder
    lastSync?: SortOrderInput | SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    syncDurationSeconds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MatrixSyncStatusCountOrderByAggregateInput
    _avg?: MatrixSyncStatusAvgOrderByAggregateInput
    _max?: MatrixSyncStatusMaxOrderByAggregateInput
    _min?: MatrixSyncStatusMinOrderByAggregateInput
    _sum?: MatrixSyncStatusSumOrderByAggregateInput
  }

  export type MatrixSyncStatusScalarWhereWithAggregatesInput = {
    AND?: MatrixSyncStatusScalarWhereWithAggregatesInput | MatrixSyncStatusScalarWhereWithAggregatesInput[]
    OR?: MatrixSyncStatusScalarWhereWithAggregatesInput[]
    NOT?: MatrixSyncStatusScalarWhereWithAggregatesInput | MatrixSyncStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MatrixSyncStatus"> | number
    syncType?: StringWithAggregatesFilter<"MatrixSyncStatus"> | string
    status?: StringWithAggregatesFilter<"MatrixSyncStatus"> | string
    lastSync?: DateTimeNullableWithAggregatesFilter<"MatrixSyncStatus"> | Date | string | null
    totalItems?: IntWithAggregatesFilter<"MatrixSyncStatus"> | number
    processedItems?: IntWithAggregatesFilter<"MatrixSyncStatus"> | number
    errorMessage?: StringNullableWithAggregatesFilter<"MatrixSyncStatus"> | string | null
    syncDurationSeconds?: IntNullableWithAggregatesFilter<"MatrixSyncStatus"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MatrixSyncStatus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MatrixSyncStatus"> | Date | string
  }

  export type MatrixUserCacheWhereInput = {
    AND?: MatrixUserCacheWhereInput | MatrixUserCacheWhereInput[]
    OR?: MatrixUserCacheWhereInput[]
    NOT?: MatrixUserCacheWhereInput | MatrixUserCacheWhereInput[]
    userId?: StringFilter<"MatrixUserCache"> | string
    displayName?: StringNullableFilter<"MatrixUserCache"> | string | null
    avatarUrl?: StringNullableFilter<"MatrixUserCache"> | string | null
    isSignalUser?: BoolFilter<"MatrixUserCache"> | boolean
    roomCount?: IntFilter<"MatrixUserCache"> | number
    lastActivity?: DateTimeNullableFilter<"MatrixUserCache"> | Date | string | null
    cacheUpdated?: DateTimeFilter<"MatrixUserCache"> | Date | string
  }

  export type MatrixUserCacheOrderByWithRelationInput = {
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isSignalUser?: SortOrder
    roomCount?: SortOrder
    lastActivity?: SortOrderInput | SortOrder
    cacheUpdated?: SortOrder
  }

  export type MatrixUserCacheWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: MatrixUserCacheWhereInput | MatrixUserCacheWhereInput[]
    OR?: MatrixUserCacheWhereInput[]
    NOT?: MatrixUserCacheWhereInput | MatrixUserCacheWhereInput[]
    displayName?: StringNullableFilter<"MatrixUserCache"> | string | null
    avatarUrl?: StringNullableFilter<"MatrixUserCache"> | string | null
    isSignalUser?: BoolFilter<"MatrixUserCache"> | boolean
    roomCount?: IntFilter<"MatrixUserCache"> | number
    lastActivity?: DateTimeNullableFilter<"MatrixUserCache"> | Date | string | null
    cacheUpdated?: DateTimeFilter<"MatrixUserCache"> | Date | string
  }, "userId">

  export type MatrixUserCacheOrderByWithAggregationInput = {
    userId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isSignalUser?: SortOrder
    roomCount?: SortOrder
    lastActivity?: SortOrderInput | SortOrder
    cacheUpdated?: SortOrder
    _count?: MatrixUserCacheCountOrderByAggregateInput
    _avg?: MatrixUserCacheAvgOrderByAggregateInput
    _max?: MatrixUserCacheMaxOrderByAggregateInput
    _min?: MatrixUserCacheMinOrderByAggregateInput
    _sum?: MatrixUserCacheSumOrderByAggregateInput
  }

  export type MatrixUserCacheScalarWhereWithAggregatesInput = {
    AND?: MatrixUserCacheScalarWhereWithAggregatesInput | MatrixUserCacheScalarWhereWithAggregatesInput[]
    OR?: MatrixUserCacheScalarWhereWithAggregatesInput[]
    NOT?: MatrixUserCacheScalarWhereWithAggregatesInput | MatrixUserCacheScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"MatrixUserCache"> | string
    displayName?: StringNullableWithAggregatesFilter<"MatrixUserCache"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"MatrixUserCache"> | string | null
    isSignalUser?: BoolWithAggregatesFilter<"MatrixUserCache"> | boolean
    roomCount?: IntWithAggregatesFilter<"MatrixUserCache"> | number
    lastActivity?: DateTimeNullableWithAggregatesFilter<"MatrixUserCache"> | Date | string | null
    cacheUpdated?: DateTimeWithAggregatesFilter<"MatrixUserCache"> | Date | string
  }

  export type UserCreateInput = {
    username?: string | null
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: Date | string
    lastLogin?: Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: string | null
    signalIdentity?: string | null
    matrixUsername?: string | null
    notes?: UserNoteCreateNestedManyWithoutUserInput
    groups?: UserGroupCreateNestedManyWithoutUserInput
    moderatorPermissions?: ModeratorPermissionCreateNestedManyWithoutUserInput
    sentInvitations?: UserInvitationCreateNestedManyWithoutInviterInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username?: string | null
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: Date | string
    lastLogin?: Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: string | null
    signalIdentity?: string | null
    matrixUsername?: string | null
    notes?: UserNoteUncheckedCreateNestedManyWithoutUserInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    moderatorPermissions?: ModeratorPermissionUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: UserInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type UserUpdateInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isModerator?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: NullableStringFieldUpdateOperationsInput | string | null
    signalIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    matrixUsername?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: UserNoteUpdateManyWithoutUserNestedInput
    groups?: UserGroupUpdateManyWithoutUserNestedInput
    moderatorPermissions?: ModeratorPermissionUpdateManyWithoutUserNestedInput
    sentInvitations?: UserInvitationUpdateManyWithoutInviterNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isModerator?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: NullableStringFieldUpdateOperationsInput | string | null
    signalIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    matrixUsername?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: UserNoteUncheckedUpdateManyWithoutUserNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    moderatorPermissions?: ModeratorPermissionUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: UserInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username?: string | null
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: Date | string
    lastLogin?: Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: string | null
    signalIdentity?: string | null
    matrixUsername?: string | null
  }

  export type UserUpdateManyMutationInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isModerator?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: NullableStringFieldUpdateOperationsInput | string | null
    signalIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    matrixUsername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isModerator?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: NullableStringFieldUpdateOperationsInput | string | null
    signalIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    matrixUsername?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminEventCreateInput = {
    eventType: string
    username?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type AdminEventUncheckedCreateInput = {
    id?: number
    eventType: string
    username?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type AdminEventUpdateInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminEventCreateManyInput = {
    id?: number
    eventType: string
    username?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type AdminEventUpdateManyMutationInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardSettingsCreateInput = {
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardSettingsUncheckedCreateInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardSettingsUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardSettingsCreateManyInput = {
    id?: number
    key: string
    value: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DashboardSettingsUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBookmarkCreateInput = {
    title: string
    description?: string | null
    url: string
    icon?: string | null
    category?: string
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityBookmarkUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    url: string
    icon?: string | null
    category?: string
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityBookmarkUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBookmarkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBookmarkCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    url: string
    icon?: string | null
    category?: string
    order?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityBookmarkUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityBookmarkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardAnnouncementCreateInput = {
    title: string
    content: string
    type?: string
    isActive?: boolean
    priority?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type DashboardAnnouncementUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    type?: string
    isActive?: boolean
    priority?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type DashboardAnnouncementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardAnnouncementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardAnnouncementCreateManyInput = {
    id?: number
    title: string
    content: string
    type?: string
    isActive?: boolean
    priority?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
  }

  export type DashboardAnnouncementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type DashboardAnnouncementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserInvitationCreateInput = {
    inviteeEmail: string
    inviteeName?: string | null
    inviteePhone?: string | null
    roomIds?: UserInvitationCreateroomIdsInput | string[]
    status?: string
    inviteToken?: string | null
    message?: string | null
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inviter?: UserCreateNestedOneWithoutSentInvitationsInput
  }

  export type UserInvitationUncheckedCreateInput = {
    id?: number
    inviterUserId?: number | null
    inviteeEmail: string
    inviteeName?: string | null
    inviteePhone?: string | null
    roomIds?: UserInvitationCreateroomIdsInput | string[]
    status?: string
    inviteToken?: string | null
    message?: string | null
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationUpdateInput = {
    inviteeEmail?: StringFieldUpdateOperationsInput | string
    inviteeName?: NullableStringFieldUpdateOperationsInput | string | null
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    roomIds?: UserInvitationUpdateroomIdsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserUpdateOneWithoutSentInvitationsNestedInput
  }

  export type UserInvitationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    inviterUserId?: NullableIntFieldUpdateOperationsInput | number | null
    inviteeEmail?: StringFieldUpdateOperationsInput | string
    inviteeName?: NullableStringFieldUpdateOperationsInput | string | null
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    roomIds?: UserInvitationUpdateroomIdsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationCreateManyInput = {
    id?: number
    inviterUserId?: number | null
    inviteeEmail: string
    inviteeName?: string | null
    inviteePhone?: string | null
    roomIds?: UserInvitationCreateroomIdsInput | string[]
    status?: string
    inviteToken?: string | null
    message?: string | null
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationUpdateManyMutationInput = {
    inviteeEmail?: StringFieldUpdateOperationsInput | string
    inviteeName?: NullableStringFieldUpdateOperationsInput | string | null
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    roomIds?: UserInvitationUpdateroomIdsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    inviterUserId?: NullableIntFieldUpdateOperationsInput | number | null
    inviteeEmail?: StringFieldUpdateOperationsInput | string
    inviteeName?: NullableStringFieldUpdateOperationsInput | string | null
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    roomIds?: UserInvitationUpdateroomIdsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityEventCreateInput = {
    eventType: string
    username: string
    details: string
    timestamp?: Date | string
    isPublic?: boolean
    category?: string | null
  }

  export type CommunityEventUncheckedCreateInput = {
    id?: number
    eventType: string
    username: string
    details: string
    timestamp?: Date | string
    isPublic?: boolean
    category?: string | null
  }

  export type CommunityEventUpdateInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityEventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityEventCreateManyInput = {
    id?: number
    eventType: string
    username: string
    details: string
    timestamp?: Date | string
    isPublic?: boolean
    category?: string | null
  }

  export type CommunityEventUpdateManyMutationInput = {
    eventType?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityEventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    eventType?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationCodeCreateInput = {
    userId: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type VerificationCodeUncheckedCreateInput = {
    id?: number
    userId: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type VerificationCodeUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeCreateManyInput = {
    id?: number
    userId: string
    code: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type VerificationCodeUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCodeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomMemberCreateInput = {
    roomId: string
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    membership?: string | null
    lastUpdated?: Date | string
  }

  export type MatrixRoomMemberUncheckedCreateInput = {
    id?: number
    roomId: string
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    membership?: string | null
    lastUpdated?: Date | string
  }

  export type MatrixRoomMemberUpdateInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    membership?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    membership?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomMemberCreateManyInput = {
    id?: number
    roomId: string
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    membership?: string | null
    lastUpdated?: Date | string
  }

  export type MatrixRoomMemberUpdateManyMutationInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    membership?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    membership?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNoteCreateInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    lastEditedBy?: string | null
    user: UserCreateNestedOneWithoutNotesInput
  }

  export type UserNoteUncheckedCreateInput = {
    id?: number
    userId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    lastEditedBy?: string | null
  }

  export type UserNoteUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    lastEditedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutNotesNestedInput
  }

  export type UserNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    lastEditedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserNoteCreateManyInput = {
    id?: number
    userId: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    lastEditedBy?: string | null
  }

  export type UserNoteUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    lastEditedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    lastEditedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InviteCreateInput = {
    token: string
    label?: string | null
    email?: string | null
    name?: string | null
    groups?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    createdBy?: string | null
    isUsed?: boolean
    usedBy?: string | null
    usedAt?: Date | string | null
  }

  export type InviteUncheckedCreateInput = {
    id?: number
    token: string
    label?: string | null
    email?: string | null
    name?: string | null
    groups?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    createdBy?: string | null
    isUsed?: boolean
    usedBy?: string | null
    usedAt?: Date | string | null
  }

  export type InviteUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    groups?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InviteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    groups?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InviteCreateManyInput = {
    id?: number
    token: string
    label?: string | null
    email?: string | null
    name?: string | null
    groups?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    createdBy?: string | null
    isUsed?: boolean
    usedBy?: string | null
    usedAt?: Date | string | null
  }

  export type InviteUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    groups?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InviteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    groups?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupCreateInput = {
    name: string
    description?: string | null
    authentikGroupId?: string | null
    users?: UserGroupCreateNestedManyWithoutGroupInput
  }

  export type GroupUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    authentikGroupId?: string | null
    users?: UserGroupUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authentikGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserGroupUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authentikGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserGroupUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    authentikGroupId?: string | null
  }

  export type GroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authentikGroupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authentikGroupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserGroupCreateInput = {
    user: UserCreateNestedOneWithoutGroupsInput
    group: GroupCreateNestedOneWithoutUsersInput
  }

  export type UserGroupUncheckedCreateInput = {
    userId: number
    groupId: number
  }

  export type UserGroupUpdateInput = {
    user?: UserUpdateOneRequiredWithoutGroupsNestedInput
    group?: GroupUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserGroupUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type UserGroupCreateManyInput = {
    userId: number
    groupId: number
  }

  export type UserGroupUpdateManyMutationInput = {

  }

  export type UserGroupUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type ModeratorPermissionCreateInput = {
    permissionType: string
    permissionValue?: string | null
    createdAt?: Date | string
    createdBy: string
    user: UserCreateNestedOneWithoutModeratorPermissionsInput
  }

  export type ModeratorPermissionUncheckedCreateInput = {
    id?: number
    userId: number
    permissionType: string
    permissionValue?: string | null
    createdAt?: Date | string
    createdBy: string
  }

  export type ModeratorPermissionUpdateInput = {
    permissionType?: StringFieldUpdateOperationsInput | string
    permissionValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutModeratorPermissionsNestedInput
  }

  export type ModeratorPermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    permissionType?: StringFieldUpdateOperationsInput | string
    permissionValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ModeratorPermissionCreateManyInput = {
    id?: number
    userId: number
    permissionType: string
    permissionValue?: string | null
    createdAt?: Date | string
    createdBy: string
  }

  export type ModeratorPermissionUpdateManyMutationInput = {
    permissionType?: StringFieldUpdateOperationsInput | string
    permissionValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ModeratorPermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    permissionType?: StringFieldUpdateOperationsInput | string
    permissionValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type MatrixUserCreateInput = {
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    isSignalUser?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MatrixRoomMembershipCreateNestedManyWithoutUserInput
  }

  export type MatrixUserUncheckedCreateInput = {
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    isSignalUser?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MatrixRoomMembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type MatrixUserUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignalUser?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MatrixRoomMembershipUpdateManyWithoutUserNestedInput
  }

  export type MatrixUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignalUser?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MatrixRoomMembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MatrixUserCreateManyInput = {
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    isSignalUser?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixUserUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignalUser?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignalUser?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomCreateInput = {
    roomId: string
    name?: string | null
    displayName?: string | null
    topic?: string | null
    canonicalAlias?: string | null
    memberCount?: number
    roomType?: string | null
    isDirect?: boolean
    isEncrypted?: boolean
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MatrixRoomMembershipCreateNestedManyWithoutRoomInput
  }

  export type MatrixRoomUncheckedCreateInput = {
    roomId: string
    name?: string | null
    displayName?: string | null
    topic?: string | null
    canonicalAlias?: string | null
    memberCount?: number
    roomType?: string | null
    isDirect?: boolean
    isEncrypted?: boolean
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: MatrixRoomMembershipUncheckedCreateNestedManyWithoutRoomInput
  }

  export type MatrixRoomUpdateInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalAlias?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MatrixRoomMembershipUpdateManyWithoutRoomNestedInput
  }

  export type MatrixRoomUncheckedUpdateInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalAlias?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: MatrixRoomMembershipUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type MatrixRoomCreateManyInput = {
    roomId: string
    name?: string | null
    displayName?: string | null
    topic?: string | null
    canonicalAlias?: string | null
    memberCount?: number
    roomType?: string | null
    isDirect?: boolean
    isEncrypted?: boolean
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixRoomUpdateManyMutationInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalAlias?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomUncheckedUpdateManyInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalAlias?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomMembershipCreateInput = {
    membershipStatus?: string
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: MatrixUserCreateNestedOneWithoutMembershipsInput
    room: MatrixRoomCreateNestedOneWithoutMembershipsInput
  }

  export type MatrixRoomMembershipUncheckedCreateInput = {
    id?: number
    roomId: string
    userId: string
    membershipStatus?: string
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixRoomMembershipUpdateInput = {
    membershipStatus?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: MatrixUserUpdateOneRequiredWithoutMembershipsNestedInput
    room?: MatrixRoomUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type MatrixRoomMembershipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    membershipStatus?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomMembershipCreateManyInput = {
    id?: number
    roomId: string
    userId: string
    membershipStatus?: string
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixRoomMembershipUpdateManyMutationInput = {
    membershipStatus?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomMembershipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    membershipStatus?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixSyncStatusCreateInput = {
    syncType: string
    status?: string
    lastSync?: Date | string | null
    totalItems?: number
    processedItems?: number
    errorMessage?: string | null
    syncDurationSeconds?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixSyncStatusUncheckedCreateInput = {
    id?: number
    syncType: string
    status?: string
    lastSync?: Date | string | null
    totalItems?: number
    processedItems?: number
    errorMessage?: string | null
    syncDurationSeconds?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixSyncStatusUpdateInput = {
    syncType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    processedItems?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    syncDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixSyncStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    processedItems?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    syncDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixSyncStatusCreateManyInput = {
    id?: number
    syncType: string
    status?: string
    lastSync?: Date | string | null
    totalItems?: number
    processedItems?: number
    errorMessage?: string | null
    syncDurationSeconds?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixSyncStatusUpdateManyMutationInput = {
    syncType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    processedItems?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    syncDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixSyncStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    syncType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalItems?: IntFieldUpdateOperationsInput | number
    processedItems?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    syncDurationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixUserCacheCreateInput = {
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    isSignalUser?: boolean
    roomCount?: number
    lastActivity?: Date | string | null
    cacheUpdated?: Date | string
  }

  export type MatrixUserCacheUncheckedCreateInput = {
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    isSignalUser?: boolean
    roomCount?: number
    lastActivity?: Date | string | null
    cacheUpdated?: Date | string
  }

  export type MatrixUserCacheUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignalUser?: BoolFieldUpdateOperationsInput | boolean
    roomCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cacheUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixUserCacheUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignalUser?: BoolFieldUpdateOperationsInput | boolean
    roomCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cacheUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixUserCacheCreateManyInput = {
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    isSignalUser?: boolean
    roomCount?: number
    lastActivity?: Date | string | null
    cacheUpdated?: Date | string
  }

  export type MatrixUserCacheUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignalUser?: BoolFieldUpdateOperationsInput | boolean
    roomCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cacheUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixUserCacheUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignalUser?: BoolFieldUpdateOperationsInput | boolean
    roomCount?: IntFieldUpdateOperationsInput | number
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cacheUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNoteListRelationFilter = {
    every?: UserNoteWhereInput
    some?: UserNoteWhereInput
    none?: UserNoteWhereInput
  }

  export type UserGroupListRelationFilter = {
    every?: UserGroupWhereInput
    some?: UserGroupWhereInput
    none?: UserGroupWhereInput
  }

  export type ModeratorPermissionListRelationFilter = {
    every?: ModeratorPermissionWhereInput
    some?: ModeratorPermissionWhereInput
    none?: ModeratorPermissionWhereInput
  }

  export type UserInvitationListRelationFilter = {
    every?: UserInvitationWhereInput
    some?: UserInvitationWhereInput
    none?: UserInvitationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModeratorPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isAdmin?: SortOrder
    isModerator?: SortOrder
    dateJoined?: SortOrder
    lastLogin?: SortOrder
    attributes?: SortOrder
    authentikId?: SortOrder
    signalIdentity?: SortOrder
    matrixUsername?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isAdmin?: SortOrder
    isModerator?: SortOrder
    dateJoined?: SortOrder
    lastLogin?: SortOrder
    authentikId?: SortOrder
    signalIdentity?: SortOrder
    matrixUsername?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    isAdmin?: SortOrder
    isModerator?: SortOrder
    dateJoined?: SortOrder
    lastLogin?: SortOrder
    authentikId?: SortOrder
    signalIdentity?: SortOrder
    matrixUsername?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AdminEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    username?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type AdminEventAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    username?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type AdminEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    username?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type AdminEventSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DashboardSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DashboardSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DashboardSettingsSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CommunityBookmarkCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityBookmarkAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type CommunityBookmarkMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityBookmarkMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    order?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityBookmarkSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type DashboardAnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DashboardAnnouncementAvgOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
  }

  export type DashboardAnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DashboardAnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    priority?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type DashboardAnnouncementSumOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    inviterUserId?: SortOrder
    inviteeEmail?: SortOrder
    inviteeName?: SortOrder
    inviteePhone?: SortOrder
    roomIds?: SortOrder
    status?: SortOrder
    inviteToken?: SortOrder
    message?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInvitationAvgOrderByAggregateInput = {
    id?: SortOrder
    inviterUserId?: SortOrder
  }

  export type UserInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    inviterUserId?: SortOrder
    inviteeEmail?: SortOrder
    inviteeName?: SortOrder
    inviteePhone?: SortOrder
    status?: SortOrder
    inviteToken?: SortOrder
    message?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    inviterUserId?: SortOrder
    inviteeEmail?: SortOrder
    inviteeName?: SortOrder
    inviteePhone?: SortOrder
    status?: SortOrder
    inviteToken?: SortOrder
    message?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInvitationSumOrderByAggregateInput = {
    id?: SortOrder
    inviterUserId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CommunityEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    username?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    isPublic?: SortOrder
    category?: SortOrder
  }

  export type CommunityEventAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CommunityEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    username?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    isPublic?: SortOrder
    category?: SortOrder
  }

  export type CommunityEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    username?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
    isPublic?: SortOrder
    category?: SortOrder
  }

  export type CommunityEventSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VerificationCodeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationCodeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VerificationCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationCodeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationCodeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MatrixRoomMemberIdx_matrix_room_member_room_userCompoundUniqueInput = {
    roomId: string
    userId: string
  }

  export type MatrixRoomMemberCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    membership?: SortOrder
    lastUpdated?: SortOrder
  }

  export type MatrixRoomMemberAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MatrixRoomMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    membership?: SortOrder
    lastUpdated?: SortOrder
  }

  export type MatrixRoomMemberMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    membership?: SortOrder
    lastUpdated?: SortOrder
  }

  export type MatrixRoomMemberSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserNoteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    lastEditedBy?: SortOrder
  }

  export type UserNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type UserNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    lastEditedBy?: SortOrder
  }

  export type UserNoteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    lastEditedBy?: SortOrder
  }

  export type UserNoteSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type InviteCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    label?: SortOrder
    email?: SortOrder
    name?: SortOrder
    groups?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    createdBy?: SortOrder
    isUsed?: SortOrder
    usedBy?: SortOrder
    usedAt?: SortOrder
  }

  export type InviteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InviteMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    label?: SortOrder
    email?: SortOrder
    name?: SortOrder
    groups?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    createdBy?: SortOrder
    isUsed?: SortOrder
    usedBy?: SortOrder
    usedAt?: SortOrder
  }

  export type InviteMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    label?: SortOrder
    email?: SortOrder
    name?: SortOrder
    groups?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    createdBy?: SortOrder
    isUsed?: SortOrder
    usedBy?: SortOrder
    usedAt?: SortOrder
  }

  export type InviteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    authentikGroupId?: SortOrder
  }

  export type GroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    authentikGroupId?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    authentikGroupId?: SortOrder
  }

  export type GroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GroupScalarRelationFilter = {
    is?: GroupWhereInput
    isNot?: GroupWhereInput
  }

  export type UserGroupUserIdGroupIdCompoundUniqueInput = {
    userId: number
    groupId: number
  }

  export type UserGroupCountOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type UserGroupAvgOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type UserGroupMaxOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type UserGroupMinOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type UserGroupSumOrderByAggregateInput = {
    userId?: SortOrder
    groupId?: SortOrder
  }

  export type ModeratorPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissionType?: SortOrder
    permissionValue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ModeratorPermissionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ModeratorPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissionType?: SortOrder
    permissionValue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ModeratorPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissionType?: SortOrder
    permissionValue?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ModeratorPermissionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MatrixRoomMembershipListRelationFilter = {
    every?: MatrixRoomMembershipWhereInput
    some?: MatrixRoomMembershipWhereInput
    none?: MatrixRoomMembershipWhereInput
  }

  export type MatrixRoomMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatrixUserCountOrderByAggregateInput = {
    userId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    isSignalUser?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    isSignalUser?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixUserMinOrderByAggregateInput = {
    userId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    isSignalUser?: SortOrder
    lastSeen?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixRoomCountOrderByAggregateInput = {
    roomId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    topic?: SortOrder
    canonicalAlias?: SortOrder
    memberCount?: SortOrder
    roomType?: SortOrder
    isDirect?: SortOrder
    isEncrypted?: SortOrder
    lastSynced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixRoomAvgOrderByAggregateInput = {
    memberCount?: SortOrder
  }

  export type MatrixRoomMaxOrderByAggregateInput = {
    roomId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    topic?: SortOrder
    canonicalAlias?: SortOrder
    memberCount?: SortOrder
    roomType?: SortOrder
    isDirect?: SortOrder
    isEncrypted?: SortOrder
    lastSynced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixRoomMinOrderByAggregateInput = {
    roomId?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    topic?: SortOrder
    canonicalAlias?: SortOrder
    memberCount?: SortOrder
    roomType?: SortOrder
    isDirect?: SortOrder
    isEncrypted?: SortOrder
    lastSynced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixRoomSumOrderByAggregateInput = {
    memberCount?: SortOrder
  }

  export type MatrixUserScalarRelationFilter = {
    is?: MatrixUserWhereInput
    isNot?: MatrixUserWhereInput
  }

  export type MatrixRoomScalarRelationFilter = {
    is?: MatrixRoomWhereInput
    isNot?: MatrixRoomWhereInput
  }

  export type MatrixRoomMembershipRoomIdUserIdCompoundUniqueInput = {
    roomId: string
    userId: string
  }

  export type MatrixRoomMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    membershipStatus?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixRoomMembershipAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MatrixRoomMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    membershipStatus?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixRoomMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    membershipStatus?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixRoomMembershipSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MatrixSyncStatusCountOrderByAggregateInput = {
    id?: SortOrder
    syncType?: SortOrder
    status?: SortOrder
    lastSync?: SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    errorMessage?: SortOrder
    syncDurationSeconds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixSyncStatusAvgOrderByAggregateInput = {
    id?: SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    syncDurationSeconds?: SortOrder
  }

  export type MatrixSyncStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    syncType?: SortOrder
    status?: SortOrder
    lastSync?: SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    errorMessage?: SortOrder
    syncDurationSeconds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixSyncStatusMinOrderByAggregateInput = {
    id?: SortOrder
    syncType?: SortOrder
    status?: SortOrder
    lastSync?: SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    errorMessage?: SortOrder
    syncDurationSeconds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MatrixSyncStatusSumOrderByAggregateInput = {
    id?: SortOrder
    totalItems?: SortOrder
    processedItems?: SortOrder
    syncDurationSeconds?: SortOrder
  }

  export type MatrixUserCacheCountOrderByAggregateInput = {
    userId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    isSignalUser?: SortOrder
    roomCount?: SortOrder
    lastActivity?: SortOrder
    cacheUpdated?: SortOrder
  }

  export type MatrixUserCacheAvgOrderByAggregateInput = {
    roomCount?: SortOrder
  }

  export type MatrixUserCacheMaxOrderByAggregateInput = {
    userId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    isSignalUser?: SortOrder
    roomCount?: SortOrder
    lastActivity?: SortOrder
    cacheUpdated?: SortOrder
  }

  export type MatrixUserCacheMinOrderByAggregateInput = {
    userId?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    isSignalUser?: SortOrder
    roomCount?: SortOrder
    lastActivity?: SortOrder
    cacheUpdated?: SortOrder
  }

  export type MatrixUserCacheSumOrderByAggregateInput = {
    roomCount?: SortOrder
  }

  export type UserNoteCreateNestedManyWithoutUserInput = {
    create?: XOR<UserNoteCreateWithoutUserInput, UserNoteUncheckedCreateWithoutUserInput> | UserNoteCreateWithoutUserInput[] | UserNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNoteCreateOrConnectWithoutUserInput | UserNoteCreateOrConnectWithoutUserInput[]
    createMany?: UserNoteCreateManyUserInputEnvelope
    connect?: UserNoteWhereUniqueInput | UserNoteWhereUniqueInput[]
  }

  export type UserGroupCreateNestedManyWithoutUserInput = {
    create?: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput> | UserGroupCreateWithoutUserInput[] | UserGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutUserInput | UserGroupCreateOrConnectWithoutUserInput[]
    createMany?: UserGroupCreateManyUserInputEnvelope
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type ModeratorPermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<ModeratorPermissionCreateWithoutUserInput, ModeratorPermissionUncheckedCreateWithoutUserInput> | ModeratorPermissionCreateWithoutUserInput[] | ModeratorPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModeratorPermissionCreateOrConnectWithoutUserInput | ModeratorPermissionCreateOrConnectWithoutUserInput[]
    createMany?: ModeratorPermissionCreateManyUserInputEnvelope
    connect?: ModeratorPermissionWhereUniqueInput | ModeratorPermissionWhereUniqueInput[]
  }

  export type UserInvitationCreateNestedManyWithoutInviterInput = {
    create?: XOR<UserInvitationCreateWithoutInviterInput, UserInvitationUncheckedCreateWithoutInviterInput> | UserInvitationCreateWithoutInviterInput[] | UserInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutInviterInput | UserInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: UserInvitationCreateManyInviterInputEnvelope
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
  }

  export type UserNoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserNoteCreateWithoutUserInput, UserNoteUncheckedCreateWithoutUserInput> | UserNoteCreateWithoutUserInput[] | UserNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNoteCreateOrConnectWithoutUserInput | UserNoteCreateOrConnectWithoutUserInput[]
    createMany?: UserNoteCreateManyUserInputEnvelope
    connect?: UserNoteWhereUniqueInput | UserNoteWhereUniqueInput[]
  }

  export type UserGroupUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput> | UserGroupCreateWithoutUserInput[] | UserGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutUserInput | UserGroupCreateOrConnectWithoutUserInput[]
    createMany?: UserGroupCreateManyUserInputEnvelope
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type ModeratorPermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ModeratorPermissionCreateWithoutUserInput, ModeratorPermissionUncheckedCreateWithoutUserInput> | ModeratorPermissionCreateWithoutUserInput[] | ModeratorPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModeratorPermissionCreateOrConnectWithoutUserInput | ModeratorPermissionCreateOrConnectWithoutUserInput[]
    createMany?: ModeratorPermissionCreateManyUserInputEnvelope
    connect?: ModeratorPermissionWhereUniqueInput | ModeratorPermissionWhereUniqueInput[]
  }

  export type UserInvitationUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<UserInvitationCreateWithoutInviterInput, UserInvitationUncheckedCreateWithoutInviterInput> | UserInvitationCreateWithoutInviterInput[] | UserInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutInviterInput | UserInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: UserInvitationCreateManyInviterInputEnvelope
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserNoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserNoteCreateWithoutUserInput, UserNoteUncheckedCreateWithoutUserInput> | UserNoteCreateWithoutUserInput[] | UserNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNoteCreateOrConnectWithoutUserInput | UserNoteCreateOrConnectWithoutUserInput[]
    upsert?: UserNoteUpsertWithWhereUniqueWithoutUserInput | UserNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserNoteCreateManyUserInputEnvelope
    set?: UserNoteWhereUniqueInput | UserNoteWhereUniqueInput[]
    disconnect?: UserNoteWhereUniqueInput | UserNoteWhereUniqueInput[]
    delete?: UserNoteWhereUniqueInput | UserNoteWhereUniqueInput[]
    connect?: UserNoteWhereUniqueInput | UserNoteWhereUniqueInput[]
    update?: UserNoteUpdateWithWhereUniqueWithoutUserInput | UserNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserNoteUpdateManyWithWhereWithoutUserInput | UserNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserNoteScalarWhereInput | UserNoteScalarWhereInput[]
  }

  export type UserGroupUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput> | UserGroupCreateWithoutUserInput[] | UserGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutUserInput | UserGroupCreateOrConnectWithoutUserInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutUserInput | UserGroupUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserGroupCreateManyUserInputEnvelope
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutUserInput | UserGroupUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutUserInput | UserGroupUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type ModeratorPermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ModeratorPermissionCreateWithoutUserInput, ModeratorPermissionUncheckedCreateWithoutUserInput> | ModeratorPermissionCreateWithoutUserInput[] | ModeratorPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModeratorPermissionCreateOrConnectWithoutUserInput | ModeratorPermissionCreateOrConnectWithoutUserInput[]
    upsert?: ModeratorPermissionUpsertWithWhereUniqueWithoutUserInput | ModeratorPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ModeratorPermissionCreateManyUserInputEnvelope
    set?: ModeratorPermissionWhereUniqueInput | ModeratorPermissionWhereUniqueInput[]
    disconnect?: ModeratorPermissionWhereUniqueInput | ModeratorPermissionWhereUniqueInput[]
    delete?: ModeratorPermissionWhereUniqueInput | ModeratorPermissionWhereUniqueInput[]
    connect?: ModeratorPermissionWhereUniqueInput | ModeratorPermissionWhereUniqueInput[]
    update?: ModeratorPermissionUpdateWithWhereUniqueWithoutUserInput | ModeratorPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ModeratorPermissionUpdateManyWithWhereWithoutUserInput | ModeratorPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ModeratorPermissionScalarWhereInput | ModeratorPermissionScalarWhereInput[]
  }

  export type UserInvitationUpdateManyWithoutInviterNestedInput = {
    create?: XOR<UserInvitationCreateWithoutInviterInput, UserInvitationUncheckedCreateWithoutInviterInput> | UserInvitationCreateWithoutInviterInput[] | UserInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutInviterInput | UserInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: UserInvitationUpsertWithWhereUniqueWithoutInviterInput | UserInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: UserInvitationCreateManyInviterInputEnvelope
    set?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    disconnect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    delete?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    update?: UserInvitationUpdateWithWhereUniqueWithoutInviterInput | UserInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: UserInvitationUpdateManyWithWhereWithoutInviterInput | UserInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserNoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserNoteCreateWithoutUserInput, UserNoteUncheckedCreateWithoutUserInput> | UserNoteCreateWithoutUserInput[] | UserNoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNoteCreateOrConnectWithoutUserInput | UserNoteCreateOrConnectWithoutUserInput[]
    upsert?: UserNoteUpsertWithWhereUniqueWithoutUserInput | UserNoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserNoteCreateManyUserInputEnvelope
    set?: UserNoteWhereUniqueInput | UserNoteWhereUniqueInput[]
    disconnect?: UserNoteWhereUniqueInput | UserNoteWhereUniqueInput[]
    delete?: UserNoteWhereUniqueInput | UserNoteWhereUniqueInput[]
    connect?: UserNoteWhereUniqueInput | UserNoteWhereUniqueInput[]
    update?: UserNoteUpdateWithWhereUniqueWithoutUserInput | UserNoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserNoteUpdateManyWithWhereWithoutUserInput | UserNoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserNoteScalarWhereInput | UserNoteScalarWhereInput[]
  }

  export type UserGroupUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput> | UserGroupCreateWithoutUserInput[] | UserGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutUserInput | UserGroupCreateOrConnectWithoutUserInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutUserInput | UserGroupUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserGroupCreateManyUserInputEnvelope
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutUserInput | UserGroupUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutUserInput | UserGroupUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type ModeratorPermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ModeratorPermissionCreateWithoutUserInput, ModeratorPermissionUncheckedCreateWithoutUserInput> | ModeratorPermissionCreateWithoutUserInput[] | ModeratorPermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModeratorPermissionCreateOrConnectWithoutUserInput | ModeratorPermissionCreateOrConnectWithoutUserInput[]
    upsert?: ModeratorPermissionUpsertWithWhereUniqueWithoutUserInput | ModeratorPermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ModeratorPermissionCreateManyUserInputEnvelope
    set?: ModeratorPermissionWhereUniqueInput | ModeratorPermissionWhereUniqueInput[]
    disconnect?: ModeratorPermissionWhereUniqueInput | ModeratorPermissionWhereUniqueInput[]
    delete?: ModeratorPermissionWhereUniqueInput | ModeratorPermissionWhereUniqueInput[]
    connect?: ModeratorPermissionWhereUniqueInput | ModeratorPermissionWhereUniqueInput[]
    update?: ModeratorPermissionUpdateWithWhereUniqueWithoutUserInput | ModeratorPermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ModeratorPermissionUpdateManyWithWhereWithoutUserInput | ModeratorPermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ModeratorPermissionScalarWhereInput | ModeratorPermissionScalarWhereInput[]
  }

  export type UserInvitationUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<UserInvitationCreateWithoutInviterInput, UserInvitationUncheckedCreateWithoutInviterInput> | UserInvitationCreateWithoutInviterInput[] | UserInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutInviterInput | UserInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: UserInvitationUpsertWithWhereUniqueWithoutInviterInput | UserInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: UserInvitationCreateManyInviterInputEnvelope
    set?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    disconnect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    delete?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    update?: UserInvitationUpdateWithWhereUniqueWithoutInviterInput | UserInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: UserInvitationUpdateManyWithWhereWithoutInviterInput | UserInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserInvitationCreateroomIdsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSentInvitationsInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserInvitationUpdateroomIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutSentInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
    upsert?: UserUpsertWithoutSentInvitationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentInvitationsInput, UserUpdateWithoutSentInvitationsInput>, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutNotesInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    upsert?: UserUpsertWithoutNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesInput, UserUpdateWithoutNotesInput>, UserUncheckedUpdateWithoutNotesInput>
  }

  export type UserGroupCreateNestedManyWithoutGroupInput = {
    create?: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput> | UserGroupCreateWithoutGroupInput[] | UserGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutGroupInput | UserGroupCreateOrConnectWithoutGroupInput[]
    createMany?: UserGroupCreateManyGroupInputEnvelope
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type UserGroupUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput> | UserGroupCreateWithoutGroupInput[] | UserGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutGroupInput | UserGroupCreateOrConnectWithoutGroupInput[]
    createMany?: UserGroupCreateManyGroupInputEnvelope
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
  }

  export type UserGroupUpdateManyWithoutGroupNestedInput = {
    create?: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput> | UserGroupCreateWithoutGroupInput[] | UserGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutGroupInput | UserGroupCreateOrConnectWithoutGroupInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutGroupInput | UserGroupUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: UserGroupCreateManyGroupInputEnvelope
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutGroupInput | UserGroupUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutGroupInput | UserGroupUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type UserGroupUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput> | UserGroupCreateWithoutGroupInput[] | UserGroupUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: UserGroupCreateOrConnectWithoutGroupInput | UserGroupCreateOrConnectWithoutGroupInput[]
    upsert?: UserGroupUpsertWithWhereUniqueWithoutGroupInput | UserGroupUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: UserGroupCreateManyGroupInputEnvelope
    set?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    disconnect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    delete?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    connect?: UserGroupWhereUniqueInput | UserGroupWhereUniqueInput[]
    update?: UserGroupUpdateWithWhereUniqueWithoutGroupInput | UserGroupUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: UserGroupUpdateManyWithWhereWithoutGroupInput | UserGroupUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutGroupsInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedOneWithoutUsersInput = {
    create?: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutUsersInput
    connect?: GroupWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGroupsNestedInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput
    upsert?: UserUpsertWithoutGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupsInput, UserUpdateWithoutGroupsInput>, UserUncheckedUpdateWithoutGroupsInput>
  }

  export type GroupUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput>
    connectOrCreate?: GroupCreateOrConnectWithoutUsersInput
    upsert?: GroupUpsertWithoutUsersInput
    connect?: GroupWhereUniqueInput
    update?: XOR<XOR<GroupUpdateToOneWithWhereWithoutUsersInput, GroupUpdateWithoutUsersInput>, GroupUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutModeratorPermissionsInput = {
    create?: XOR<UserCreateWithoutModeratorPermissionsInput, UserUncheckedCreateWithoutModeratorPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModeratorPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutModeratorPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutModeratorPermissionsInput, UserUncheckedCreateWithoutModeratorPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutModeratorPermissionsInput
    upsert?: UserUpsertWithoutModeratorPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModeratorPermissionsInput, UserUpdateWithoutModeratorPermissionsInput>, UserUncheckedUpdateWithoutModeratorPermissionsInput>
  }

  export type MatrixRoomMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<MatrixRoomMembershipCreateWithoutUserInput, MatrixRoomMembershipUncheckedCreateWithoutUserInput> | MatrixRoomMembershipCreateWithoutUserInput[] | MatrixRoomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatrixRoomMembershipCreateOrConnectWithoutUserInput | MatrixRoomMembershipCreateOrConnectWithoutUserInput[]
    createMany?: MatrixRoomMembershipCreateManyUserInputEnvelope
    connect?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
  }

  export type MatrixRoomMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MatrixRoomMembershipCreateWithoutUserInput, MatrixRoomMembershipUncheckedCreateWithoutUserInput> | MatrixRoomMembershipCreateWithoutUserInput[] | MatrixRoomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatrixRoomMembershipCreateOrConnectWithoutUserInput | MatrixRoomMembershipCreateOrConnectWithoutUserInput[]
    createMany?: MatrixRoomMembershipCreateManyUserInputEnvelope
    connect?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
  }

  export type MatrixRoomMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatrixRoomMembershipCreateWithoutUserInput, MatrixRoomMembershipUncheckedCreateWithoutUserInput> | MatrixRoomMembershipCreateWithoutUserInput[] | MatrixRoomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatrixRoomMembershipCreateOrConnectWithoutUserInput | MatrixRoomMembershipCreateOrConnectWithoutUserInput[]
    upsert?: MatrixRoomMembershipUpsertWithWhereUniqueWithoutUserInput | MatrixRoomMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatrixRoomMembershipCreateManyUserInputEnvelope
    set?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    disconnect?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    delete?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    connect?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    update?: MatrixRoomMembershipUpdateWithWhereUniqueWithoutUserInput | MatrixRoomMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatrixRoomMembershipUpdateManyWithWhereWithoutUserInput | MatrixRoomMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatrixRoomMembershipScalarWhereInput | MatrixRoomMembershipScalarWhereInput[]
  }

  export type MatrixRoomMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatrixRoomMembershipCreateWithoutUserInput, MatrixRoomMembershipUncheckedCreateWithoutUserInput> | MatrixRoomMembershipCreateWithoutUserInput[] | MatrixRoomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatrixRoomMembershipCreateOrConnectWithoutUserInput | MatrixRoomMembershipCreateOrConnectWithoutUserInput[]
    upsert?: MatrixRoomMembershipUpsertWithWhereUniqueWithoutUserInput | MatrixRoomMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatrixRoomMembershipCreateManyUserInputEnvelope
    set?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    disconnect?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    delete?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    connect?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    update?: MatrixRoomMembershipUpdateWithWhereUniqueWithoutUserInput | MatrixRoomMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatrixRoomMembershipUpdateManyWithWhereWithoutUserInput | MatrixRoomMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatrixRoomMembershipScalarWhereInput | MatrixRoomMembershipScalarWhereInput[]
  }

  export type MatrixRoomMembershipCreateNestedManyWithoutRoomInput = {
    create?: XOR<MatrixRoomMembershipCreateWithoutRoomInput, MatrixRoomMembershipUncheckedCreateWithoutRoomInput> | MatrixRoomMembershipCreateWithoutRoomInput[] | MatrixRoomMembershipUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MatrixRoomMembershipCreateOrConnectWithoutRoomInput | MatrixRoomMembershipCreateOrConnectWithoutRoomInput[]
    createMany?: MatrixRoomMembershipCreateManyRoomInputEnvelope
    connect?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
  }

  export type MatrixRoomMembershipUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<MatrixRoomMembershipCreateWithoutRoomInput, MatrixRoomMembershipUncheckedCreateWithoutRoomInput> | MatrixRoomMembershipCreateWithoutRoomInput[] | MatrixRoomMembershipUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MatrixRoomMembershipCreateOrConnectWithoutRoomInput | MatrixRoomMembershipCreateOrConnectWithoutRoomInput[]
    createMany?: MatrixRoomMembershipCreateManyRoomInputEnvelope
    connect?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
  }

  export type MatrixRoomMembershipUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MatrixRoomMembershipCreateWithoutRoomInput, MatrixRoomMembershipUncheckedCreateWithoutRoomInput> | MatrixRoomMembershipCreateWithoutRoomInput[] | MatrixRoomMembershipUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MatrixRoomMembershipCreateOrConnectWithoutRoomInput | MatrixRoomMembershipCreateOrConnectWithoutRoomInput[]
    upsert?: MatrixRoomMembershipUpsertWithWhereUniqueWithoutRoomInput | MatrixRoomMembershipUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MatrixRoomMembershipCreateManyRoomInputEnvelope
    set?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    disconnect?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    delete?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    connect?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    update?: MatrixRoomMembershipUpdateWithWhereUniqueWithoutRoomInput | MatrixRoomMembershipUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MatrixRoomMembershipUpdateManyWithWhereWithoutRoomInput | MatrixRoomMembershipUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MatrixRoomMembershipScalarWhereInput | MatrixRoomMembershipScalarWhereInput[]
  }

  export type MatrixRoomMembershipUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MatrixRoomMembershipCreateWithoutRoomInput, MatrixRoomMembershipUncheckedCreateWithoutRoomInput> | MatrixRoomMembershipCreateWithoutRoomInput[] | MatrixRoomMembershipUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MatrixRoomMembershipCreateOrConnectWithoutRoomInput | MatrixRoomMembershipCreateOrConnectWithoutRoomInput[]
    upsert?: MatrixRoomMembershipUpsertWithWhereUniqueWithoutRoomInput | MatrixRoomMembershipUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MatrixRoomMembershipCreateManyRoomInputEnvelope
    set?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    disconnect?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    delete?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    connect?: MatrixRoomMembershipWhereUniqueInput | MatrixRoomMembershipWhereUniqueInput[]
    update?: MatrixRoomMembershipUpdateWithWhereUniqueWithoutRoomInput | MatrixRoomMembershipUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MatrixRoomMembershipUpdateManyWithWhereWithoutRoomInput | MatrixRoomMembershipUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MatrixRoomMembershipScalarWhereInput | MatrixRoomMembershipScalarWhereInput[]
  }

  export type MatrixUserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<MatrixUserCreateWithoutMembershipsInput, MatrixUserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: MatrixUserCreateOrConnectWithoutMembershipsInput
    connect?: MatrixUserWhereUniqueInput
  }

  export type MatrixRoomCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<MatrixRoomCreateWithoutMembershipsInput, MatrixRoomUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: MatrixRoomCreateOrConnectWithoutMembershipsInput
    connect?: MatrixRoomWhereUniqueInput
  }

  export type MatrixUserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<MatrixUserCreateWithoutMembershipsInput, MatrixUserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: MatrixUserCreateOrConnectWithoutMembershipsInput
    upsert?: MatrixUserUpsertWithoutMembershipsInput
    connect?: MatrixUserWhereUniqueInput
    update?: XOR<XOR<MatrixUserUpdateToOneWithWhereWithoutMembershipsInput, MatrixUserUpdateWithoutMembershipsInput>, MatrixUserUncheckedUpdateWithoutMembershipsInput>
  }

  export type MatrixRoomUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<MatrixRoomCreateWithoutMembershipsInput, MatrixRoomUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: MatrixRoomCreateOrConnectWithoutMembershipsInput
    upsert?: MatrixRoomUpsertWithoutMembershipsInput
    connect?: MatrixRoomWhereUniqueInput
    update?: XOR<XOR<MatrixRoomUpdateToOneWithWhereWithoutMembershipsInput, MatrixRoomUpdateWithoutMembershipsInput>, MatrixRoomUncheckedUpdateWithoutMembershipsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserNoteCreateWithoutUserInput = {
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    lastEditedBy?: string | null
  }

  export type UserNoteUncheckedCreateWithoutUserInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    lastEditedBy?: string | null
  }

  export type UserNoteCreateOrConnectWithoutUserInput = {
    where: UserNoteWhereUniqueInput
    create: XOR<UserNoteCreateWithoutUserInput, UserNoteUncheckedCreateWithoutUserInput>
  }

  export type UserNoteCreateManyUserInputEnvelope = {
    data: UserNoteCreateManyUserInput | UserNoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserGroupCreateWithoutUserInput = {
    group: GroupCreateNestedOneWithoutUsersInput
  }

  export type UserGroupUncheckedCreateWithoutUserInput = {
    groupId: number
  }

  export type UserGroupCreateOrConnectWithoutUserInput = {
    where: UserGroupWhereUniqueInput
    create: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput>
  }

  export type UserGroupCreateManyUserInputEnvelope = {
    data: UserGroupCreateManyUserInput | UserGroupCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ModeratorPermissionCreateWithoutUserInput = {
    permissionType: string
    permissionValue?: string | null
    createdAt?: Date | string
    createdBy: string
  }

  export type ModeratorPermissionUncheckedCreateWithoutUserInput = {
    id?: number
    permissionType: string
    permissionValue?: string | null
    createdAt?: Date | string
    createdBy: string
  }

  export type ModeratorPermissionCreateOrConnectWithoutUserInput = {
    where: ModeratorPermissionWhereUniqueInput
    create: XOR<ModeratorPermissionCreateWithoutUserInput, ModeratorPermissionUncheckedCreateWithoutUserInput>
  }

  export type ModeratorPermissionCreateManyUserInputEnvelope = {
    data: ModeratorPermissionCreateManyUserInput | ModeratorPermissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserInvitationCreateWithoutInviterInput = {
    inviteeEmail: string
    inviteeName?: string | null
    inviteePhone?: string | null
    roomIds?: UserInvitationCreateroomIdsInput | string[]
    status?: string
    inviteToken?: string | null
    message?: string | null
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationUncheckedCreateWithoutInviterInput = {
    id?: number
    inviteeEmail: string
    inviteeName?: string | null
    inviteePhone?: string | null
    roomIds?: UserInvitationCreateroomIdsInput | string[]
    status?: string
    inviteToken?: string | null
    message?: string | null
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationCreateOrConnectWithoutInviterInput = {
    where: UserInvitationWhereUniqueInput
    create: XOR<UserInvitationCreateWithoutInviterInput, UserInvitationUncheckedCreateWithoutInviterInput>
  }

  export type UserInvitationCreateManyInviterInputEnvelope = {
    data: UserInvitationCreateManyInviterInput | UserInvitationCreateManyInviterInput[]
    skipDuplicates?: boolean
  }

  export type UserNoteUpsertWithWhereUniqueWithoutUserInput = {
    where: UserNoteWhereUniqueInput
    update: XOR<UserNoteUpdateWithoutUserInput, UserNoteUncheckedUpdateWithoutUserInput>
    create: XOR<UserNoteCreateWithoutUserInput, UserNoteUncheckedCreateWithoutUserInput>
  }

  export type UserNoteUpdateWithWhereUniqueWithoutUserInput = {
    where: UserNoteWhereUniqueInput
    data: XOR<UserNoteUpdateWithoutUserInput, UserNoteUncheckedUpdateWithoutUserInput>
  }

  export type UserNoteUpdateManyWithWhereWithoutUserInput = {
    where: UserNoteScalarWhereInput
    data: XOR<UserNoteUpdateManyMutationInput, UserNoteUncheckedUpdateManyWithoutUserInput>
  }

  export type UserNoteScalarWhereInput = {
    AND?: UserNoteScalarWhereInput | UserNoteScalarWhereInput[]
    OR?: UserNoteScalarWhereInput[]
    NOT?: UserNoteScalarWhereInput | UserNoteScalarWhereInput[]
    id?: IntFilter<"UserNote"> | number
    userId?: IntFilter<"UserNote"> | number
    content?: StringFilter<"UserNote"> | string
    createdAt?: DateTimeFilter<"UserNote"> | Date | string
    updatedAt?: DateTimeFilter<"UserNote"> | Date | string
    createdBy?: StringFilter<"UserNote"> | string
    lastEditedBy?: StringNullableFilter<"UserNote"> | string | null
  }

  export type UserGroupUpsertWithWhereUniqueWithoutUserInput = {
    where: UserGroupWhereUniqueInput
    update: XOR<UserGroupUpdateWithoutUserInput, UserGroupUncheckedUpdateWithoutUserInput>
    create: XOR<UserGroupCreateWithoutUserInput, UserGroupUncheckedCreateWithoutUserInput>
  }

  export type UserGroupUpdateWithWhereUniqueWithoutUserInput = {
    where: UserGroupWhereUniqueInput
    data: XOR<UserGroupUpdateWithoutUserInput, UserGroupUncheckedUpdateWithoutUserInput>
  }

  export type UserGroupUpdateManyWithWhereWithoutUserInput = {
    where: UserGroupScalarWhereInput
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyWithoutUserInput>
  }

  export type UserGroupScalarWhereInput = {
    AND?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
    OR?: UserGroupScalarWhereInput[]
    NOT?: UserGroupScalarWhereInput | UserGroupScalarWhereInput[]
    userId?: IntFilter<"UserGroup"> | number
    groupId?: IntFilter<"UserGroup"> | number
  }

  export type ModeratorPermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: ModeratorPermissionWhereUniqueInput
    update: XOR<ModeratorPermissionUpdateWithoutUserInput, ModeratorPermissionUncheckedUpdateWithoutUserInput>
    create: XOR<ModeratorPermissionCreateWithoutUserInput, ModeratorPermissionUncheckedCreateWithoutUserInput>
  }

  export type ModeratorPermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: ModeratorPermissionWhereUniqueInput
    data: XOR<ModeratorPermissionUpdateWithoutUserInput, ModeratorPermissionUncheckedUpdateWithoutUserInput>
  }

  export type ModeratorPermissionUpdateManyWithWhereWithoutUserInput = {
    where: ModeratorPermissionScalarWhereInput
    data: XOR<ModeratorPermissionUpdateManyMutationInput, ModeratorPermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type ModeratorPermissionScalarWhereInput = {
    AND?: ModeratorPermissionScalarWhereInput | ModeratorPermissionScalarWhereInput[]
    OR?: ModeratorPermissionScalarWhereInput[]
    NOT?: ModeratorPermissionScalarWhereInput | ModeratorPermissionScalarWhereInput[]
    id?: IntFilter<"ModeratorPermission"> | number
    userId?: IntFilter<"ModeratorPermission"> | number
    permissionType?: StringFilter<"ModeratorPermission"> | string
    permissionValue?: StringNullableFilter<"ModeratorPermission"> | string | null
    createdAt?: DateTimeFilter<"ModeratorPermission"> | Date | string
    createdBy?: StringFilter<"ModeratorPermission"> | string
  }

  export type UserInvitationUpsertWithWhereUniqueWithoutInviterInput = {
    where: UserInvitationWhereUniqueInput
    update: XOR<UserInvitationUpdateWithoutInviterInput, UserInvitationUncheckedUpdateWithoutInviterInput>
    create: XOR<UserInvitationCreateWithoutInviterInput, UserInvitationUncheckedCreateWithoutInviterInput>
  }

  export type UserInvitationUpdateWithWhereUniqueWithoutInviterInput = {
    where: UserInvitationWhereUniqueInput
    data: XOR<UserInvitationUpdateWithoutInviterInput, UserInvitationUncheckedUpdateWithoutInviterInput>
  }

  export type UserInvitationUpdateManyWithWhereWithoutInviterInput = {
    where: UserInvitationScalarWhereInput
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyWithoutInviterInput>
  }

  export type UserInvitationScalarWhereInput = {
    AND?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
    OR?: UserInvitationScalarWhereInput[]
    NOT?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
    id?: IntFilter<"UserInvitation"> | number
    inviterUserId?: IntNullableFilter<"UserInvitation"> | number | null
    inviteeEmail?: StringFilter<"UserInvitation"> | string
    inviteeName?: StringNullableFilter<"UserInvitation"> | string | null
    inviteePhone?: StringNullableFilter<"UserInvitation"> | string | null
    roomIds?: StringNullableListFilter<"UserInvitation">
    status?: StringFilter<"UserInvitation"> | string
    inviteToken?: StringNullableFilter<"UserInvitation"> | string | null
    message?: StringNullableFilter<"UserInvitation"> | string | null
    expiresAt?: DateTimeFilter<"UserInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"UserInvitation"> | Date | string | null
    createdAt?: DateTimeFilter<"UserInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"UserInvitation"> | Date | string
  }

  export type UserCreateWithoutSentInvitationsInput = {
    username?: string | null
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: Date | string
    lastLogin?: Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: string | null
    signalIdentity?: string | null
    matrixUsername?: string | null
    notes?: UserNoteCreateNestedManyWithoutUserInput
    groups?: UserGroupCreateNestedManyWithoutUserInput
    moderatorPermissions?: ModeratorPermissionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentInvitationsInput = {
    id?: number
    username?: string | null
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: Date | string
    lastLogin?: Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: string | null
    signalIdentity?: string | null
    matrixUsername?: string | null
    notes?: UserNoteUncheckedCreateNestedManyWithoutUserInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    moderatorPermissions?: ModeratorPermissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
  }

  export type UserUpsertWithoutSentInvitationsInput = {
    update: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type UserUpdateWithoutSentInvitationsInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isModerator?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: NullableStringFieldUpdateOperationsInput | string | null
    signalIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    matrixUsername?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: UserNoteUpdateManyWithoutUserNestedInput
    groups?: UserGroupUpdateManyWithoutUserNestedInput
    moderatorPermissions?: ModeratorPermissionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentInvitationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isModerator?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: NullableStringFieldUpdateOperationsInput | string | null
    signalIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    matrixUsername?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: UserNoteUncheckedUpdateManyWithoutUserNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    moderatorPermissions?: ModeratorPermissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotesInput = {
    username?: string | null
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: Date | string
    lastLogin?: Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: string | null
    signalIdentity?: string | null
    matrixUsername?: string | null
    groups?: UserGroupCreateNestedManyWithoutUserInput
    moderatorPermissions?: ModeratorPermissionCreateNestedManyWithoutUserInput
    sentInvitations?: UserInvitationCreateNestedManyWithoutInviterInput
  }

  export type UserUncheckedCreateWithoutNotesInput = {
    id?: number
    username?: string | null
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: Date | string
    lastLogin?: Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: string | null
    signalIdentity?: string | null
    matrixUsername?: string | null
    groups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    moderatorPermissions?: ModeratorPermissionUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: UserInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type UserCreateOrConnectWithoutNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
  }

  export type UserUpsertWithoutNotesInput = {
    update: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateWithoutNotesInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isModerator?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: NullableStringFieldUpdateOperationsInput | string | null
    signalIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    matrixUsername?: NullableStringFieldUpdateOperationsInput | string | null
    groups?: UserGroupUpdateManyWithoutUserNestedInput
    moderatorPermissions?: ModeratorPermissionUpdateManyWithoutUserNestedInput
    sentInvitations?: UserInvitationUpdateManyWithoutInviterNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isModerator?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: NullableStringFieldUpdateOperationsInput | string | null
    signalIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    matrixUsername?: NullableStringFieldUpdateOperationsInput | string | null
    groups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    moderatorPermissions?: ModeratorPermissionUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: UserInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type UserGroupCreateWithoutGroupInput = {
    user: UserCreateNestedOneWithoutGroupsInput
  }

  export type UserGroupUncheckedCreateWithoutGroupInput = {
    userId: number
  }

  export type UserGroupCreateOrConnectWithoutGroupInput = {
    where: UserGroupWhereUniqueInput
    create: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput>
  }

  export type UserGroupCreateManyGroupInputEnvelope = {
    data: UserGroupCreateManyGroupInput | UserGroupCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserGroupUpsertWithWhereUniqueWithoutGroupInput = {
    where: UserGroupWhereUniqueInput
    update: XOR<UserGroupUpdateWithoutGroupInput, UserGroupUncheckedUpdateWithoutGroupInput>
    create: XOR<UserGroupCreateWithoutGroupInput, UserGroupUncheckedCreateWithoutGroupInput>
  }

  export type UserGroupUpdateWithWhereUniqueWithoutGroupInput = {
    where: UserGroupWhereUniqueInput
    data: XOR<UserGroupUpdateWithoutGroupInput, UserGroupUncheckedUpdateWithoutGroupInput>
  }

  export type UserGroupUpdateManyWithWhereWithoutGroupInput = {
    where: UserGroupScalarWhereInput
    data: XOR<UserGroupUpdateManyMutationInput, UserGroupUncheckedUpdateManyWithoutGroupInput>
  }

  export type UserCreateWithoutGroupsInput = {
    username?: string | null
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: Date | string
    lastLogin?: Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: string | null
    signalIdentity?: string | null
    matrixUsername?: string | null
    notes?: UserNoteCreateNestedManyWithoutUserInput
    moderatorPermissions?: ModeratorPermissionCreateNestedManyWithoutUserInput
    sentInvitations?: UserInvitationCreateNestedManyWithoutInviterInput
  }

  export type UserUncheckedCreateWithoutGroupsInput = {
    id?: number
    username?: string | null
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: Date | string
    lastLogin?: Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: string | null
    signalIdentity?: string | null
    matrixUsername?: string | null
    notes?: UserNoteUncheckedCreateNestedManyWithoutUserInput
    moderatorPermissions?: ModeratorPermissionUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: UserInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type UserCreateOrConnectWithoutGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
  }

  export type GroupCreateWithoutUsersInput = {
    name: string
    description?: string | null
    authentikGroupId?: string | null
  }

  export type GroupUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    authentikGroupId?: string | null
  }

  export type GroupCreateOrConnectWithoutUsersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutGroupsInput = {
    update: XOR<UserUpdateWithoutGroupsInput, UserUncheckedUpdateWithoutGroupsInput>
    create: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupsInput, UserUncheckedUpdateWithoutGroupsInput>
  }

  export type UserUpdateWithoutGroupsInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isModerator?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: NullableStringFieldUpdateOperationsInput | string | null
    signalIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    matrixUsername?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: UserNoteUpdateManyWithoutUserNestedInput
    moderatorPermissions?: ModeratorPermissionUpdateManyWithoutUserNestedInput
    sentInvitations?: UserInvitationUpdateManyWithoutInviterNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isModerator?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: NullableStringFieldUpdateOperationsInput | string | null
    signalIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    matrixUsername?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: UserNoteUncheckedUpdateManyWithoutUserNestedInput
    moderatorPermissions?: ModeratorPermissionUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: UserInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type GroupUpsertWithoutUsersInput = {
    update: XOR<GroupUpdateWithoutUsersInput, GroupUncheckedUpdateWithoutUsersInput>
    create: XOR<GroupCreateWithoutUsersInput, GroupUncheckedCreateWithoutUsersInput>
    where?: GroupWhereInput
  }

  export type GroupUpdateToOneWithWhereWithoutUsersInput = {
    where?: GroupWhereInput
    data: XOR<GroupUpdateWithoutUsersInput, GroupUncheckedUpdateWithoutUsersInput>
  }

  export type GroupUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authentikGroupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authentikGroupId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutModeratorPermissionsInput = {
    username?: string | null
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: Date | string
    lastLogin?: Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: string | null
    signalIdentity?: string | null
    matrixUsername?: string | null
    notes?: UserNoteCreateNestedManyWithoutUserInput
    groups?: UserGroupCreateNestedManyWithoutUserInput
    sentInvitations?: UserInvitationCreateNestedManyWithoutInviterInput
  }

  export type UserUncheckedCreateWithoutModeratorPermissionsInput = {
    id?: number
    username?: string | null
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    password?: string | null
    isActive?: boolean
    isAdmin?: boolean
    isModerator?: boolean
    dateJoined?: Date | string
    lastLogin?: Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: string | null
    signalIdentity?: string | null
    matrixUsername?: string | null
    notes?: UserNoteUncheckedCreateNestedManyWithoutUserInput
    groups?: UserGroupUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: UserInvitationUncheckedCreateNestedManyWithoutInviterInput
  }

  export type UserCreateOrConnectWithoutModeratorPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModeratorPermissionsInput, UserUncheckedCreateWithoutModeratorPermissionsInput>
  }

  export type UserUpsertWithoutModeratorPermissionsInput = {
    update: XOR<UserUpdateWithoutModeratorPermissionsInput, UserUncheckedUpdateWithoutModeratorPermissionsInput>
    create: XOR<UserCreateWithoutModeratorPermissionsInput, UserUncheckedCreateWithoutModeratorPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModeratorPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModeratorPermissionsInput, UserUncheckedUpdateWithoutModeratorPermissionsInput>
  }

  export type UserUpdateWithoutModeratorPermissionsInput = {
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isModerator?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: NullableStringFieldUpdateOperationsInput | string | null
    signalIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    matrixUsername?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: UserNoteUpdateManyWithoutUserNestedInput
    groups?: UserGroupUpdateManyWithoutUserNestedInput
    sentInvitations?: UserInvitationUpdateManyWithoutInviterNestedInput
  }

  export type UserUncheckedUpdateWithoutModeratorPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isModerator?: BoolFieldUpdateOperationsInput | boolean
    dateJoined?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    authentikId?: NullableStringFieldUpdateOperationsInput | string | null
    signalIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    matrixUsername?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: UserNoteUncheckedUpdateManyWithoutUserNestedInput
    groups?: UserGroupUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: UserInvitationUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type MatrixRoomMembershipCreateWithoutUserInput = {
    membershipStatus?: string
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: MatrixRoomCreateNestedOneWithoutMembershipsInput
  }

  export type MatrixRoomMembershipUncheckedCreateWithoutUserInput = {
    id?: number
    roomId: string
    membershipStatus?: string
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixRoomMembershipCreateOrConnectWithoutUserInput = {
    where: MatrixRoomMembershipWhereUniqueInput
    create: XOR<MatrixRoomMembershipCreateWithoutUserInput, MatrixRoomMembershipUncheckedCreateWithoutUserInput>
  }

  export type MatrixRoomMembershipCreateManyUserInputEnvelope = {
    data: MatrixRoomMembershipCreateManyUserInput | MatrixRoomMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MatrixRoomMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: MatrixRoomMembershipWhereUniqueInput
    update: XOR<MatrixRoomMembershipUpdateWithoutUserInput, MatrixRoomMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<MatrixRoomMembershipCreateWithoutUserInput, MatrixRoomMembershipUncheckedCreateWithoutUserInput>
  }

  export type MatrixRoomMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: MatrixRoomMembershipWhereUniqueInput
    data: XOR<MatrixRoomMembershipUpdateWithoutUserInput, MatrixRoomMembershipUncheckedUpdateWithoutUserInput>
  }

  export type MatrixRoomMembershipUpdateManyWithWhereWithoutUserInput = {
    where: MatrixRoomMembershipScalarWhereInput
    data: XOR<MatrixRoomMembershipUpdateManyMutationInput, MatrixRoomMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type MatrixRoomMembershipScalarWhereInput = {
    AND?: MatrixRoomMembershipScalarWhereInput | MatrixRoomMembershipScalarWhereInput[]
    OR?: MatrixRoomMembershipScalarWhereInput[]
    NOT?: MatrixRoomMembershipScalarWhereInput | MatrixRoomMembershipScalarWhereInput[]
    id?: IntFilter<"MatrixRoomMembership"> | number
    roomId?: StringFilter<"MatrixRoomMembership"> | string
    userId?: StringFilter<"MatrixRoomMembership"> | string
    membershipStatus?: StringFilter<"MatrixRoomMembership"> | string
    joinedAt?: DateTimeNullableFilter<"MatrixRoomMembership"> | Date | string | null
    createdAt?: DateTimeFilter<"MatrixRoomMembership"> | Date | string
    updatedAt?: DateTimeFilter<"MatrixRoomMembership"> | Date | string
  }

  export type MatrixRoomMembershipCreateWithoutRoomInput = {
    membershipStatus?: string
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: MatrixUserCreateNestedOneWithoutMembershipsInput
  }

  export type MatrixRoomMembershipUncheckedCreateWithoutRoomInput = {
    id?: number
    userId: string
    membershipStatus?: string
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixRoomMembershipCreateOrConnectWithoutRoomInput = {
    where: MatrixRoomMembershipWhereUniqueInput
    create: XOR<MatrixRoomMembershipCreateWithoutRoomInput, MatrixRoomMembershipUncheckedCreateWithoutRoomInput>
  }

  export type MatrixRoomMembershipCreateManyRoomInputEnvelope = {
    data: MatrixRoomMembershipCreateManyRoomInput | MatrixRoomMembershipCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type MatrixRoomMembershipUpsertWithWhereUniqueWithoutRoomInput = {
    where: MatrixRoomMembershipWhereUniqueInput
    update: XOR<MatrixRoomMembershipUpdateWithoutRoomInput, MatrixRoomMembershipUncheckedUpdateWithoutRoomInput>
    create: XOR<MatrixRoomMembershipCreateWithoutRoomInput, MatrixRoomMembershipUncheckedCreateWithoutRoomInput>
  }

  export type MatrixRoomMembershipUpdateWithWhereUniqueWithoutRoomInput = {
    where: MatrixRoomMembershipWhereUniqueInput
    data: XOR<MatrixRoomMembershipUpdateWithoutRoomInput, MatrixRoomMembershipUncheckedUpdateWithoutRoomInput>
  }

  export type MatrixRoomMembershipUpdateManyWithWhereWithoutRoomInput = {
    where: MatrixRoomMembershipScalarWhereInput
    data: XOR<MatrixRoomMembershipUpdateManyMutationInput, MatrixRoomMembershipUncheckedUpdateManyWithoutRoomInput>
  }

  export type MatrixUserCreateWithoutMembershipsInput = {
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    isSignalUser?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixUserUncheckedCreateWithoutMembershipsInput = {
    userId: string
    displayName?: string | null
    avatarUrl?: string | null
    isSignalUser?: boolean
    lastSeen?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixUserCreateOrConnectWithoutMembershipsInput = {
    where: MatrixUserWhereUniqueInput
    create: XOR<MatrixUserCreateWithoutMembershipsInput, MatrixUserUncheckedCreateWithoutMembershipsInput>
  }

  export type MatrixRoomCreateWithoutMembershipsInput = {
    roomId: string
    name?: string | null
    displayName?: string | null
    topic?: string | null
    canonicalAlias?: string | null
    memberCount?: number
    roomType?: string | null
    isDirect?: boolean
    isEncrypted?: boolean
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixRoomUncheckedCreateWithoutMembershipsInput = {
    roomId: string
    name?: string | null
    displayName?: string | null
    topic?: string | null
    canonicalAlias?: string | null
    memberCount?: number
    roomType?: string | null
    isDirect?: boolean
    isEncrypted?: boolean
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixRoomCreateOrConnectWithoutMembershipsInput = {
    where: MatrixRoomWhereUniqueInput
    create: XOR<MatrixRoomCreateWithoutMembershipsInput, MatrixRoomUncheckedCreateWithoutMembershipsInput>
  }

  export type MatrixUserUpsertWithoutMembershipsInput = {
    update: XOR<MatrixUserUpdateWithoutMembershipsInput, MatrixUserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<MatrixUserCreateWithoutMembershipsInput, MatrixUserUncheckedCreateWithoutMembershipsInput>
    where?: MatrixUserWhereInput
  }

  export type MatrixUserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: MatrixUserWhereInput
    data: XOR<MatrixUserUpdateWithoutMembershipsInput, MatrixUserUncheckedUpdateWithoutMembershipsInput>
  }

  export type MatrixUserUpdateWithoutMembershipsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignalUser?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixUserUncheckedUpdateWithoutMembershipsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isSignalUser?: BoolFieldUpdateOperationsInput | boolean
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomUpsertWithoutMembershipsInput = {
    update: XOR<MatrixRoomUpdateWithoutMembershipsInput, MatrixRoomUncheckedUpdateWithoutMembershipsInput>
    create: XOR<MatrixRoomCreateWithoutMembershipsInput, MatrixRoomUncheckedCreateWithoutMembershipsInput>
    where?: MatrixRoomWhereInput
  }

  export type MatrixRoomUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: MatrixRoomWhereInput
    data: XOR<MatrixRoomUpdateWithoutMembershipsInput, MatrixRoomUncheckedUpdateWithoutMembershipsInput>
  }

  export type MatrixRoomUpdateWithoutMembershipsInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalAlias?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomUncheckedUpdateWithoutMembershipsInput = {
    roomId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalAlias?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: IntFieldUpdateOperationsInput | number
    roomType?: NullableStringFieldUpdateOperationsInput | string | null
    isDirect?: BoolFieldUpdateOperationsInput | boolean
    isEncrypted?: BoolFieldUpdateOperationsInput | boolean
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNoteCreateManyUserInput = {
    id?: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: string
    lastEditedBy?: string | null
  }

  export type UserGroupCreateManyUserInput = {
    groupId: number
  }

  export type ModeratorPermissionCreateManyUserInput = {
    id?: number
    permissionType: string
    permissionValue?: string | null
    createdAt?: Date | string
    createdBy: string
  }

  export type UserInvitationCreateManyInviterInput = {
    id?: number
    inviteeEmail: string
    inviteeName?: string | null
    inviteePhone?: string | null
    roomIds?: UserInvitationCreateroomIdsInput | string[]
    status?: string
    inviteToken?: string | null
    message?: string | null
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNoteUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    lastEditedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserNoteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    lastEditedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserNoteUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    lastEditedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserGroupUpdateWithoutUserInput = {
    group?: GroupUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserGroupUncheckedUpdateWithoutUserInput = {
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type UserGroupUncheckedUpdateManyWithoutUserInput = {
    groupId?: IntFieldUpdateOperationsInput | number
  }

  export type ModeratorPermissionUpdateWithoutUserInput = {
    permissionType?: StringFieldUpdateOperationsInput | string
    permissionValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ModeratorPermissionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionType?: StringFieldUpdateOperationsInput | string
    permissionValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type ModeratorPermissionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionType?: StringFieldUpdateOperationsInput | string
    permissionValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserInvitationUpdateWithoutInviterInput = {
    inviteeEmail?: StringFieldUpdateOperationsInput | string
    inviteeName?: NullableStringFieldUpdateOperationsInput | string | null
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    roomIds?: UserInvitationUpdateroomIdsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUncheckedUpdateWithoutInviterInput = {
    id?: IntFieldUpdateOperationsInput | number
    inviteeEmail?: StringFieldUpdateOperationsInput | string
    inviteeName?: NullableStringFieldUpdateOperationsInput | string | null
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    roomIds?: UserInvitationUpdateroomIdsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUncheckedUpdateManyWithoutInviterInput = {
    id?: IntFieldUpdateOperationsInput | number
    inviteeEmail?: StringFieldUpdateOperationsInput | string
    inviteeName?: NullableStringFieldUpdateOperationsInput | string | null
    inviteePhone?: NullableStringFieldUpdateOperationsInput | string | null
    roomIds?: UserInvitationUpdateroomIdsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGroupCreateManyGroupInput = {
    userId: number
  }

  export type UserGroupUpdateWithoutGroupInput = {
    user?: UserUpdateOneRequiredWithoutGroupsNestedInput
  }

  export type UserGroupUncheckedUpdateWithoutGroupInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserGroupUncheckedUpdateManyWithoutGroupInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type MatrixRoomMembershipCreateManyUserInput = {
    id?: number
    roomId: string
    membershipStatus?: string
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixRoomMembershipUpdateWithoutUserInput = {
    membershipStatus?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: MatrixRoomUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type MatrixRoomMembershipUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: StringFieldUpdateOperationsInput | string
    membershipStatus?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomMembershipUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: StringFieldUpdateOperationsInput | string
    membershipStatus?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomMembershipCreateManyRoomInput = {
    id?: number
    userId: string
    membershipStatus?: string
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatrixRoomMembershipUpdateWithoutRoomInput = {
    membershipStatus?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: MatrixUserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type MatrixRoomMembershipUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    membershipStatus?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatrixRoomMembershipUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    membershipStatus?: StringFieldUpdateOperationsInput | string
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}