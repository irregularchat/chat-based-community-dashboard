#!/usr/bin/env python3
"""
Test script to decrypt Matrix messages using security key and recovery passphrase from .env
Based on Matrix community solutions for encrypted message handling.
"""
import asyncio
import sys
import os
import base64
sys.path.insert(0, '/app')

from app.utils.matrix_actions import get_matrix_client
from app.utils.config import Config
from nio import AsyncClient, LoginResponse, SyncResponse
from nio.store import SqliteStore

async def test_security_key_decryption():
    print("üß™ Testing Matrix message decryption with security key...")
    print("üîë Using security key and recovery passphrase from .env configuration")
    
    # Use the room ID we know contains Sac's messages
    room_id = "!XXXXXXXXXXXXXXXXXX:example.com"
    
    print(f"\nüéØ Attempting decryption for room: {room_id}")
    print("This uses the security key and recovery passphrase for enhanced decryption")
    
    try:
        # Get security configuration from .env
        security_key = Config.MATRIX_SECURITY_KEY
        recovery_passphrase = Config.MATRIX_RECOVERY_PASSPHRASE
        store_path = Config.MATRIX_STORE_PATH
        
        print(f"\nüìç Step 1: Loading security configuration...")
        if security_key:
            print(f"‚úÖ Security key loaded: {security_key[:20]}...")
        else:
            print(f"‚ùå No security key found in configuration")
            return
            
        if recovery_passphrase:
            print(f"‚úÖ Recovery passphrase loaded: {recovery_passphrase[:10]}...")
        else:
            print(f"‚ö†Ô∏è  No recovery passphrase found")
            
        print(f"‚úÖ Store path: {store_path}")
        
        # Create enhanced Matrix client with crypto store
        print(f"\nüìç Step 2: Creating enhanced Matrix client with crypto store...")
        
        homeserver = Config.MATRIX_HOMESERVER_URL or "https://matrix.example.com"
        user_id = Config.MATRIX_BOT_USERNAME
        access_token = Config.MATRIX_ACCESS_TOKEN
        
        if not all([homeserver, user_id, access_token]):
            print(f"‚ùå Missing Matrix configuration")
            return
            
        # Ensure store directory exists
        os.makedirs(store_path, exist_ok=True)
        
        # Create client with crypto store
        store = SqliteStore(user_id, "DEVICE_ID", store_path)
        client = AsyncClient(
            homeserver=homeserver,
            user=user_id,
            store_path=store_path,
            config=None,
            ssl=True,
            proxy=None
        )
        
        # Set access token
        client.access_token = access_token
        client.user_id = user_id
        
        print(f"‚úÖ Enhanced Matrix client created with crypto store")
        print(f"   - User: {user_id}")
        print(f"   - Homeserver: {homeserver}")
        print(f"   - Store: {store_path}")
        
        try:
            # Step 3: Import security key for decryption
            print(f"\nüìç Step 3: Importing security key for decryption...")
            
            # Process the security key (remove spaces and decode if needed)
            processed_key = security_key.replace(" ", "")
            
            # Try to use the security key for decryption setup
            if hasattr(client, 'import_keys'):
                try:
                    # Attempt to import keys using the security key
                    print(f"   üîë Attempting to import encryption keys...")
                    # This would typically require the actual key backup data
                    # For now, we'll focus on the sync and decryption process
                except Exception as e:
                    print(f"   ‚ö†Ô∏è  Key import not available or failed: {e}")
            
            # Step 4: Sync to get latest encryption keys and messages
            print(f"\nüìç Step 4: Syncing to get latest encryption keys...")
            
            # Perform initial sync to get encryption keys
            sync_response = await client.sync(timeout=10000, full_state=True)
            print(f"‚úÖ Initial sync completed: {type(sync_response).__name__}")
            
            if hasattr(sync_response, 'rooms'):
                if hasattr(sync_response.rooms, 'join') and room_id in sync_response.rooms.join:
                    room_sync = sync_response.rooms.join[room_id]
                    print(f"‚úÖ Found room in sync response")
                    
                    # Check for encrypted events in timeline
                    if hasattr(room_sync, 'timeline') and hasattr(room_sync.timeline, 'events'):
                        encrypted_events = [e for e in room_sync.timeline.events 
                                          if hasattr(e, 'type') and e.type == 'm.room.encrypted']
                        print(f"   üìä Found {len(encrypted_events)} encrypted events in sync")
            
            # Step 5: Get room messages with enhanced decryption
            print(f"\nüìç Step 5: Retrieving messages with enhanced decryption...")
            response = await client.room_messages(room_id, limit=10)
            
            if hasattr(response, 'chunk'):
                messages = response.chunk
                print(f"‚úÖ Retrieved {len(messages)} events")
                
                decrypted_count = 0
                sac_messages = []
                
                for i, event in enumerate(messages, 1):
                    sender = getattr(event, 'sender', 'Unknown')
                    event_id = getattr(event, 'event_id', 'Unknown')
                    event_type = getattr(event, 'type', 'Unknown')
                    
                    # Check for timestamp
                    timestamp = "Unknown"
                    if hasattr(event, 'server_timestamp'):
                        import datetime
                        dt = datetime.datetime.fromtimestamp(event.server_timestamp / 1000)
                        timestamp = dt.strftime('%Y-%m-%d %H:%M:%S')
                    
                    print(f"\n{i}. [{timestamp}] {sender}")
                    print(f"   Event: {event_id}")
                    print(f"   Type: {event_type}")
                    
                    # Try enhanced decryption approaches
                    decrypted_content = None
                    
                    if event_type == 'm.room.message':
                        # Already decrypted message
                        if hasattr(event, 'body'):
                            decrypted_content = event.body
                            decrypted_count += 1
                            print(f"   üí¨ Content: {decrypted_content}")
                    
                    elif event_type == 'm.room.encrypted':
                        print(f"   üîí Encrypted message - attempting enhanced decryption...")
                        
                        # Method 1: Check if already decrypted by client
                        if hasattr(event, 'decrypted_event') and event.decrypted_event:
                            decrypted = event.decrypted_event
                            if hasattr(decrypted, 'body'):
                                decrypted_content = decrypted.body
                                decrypted_count += 1
                                print(f"   üí¨ Decrypted (auto): {decrypted_content}")
                        
                        # Method 2: Try manual decryption with security key
                        elif hasattr(client, 'decrypt_event'):
                            try:
                                decrypted_event = await client.decrypt_event(event)
                                if decrypted_event and hasattr(decrypted_event, 'body'):
                                    decrypted_content = decrypted_event.body
                                    decrypted_count += 1
                                    print(f"   üí¨ Decrypted (manual): {decrypted_content}")
                            except Exception as e:
                                print(f"   ‚ùå Manual decryption failed: {e}")
                        
                        # Method 3: Try using recovery passphrase
                        if not decrypted_content and recovery_passphrase:
                            try:
                                # This would require implementing passphrase-based decryption
                                # For now, we'll note that the passphrase is available
                                print(f"   üîë Recovery passphrase available for advanced decryption")
                            except Exception as e:
                                print(f"   ‚ùå Passphrase decryption failed: {e}")
                        
                        if not decrypted_content:
                            print(f"   üîí Unable to decrypt with current methods")
                    
                    else:
                        print(f"   ‚ÑπÔ∏è  Non-message event: {event_type}")
                    
                    # Check if this is from Sac and looks like a 4-digit number
                    if (sender == "@signal_XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX:example.com" 
                        and decrypted_content):
                        sac_messages.append({
                            'timestamp': timestamp,
                            'content': decrypted_content,
                            'event_id': event_id
                        })
                        
                        if decrypted_content.strip().isdigit() and len(decrypted_content.strip()) == 4:
                            print(f"   üéØ FOUND: Sac's 4-digit number: {decrypted_content}")
                
                print(f"\nüìä Enhanced Decryption Results:")
                print(f"   - Total events: {len(messages)}")
                print(f"   - Successfully decrypted: {decrypted_count}")
                print(f"   - Messages from Sac: {len(sac_messages)}")
                
                if sac_messages:
                    print(f"\nüì± Sac's Messages:")
                    for msg in sac_messages:
                        print(f"   [{msg['timestamp']}] {msg['content']}")
                        if msg['content'].strip().isdigit() and len(msg['content'].strip()) == 4:
                            print(f"   üéØ 4-digit number found: {msg['content']}")
                
                if decrypted_count == 0:
                    print(f"\nüí° Next Steps for Full Decryption:")
                    print(f"   1. ‚úÖ Security key is configured")
                    print(f"   2. ‚úÖ Recovery passphrase is configured") 
                    print(f"   3. üîÑ May need to implement key backup import")
                    print(f"   4. üîÑ May need Signal bridge specific decryption")
                    print(f"   5. üîÑ Consider using Element's key export/import")
                else:
                    print(f"\n‚úÖ Successfully decrypted {decrypted_count} messages!")
                
            else:
                print(f"‚ùå Invalid response format")
                
        finally:
            await client.close()
            
    except Exception as e:
        print(f"‚ùå EXCEPTION: {e}")
        import traceback
        traceback.print_exc()

if __name__ == '__main__':
    asyncio.run(test_security_key_decryption()) 